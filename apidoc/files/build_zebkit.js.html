<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build/zebkit.js - zebkit</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/dune-light.css">
    <link rel="stylesheet" href="../assets/css/main.light.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc" style="padding-top:16px;">
    <div class="yui3-g">
        <table style="width:auto">
            <tr style="background:none">
                <td valign="top" align="left" >
                    <div id="sidebar" class="yui3-u">
                        <div id="classes" class="sidebox">
                            <div class="hd">
                                <h2 class="no-toc">All packages</h2>
                            </div>
                            <div class="bd">
                                <ul>
                                        <li>
                                            <a href="../classes/environment.html">environment</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.html">zebkit</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.data.html">zebkit.data</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.draw.html">zebkit.draw</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.io.html">zebkit.io</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.layout.html">zebkit.layout</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.html">zebkit.ui</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.date.html">zebkit.ui.date</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.design.html">zebkit.ui.design</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.event.html">zebkit.ui.event</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.grid.html">zebkit.ui.grid</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.tree.html">zebkit.ui.tree</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.vk.html">zebkit.ui.vk</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.ui.web.html">zebkit.ui.web</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.util.html">zebkit.util</a>
                                        </li>
                                        <li>
                                            <a href="../classes/zebkit.web.html">zebkit.web</a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                        
                        
                        <div id="classes" class="sidebox">
                            <div class="hd">
                                <table border="0" cellpadding="0" cellspecing="0">
                                    <tr>
                                        <td>
                                            <h2 class="no-toc">All classes</h2>
                                        </td>
                                        <td>
                                            <input id="search" style="width:95%;" type=text value=""/>
                                        </td>
                                    </tr>
                                </table>
                            </div>
                            <div class="bd">
                                <table id="allClasses" style="background:none;" border="0">
                                        <tr class="classNameCell" className="zebkit.Class" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Class.html">zebkit.Class</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.Class.zObject" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Class.zObject.html">zebkit.Class.zObject</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.DataModel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.DataModel.html">zebkit.data.DataModel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.Item" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.Item.html">zebkit.data.Item</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.ListModel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.ListModel.html">zebkit.data.ListModel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.Matrix" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.Matrix.html">zebkit.data.Matrix</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.SingleLineTxt" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.SingleLineTxt.html">zebkit.data.SingleLineTxt</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.Text" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.Text.html">zebkit.data.Text</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.TextModel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.TextModel.html">zebkit.data.TextModel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.data.TreeModel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.data.TreeModel.html">zebkit.data.TreeModel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.DoIt" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.DoIt.html">zebkit.DoIt</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.ArrowView" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.ArrowView.html">zebkit.draw.ArrowView</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.BaseTextRender" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.BaseTextRender.html">zebkit.draw.BaseTextRender</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.BaseViewProvider" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.BaseViewProvider.html">zebkit.draw.BaseViewProvider</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Border" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Border.html">zebkit.draw.Border</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.CompositeView" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.CompositeView.html">zebkit.draw.CompositeView</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Dotted" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Dotted.html">zebkit.draw.Dotted</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Etched" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Etched.html">zebkit.draw.Etched</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Gradient" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Gradient.html">zebkit.draw.Gradient</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Line" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Line.html">zebkit.draw.Line</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.PasswordText" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.PasswordText.html">zebkit.draw.PasswordText</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Pattern" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Pattern.html">zebkit.draw.Pattern</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Picture" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Picture.html">zebkit.draw.Picture</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Radial" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Radial.html">zebkit.draw.Radial</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.RadioView" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.RadioView.html">zebkit.draw.RadioView</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Raised" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Raised.html">zebkit.draw.Raised</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Render" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Render.html">zebkit.draw.Render</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.RoundBorder" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.RoundBorder.html">zebkit.draw.RoundBorder</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Shape" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Shape.html">zebkit.draw.Shape</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.StringRender" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.StringRender.html">zebkit.draw.StringRender</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.Sunken" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.Sunken.html">zebkit.draw.Sunken</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.TextRender" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.TextRender.html">zebkit.draw.TextRender</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.TitledBorder" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.TitledBorder.html">zebkit.draw.TitledBorder</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.ToggleView" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.ToggleView.html">zebkit.draw.ToggleView</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.TriangleShape" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.TriangleShape.html">zebkit.draw.TriangleShape</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.View" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.View.html">zebkit.draw.View</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.draw.ViewSet" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.draw.ViewSet.html">zebkit.draw.ViewSet</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.Dummy" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Dummy.html">zebkit.Dummy</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.EventProducer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.EventProducer.html">zebkit.EventProducer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.Font" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Font.html">zebkit.Font</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.Interface" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Interface.html">zebkit.Interface</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.io.HTTP" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.io.HTTP.html">zebkit.io.HTTP</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.io.JRPC" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.io.JRPC.html">zebkit.io.JRPC</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.io.Service" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.io.Service.html">zebkit.io.Service</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.io.XRPC" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.io.XRPC.html">zebkit.io.XRPC</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.BorderLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.BorderLayout.html">zebkit.layout.BorderLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.Constraints" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.Constraints.html">zebkit.layout.Constraints</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.FlowLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.FlowLayout.html">zebkit.layout.FlowLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.GridLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.GridLayout.html">zebkit.layout.GridLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.Layout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.Layout.html">zebkit.layout.Layout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.Layoutable" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.Layoutable.html">zebkit.layout.Layoutable</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.ListLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.ListLayout.html">zebkit.layout.ListLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.PercentLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.PercentLayout.html">zebkit.layout.PercentLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.RasterLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.RasterLayout.html">zebkit.layout.RasterLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.layout.StackLayout" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.layout.StackLayout.html">zebkit.layout.StackLayout</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.Package" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.Package.html">zebkit.Package</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ArrowButton" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ArrowButton.html">zebkit.ui.ArrowButton</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.BaseList" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.BaseList.html">zebkit.ui.BaseList</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.BoldLabel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.BoldLabel.html">zebkit.ui.BoldLabel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.BorderPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.BorderPan.html">zebkit.ui.BorderPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Button" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Button.html">zebkit.ui.Button</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ButtonRepeatMix" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ButtonRepeatMix.html">zebkit.ui.ButtonRepeatMix</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Checkbox" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Checkbox.html">zebkit.ui.Checkbox</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Checkbox.Box" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Checkbox.Box.html">zebkit.ui.Checkbox.Box</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.CollapsiblePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.CollapsiblePan.html">zebkit.ui.CollapsiblePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Combo" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Combo.html">zebkit.ui.Combo</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Combo.ComboPadPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Combo.ComboPadPan.html">zebkit.ui.Combo.ComboPadPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Combo.ContentPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Combo.ContentPan.html">zebkit.ui.Combo.ContentPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Combo.EditableContentPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Combo.EditableContentPan.html">zebkit.ui.Combo.EditableContentPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Combo.ReadonlyContentPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Combo.ReadonlyContentPan.html">zebkit.ui.Combo.ReadonlyContentPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.CompList" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.CompList.html">zebkit.ui.CompList</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.CompositeEvStatePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.CompositeEvStatePan.html">zebkit.ui.CompositeEvStatePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.CompRender" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.CompRender.html">zebkit.ui.CompRender</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Cursor" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Cursor.html">zebkit.ui.Cursor</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.date.DaysGrid" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.date.DaysGrid.html">zebkit.ui.date.DaysGrid</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.DecorationViews" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.DecorationViews.html">zebkit.ui.DecorationViews</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.design.FormTreeModel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.design.FormTreeModel.html">zebkit.ui.design.FormTreeModel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.design.ShaperBorder" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.design.ShaperBorder.html">zebkit.ui.design.ShaperBorder</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.design.ShaperPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.design.ShaperPan.html">zebkit.ui.design.ShaperPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.Clipboard" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.Clipboard.html">zebkit.ui.event.Clipboard</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.CompEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.CompEvent.html">zebkit.ui.event.CompEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.CursorManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.CursorManager.html">zebkit.ui.event.CursorManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.EventManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.EventManager.html">zebkit.ui.event.EventManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.FocusEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.FocusEvent.html">zebkit.ui.event.FocusEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.FocusManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.FocusManager.html">zebkit.ui.event.FocusManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.KeyEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.KeyEvent.html">zebkit.ui.event.KeyEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.Manager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.Manager.html">zebkit.ui.event.Manager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.MenuEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.MenuEvent.html">zebkit.ui.event.MenuEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.PointerEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.PointerEvent.html">zebkit.ui.event.PointerEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.ShortcutEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.ShortcutEvent.html">zebkit.ui.event.ShortcutEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.ShortcutManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.ShortcutManager.html">zebkit.ui.event.ShortcutManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.event.WinEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.event.WinEvent.html">zebkit.ui.event.WinEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.EvStatePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.EvStatePan.html">zebkit.ui.EvStatePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.BaseCaption" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.BaseCaption.html">zebkit.ui.grid.BaseCaption</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.CaptionViewProvider" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.CaptionViewProvider.html">zebkit.ui.grid.CaptionViewProvider</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.CellsVisibility" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.CellsVisibility.html">zebkit.ui.grid.CellsVisibility</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.CompGridCaption" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.CompGridCaption.html">zebkit.ui.grid.CompGridCaption</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.CompGridCaption.TitlePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.CompGridCaption.TitlePan.html">zebkit.ui.grid.CompGridCaption.TitlePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.DefEditors" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.DefEditors.html">zebkit.ui.grid.DefEditors</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.DefViews" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.DefViews.html">zebkit.ui.grid.DefViews</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.Grid" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.Grid.html">zebkit.ui.grid.Grid</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.GridCaption" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.GridCaption.html">zebkit.ui.grid.GridCaption</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.GridStretchPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.GridStretchPan.html">zebkit.ui.grid.GridStretchPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.LeftCompGridCaption" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.LeftCompGridCaption.html">zebkit.ui.grid.LeftCompGridCaption</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.LeftGridCaption" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.LeftGridCaption.html">zebkit.ui.grid.LeftGridCaption</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.Metrics" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.Metrics.html">zebkit.ui.grid.Metrics</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.grid.StrippedRows" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.grid.StrippedRows.html">zebkit.ui.grid.StrippedRows</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Group" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Group.html">zebkit.ui.Group</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ImageLabel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ImageLabel.html">zebkit.ui.ImageLabel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ImagePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ImagePan.html">zebkit.ui.ImagePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Label" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Label.html">zebkit.ui.Label</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Line" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Line.html">zebkit.ui.Line</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.LinearRulerPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.LinearRulerPan.html">zebkit.ui.LinearRulerPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Link" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Link.html">zebkit.ui.Link</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.List" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.List.html">zebkit.ui.List</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.List.ViewProvider" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.List.ViewProvider.html">zebkit.ui.List.ViewProvider</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Menu" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Menu.html">zebkit.ui.Menu</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Menubar" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Menubar.html">zebkit.ui.Menubar</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.MenuItem" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.MenuItem.html">zebkit.ui.MenuItem</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.MobileScrollMan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.MobileScrollMan.html">zebkit.ui.MobileScrollMan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Panel" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Panel.html">zebkit.ui.Panel</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PassTextField" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PassTextField.html">zebkit.ui.PassTextField</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PointRulerPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PointRulerPan.html">zebkit.ui.PointRulerPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PointRulerPan.DeltaPointsGenerator" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PointRulerPan.DeltaPointsGenerator.html">zebkit.ui.PointRulerPan.DeltaPointsGenerator</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PointRulerPan.PointsGenerator" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PointRulerPan.PointsGenerator.html">zebkit.ui.PointRulerPan.PointsGenerator</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PopupLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PopupLayer.html">zebkit.ui.PopupLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.PopupLayerMix" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.PopupLayerMix.html">zebkit.ui.PopupLayerMix</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Progress" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Progress.html">zebkit.ui.Progress</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Radiobox" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Radiobox.html">zebkit.ui.Radiobox</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.RootLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.RootLayer.html">zebkit.ui.RootLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.RootLayerMix" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.RootLayerMix.html">zebkit.ui.RootLayerMix</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.RulePan.NumLabels" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.RulePan.NumLabels.html">zebkit.ui.RulePan.NumLabels</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.RulePan.PercentageLabels" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.RulePan.PercentageLabels.html">zebkit.ui.RulePan.PercentageLabels</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.RulerPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.RulerPan.html">zebkit.ui.RulerPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Scroll" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Scroll.html">zebkit.ui.Scroll</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ScrollManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ScrollManager.html">zebkit.ui.ScrollManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ScrollPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ScrollPan.html">zebkit.ui.ScrollPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Slider" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Slider.html">zebkit.ui.Slider</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.SplitPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.SplitPan.html">zebkit.ui.SplitPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.StackPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.StackPan.html">zebkit.ui.StackPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.StatePan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.StatePan.html">zebkit.ui.StatePan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.StatusBar" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.StatusBar.html">zebkit.ui.StatusBar</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Tabs" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Tabs.html">zebkit.ui.Tabs</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Tabs.TabView" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Tabs.TabView.html">zebkit.ui.Tabs.TabView</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.TextArea" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.TextArea.html">zebkit.ui.TextArea</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.TextField" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.TextField.html">zebkit.ui.TextField</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.TextField.HintRender" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.TextField.HintRender.html">zebkit.ui.TextField.HintRender</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Toolbar" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Toolbar.html">zebkit.ui.Toolbar</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Tooltip" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Tooltip.html">zebkit.ui.Tooltip</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.TooltipManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.TooltipManager.html">zebkit.ui.TooltipManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.tree.BaseTree" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.tree.BaseTree.html">zebkit.ui.tree.BaseTree</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.tree.CompTree" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.tree.CompTree.html">zebkit.ui.tree.CompTree</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.tree.DefEditors" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.tree.DefEditors.html">zebkit.ui.tree.DefEditors</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.tree.DefViews" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.tree.DefViews.html">zebkit.ui.tree.DefViews</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.tree.Tree" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.tree.Tree.html">zebkit.ui.tree.Tree</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.ViewPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.ViewPan.html">zebkit.ui.ViewPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.CursorManager" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.CursorManager.html">zebkit.ui.web.CursorManager</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlCanvas" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlCanvas.html">zebkit.ui.web.HtmlCanvas</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlElement" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlElement.html">zebkit.ui.web.HtmlElement</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlFocusableElement" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlFocusableElement.html">zebkit.ui.web.HtmlFocusableElement</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlLayer.html">zebkit.ui.web.HtmlLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlLink" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlLink.html">zebkit.ui.web.HtmlLink</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlTextArea" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlTextArea.html">zebkit.ui.web.HtmlTextArea</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlTextField" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlTextField.html">zebkit.ui.web.HtmlTextField</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlTextInput" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlTextInput.html">zebkit.ui.web.HtmlTextInput</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.HtmlWinCanvas" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.HtmlWinCanvas.html">zebkit.ui.web.HtmlWinCanvas</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.PopupLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.PopupLayer.html">zebkit.ui.web.PopupLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.RootLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.RootLayer.html">zebkit.ui.web.RootLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.VideoPan" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.VideoPan.html">zebkit.ui.web.VideoPan</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.web.WinLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.web.WinLayer.html">zebkit.ui.web.WinLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.Window" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.Window.html">zebkit.ui.Window</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.WinLayer" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.WinLayer.html">zebkit.ui.WinLayer</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.ui.zCanvas" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.ui.zCanvas.html">zebkit.ui.zCanvas</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.URI" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.URI.html">zebkit.URI</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.Event" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.Event.html">zebkit.util.Event</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.Listeners" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.Listeners.html">zebkit.util.Listeners</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.PathSearch" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.PathSearch.html">zebkit.util.PathSearch</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.Position" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.Position.html">zebkit.util.Position</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.Position.Metric" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.Position.Metric.html">zebkit.util.Position.Metric</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.rgb" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.rgb.html">zebkit.util.rgb</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.SingleColPosition" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.SingleColPosition.html">zebkit.util.SingleColPosition</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.TasksSet" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.TasksSet.html">zebkit.util.TasksSet</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.TasksSet.Task" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.TasksSet.Task.html">zebkit.util.TasksSet.Task</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.util.Zson" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.util.Zson.html">zebkit.util.Zson</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.Clipboard" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.Clipboard.html">zebkit.web.Clipboard</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.KeyEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.KeyEvent.html">zebkit.web.KeyEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.KeyEventUninfier" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.KeyEventUninfier.html">zebkit.web.KeyEventUninfier</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.MouseWheelSupport" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.MouseWheelSupport.html">zebkit.web.MouseWheelSupport</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.PointerEvent" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.PointerEvent.html">zebkit.web.PointerEvent</a>
                                            </td>
                                        </tr>
                                        <tr class="classNameCell" className="zebkit.web.PointerEventUnifier" name="allClassesItem">
                                            <td>
                                               <a href="../classes/zebkit.web.PointerEventUnifier.html">zebkit.web.PointerEventUnifier</a>
                                            </td>
                                        </tr>
                                </table>
                            </div>
                        </div>
                        
                        <script>
                            var root = document.getElementById("allClasses");
                            document.getElementById("search").addEventListener('input', function(e) {
                                var items = document.getElementsByName("allClassesItem"),
                                    value = this.value.trim().toLowerCase();
                        
                                for(var i = 0; i < items.length; i++) {
                                    var item = items[i];
                                    if (value.length < 3 || item.getAttribute("className").toLowerCase().indexOf(value) >= 0) {
                                        item.style.display = "block";
                                    } else {
                                        item.style.display = "none";
                                    };
                                }
                            });
                        </script>                    </div>
                </td>

                <td valign="top" align="left">
                    <div id="main" class="yui3-u">
                        <div class="content"><h4>build/zebkit.js</h4>

<pre class="code prettyprint linenums">
(function() {

    /**
     * WEB environment implementation. Provides elementary API zebkit needs to perform an
     * environment specific operations.
     * @class environment
     * @access package
     */
    var zebkitEnvironment = function() {
        var pkg    = {},
            hostRe = /([a-zA-Z]+)\:\/\/([^/:]+)/,
            isFF   = typeof navigator !== &#x27;undefined&#x27; &amp;&amp;
                     navigator.userAgent.toLowerCase().indexOf(&#x27;firefox&#x27;) &gt;= 0;

        function $sleep() {
            var r = new XMLHttpRequest(),
                t = (new Date()).getTime().toString(),
                i = window.location.toString().lastIndexOf(&quot;?&quot;);
            r.open(&#x27;GET&#x27;, window.location + (i &gt; 0 ? &quot;&amp;&quot; : &quot;?&quot;) + t, false);
            r.send(null);
        }

        function $Request() {
            this.responseText = this.statusText = &quot;&quot;;
            this.onreadystatechange = this.responseXml = null;
            this.readyState = this.status = 0;
        }

        $Request.prototype.open = function(method, url, async, user, password) {
            var m = url.match(hostRe);
            if (window.location.scheme.toLowerCase() === &quot;file:&quot; ||
                  (m           !== null &amp;&amp;
                   typeof m[2] !== &#x27;undefined&#x27; &amp;&amp;
                   m[2].toLowerCase() === window.location.host.toLowerCase()))
            {
                this._request = new XMLHttpRequest();
                this._xdomain = false;

                var $this = this;
                this._request.onreadystatechange = function() {
                    $this.readyState = $this._request.readyState;
                    if ($this._request.readyState === 4) {
                        $this.responseText = $this._request.responseText;
                        $this.responseXml  = $this._request.responseXml;
                        $this.status       = $this._request.status;
                        $this.statusText   = $this._request.statusText;
                    }

                    if ($this.onreadystatechange) {
                        $this.onreadystatechange();
                    }
                };

                return this._request.open(method, url, (async !== false), user, password);
            } else {
                this._xdomain = true;
                this._async = (async === true);
                this._request = new XDomainRequest();
                return this._request.open(method, url);
            }
        };

        $Request.prototype.send = function(data) {
            if (this._xdomain) {
                var originalReq = this._request,
                    $this       = this;

                //!!!! handler has to be defined after
                //!!!! open method has been called and all
                //!!!! four handlers have to be defined
                originalReq.ontimeout = originalReq.onprogress = function () {};

                originalReq.onerror = function() {
                    $this.readyState = 4;
                    $this.status = 404;
                    if ($this._async &amp;&amp; $this.onreadystatechange) {
                        $this.onreadystatechange();
                    }
                };

                originalReq.onload  = function() {
                    $this.readyState = 4;
                    $this.status = 200;

                    if ($this._async &amp;&amp; $this.onreadystatechange) {
                        $this.onreadystatechange(originalReq.responseText, originalReq);
                    }
                };

                //!!! set time out zero to prevent data lost
                originalReq.timeout = 0;

                if (this._async === false) {
                    originalReq.send(data);

                    while (this.status === 0) {
                        $sleep();
                    }

                    this.readyState = 4;
                    this.responseText = originalReq.responseText;

                } else {
                    //!!!  short timeout to make sure bloody IE is ready
                    setTimeout(function () {
                       originalReq.send(data);
                    }, 10);
                }
            } else  {
                return this._request.send(data);
            }
        };

        $Request.prototype.abort = function(data) {
            return this._request.abort();
        };

        $Request.prototype.setRequestHeader = function(name, value) {
            if (this._xdomain) {
                if (name === &quot;Content-Type&quot;) {
                    //!!!
                    // IE8 and IE9 anyway don&#x27;t take in account the assignment
                    // IE8 throws exception every time a value is assigned to
                    // the property
                    // !!!
                    //this._request.contentType = value;
                    return;
                } else {
                    throw new Error(&quot;Method &#x27;setRequestHeader&#x27; is not supported for &quot; + name);
                }
            } else {
                this._request.setRequestHeader(name, value);
            }
        };

        $Request.prototype.getResponseHeader = function(name) {
            if (this._xdomain) {
                throw new Error(&quot;Method is not supported&quot;);
            }
            return this._request.getResponseHeader(name);
        };

        $Request.prototype.getAllResponseHeaders = function() {
            if (this._xdomain) {
                throw new Error(&quot;Method is not supported&quot;);
            }
            return this._request.getAllResponseHeaders();
        };

        pkg.getHttpRequest = function() {
            if (typeof XMLHttpRequest !== &quot;undefined&quot;) {
                var r = new XMLHttpRequest();

                if (isFF) {
                    r.__send = r.send;
                    r.send = function(data) {
                        // !!! FF can throw NS_ERROR_FAILURE exception instead of
                        // !!! returning 404 File Not Found HTTP error code
                        // !!! No request status, statusText are defined in this case
                        try { return this.__send(data); }
                        catch(e) {
                            if (!e.message || e.message.toUpperCase().indexOf(&quot;NS_ERROR_FAILURE&quot;) &lt; 0) {
                                // exception has to be re-instantiate to be Error class instance
                                throw new Error(e.toString());
                            }
                        }
                    };
                }
                return (&quot;withCredentials&quot; in r) ? r  // CORS is supported out of box
                                                : new $Request(); // IE
            }
            throw new Error(&quot;Archaic browser detected&quot;);
        };

        pkg.parseXML = function(s) {
            function rmws(node) {
                if (node.childNodes !== null) {
                    for (var i = node.childNodes.length; i-- &gt; 0;) {
                        var child= node.childNodes[i];
                        if (child.nodeType === 3 &amp;&amp; child.data.match(/^\s*$/) !== null) {
                            node.removeChild(child);
                        }

                        if (child.nodeType === 1) {
                            rmws(child);
                        }
                    }
                }
                return node;
            }

            if (typeof DOMParser !== &quot;undefined&quot;) {
                return rmws((new DOMParser()).parseFromString(s, &quot;text/xml&quot;));
            } else {
                for (var n in { &quot;Microsoft.XMLDOM&quot;:0, &quot;MSXML2.DOMDocument&quot;:1, &quot;MSXML.DOMDocument&quot;:2 }) {
                    var p = null;
                    try {
                        p = new ActiveXObject(n);
                        p.async = false;
                    } catch (e) {
                        continue;
                    }

                    if (p === null) {
                        throw new Error(&quot;XML parser is not available&quot;);
                    }
                    p.loadXML(s);
                    return p;
                }
            }
            throw new Error(&quot;No XML parser is available&quot;);
        };

        /**
         * Loads an image by the given URL.
         * @param  {String|HTMLImageElement} img an image URL or image object
         * @param  {Function} ready a call back method to be notified when the image has been completely
         * loaded or failed. The method gets three parameters

            - an URL to the image
            - boolean loading result. true means success
            - an image that has been loaded

        * @example
            // load image
            zebkit.environment.loadImage(&quot;test.png&quot;, function(image) {
                 // handle loaded image
                 ...
            }, function (img, exception) {
                // handle error
                ...
            });
         * @return {HTMLImageElement}  an image
         * @for  zebkit.web
         * @method  loadImage
         */
        pkg.loadImage = function(ph, success, error) {
            var img = null;
            if (ph instanceof Image) {
                img = ph;
            } else {
                img = new Image();
                img.crossOrigin = &#x27;&#x27;;
                img.crossOrigin =&#x27;anonymous&#x27;;
                img.src = ph;
            }

            if (img.complete === true &amp;&amp; img.naturalWidth !== 0) {
                success.call(this, img);
            } else {
                var pErr  = img.onerror,
                    pLoad = img.onload,
                    $this = this;

                img.onerror = function(e) {
                    img.onerror = null;
                    try {
                        if (typeof error !== &#x27;undefined&#x27;) {
                            error.call($this, img, new Error(&quot;Image &#x27;&quot; + ph + &quot;&#x27; cannot be loaded &quot; + e));
                        }
                    } finally {
                        if (typeof pErr === &#x27;function&#x27;) {
                            img.onerror = pErr;
                            pErr.call(this, e);
                        }
                    }
                };

                img.onload  = function(e) {
                    img.onload = null;
                    try {
                        success.call($this, img);
                    } finally {
                        if (typeof pLoad === &#x27;function&#x27;) {
                            img.onload = pLoad;
                            pLoad.call(this, e);
                        }
                    }
                };
            }

            return img;
        };

        pkg.parseJSON = JSON.parse;

        pkg.stringifyJSON = JSON.stringify;

        pkg.setInterval = function (cb, time) {
            return window.setInterval(cb, time);
        };

        pkg.clearInterval = function (id) {
            return window.clearInterval(id);
        };

        if (typeof window !== &#x27;undefined&#x27;) {
            var $taskMethod = window.requestAnimationFrame       ||
                              window.webkitRequestAnimationFrame ||
                              window.mozRequestAnimationFrame    ||
                              function(callback) { return setTimeout(callback, 35); };

            pkg.decodeURIComponent = window.decodeURIComponent;
            pkg.encodeURIComponent = window.encodeURIComponent;

        } else {
            pkg.decodeURIComponent = function(s) { return s; } ;
            pkg.encodeURIComponent = function(s) { return s; } ;
        }

        /**
         * Request to run a method as an animation task.
         * @param  {Function} f the task body method
         * @method  animate
         * @for  zebkit.web
         */
        pkg.animate = function(f){
            return $taskMethod.call(window, f);
        };

        function buildFontHelpers() {
            //  font metrics API
            var e = document.getElementById(&quot;zebkit.fm&quot;);
            if (e === null) {
                e = document.createElement(&quot;div&quot;);
                e.setAttribute(&quot;id&quot;, &quot;zebkit.fm&quot;);  // !!! position fixed below allows to avoid 1px size in HTML layout for &quot;zebkit.fm&quot; element
                e.setAttribute(&quot;style&quot;, &quot;visibility:hidden;line-height:0;height:1px;vertical-align:baseline;position:fixed;&quot;);
                e.innerHTML = &quot;&lt;span id=&#x27;zebkit.fm.text&#x27; style=&#x27;display:inline;vertical-align:baseline;&#x27;&gt;&amp;nbsp;&lt;/span&gt;&quot; +
                              &quot;&lt;img id=&#x27;zebkit.fm.image&#x27; style=&#x27;width:1px;height:1px;display:inline;vertical-align:baseline;&#x27; width=&#x27;1&#x27; height=&#x27;1&#x27;/&gt;&quot;;
                document.body.appendChild(e);
            }
            var $fmCanvas = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;),
                $fmText   = document.getElementById(&quot;zebkit.fm.text&quot;),
                $fmImage  = document.getElementById(&quot;zebkit.fm.image&quot;);

            $fmImage.onload = function() {
                // TODO: hope the base64 specified image load synchronously and
                // checking it with &quot;join()&quot;
            };

            // set 1x1 transparent picture
            $fmImage.src = &#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII%3D&#x27;;

            pkg.fontMeasure = $fmCanvas;

            pkg.fontStringWidth = function(font, str) {
                if (str.length === 0) {
                    return 0;
                } else {
                    if ($fmCanvas.font !== font) {
                        $fmCanvas.font = font;
                    }
                    return Math.round($fmCanvas.measureText(str).width);
                }
            };

            pkg.fontMetrics = function(font) {
                if ($fmText.style.font !== font) {
                    $fmText.style.font = font;
                }

                var height = $fmText.offsetHeight;
                //!!!
                // Something weird is going sometimes in IE10 !
                // Sometimes the property offsetHeight is 0 but
                // second attempt to access to the property gives
                // proper result
                if (height === 0) {
                    height = $fmText.offsetHeight;
                }

                return {
                    height : height,
                    ascent : $fmImage.offsetTop - $fmText.offsetTop + 1
                };
            };
        }

        if (typeof document !== &#x27;undefined&#x27;) {
            document.addEventListener(&quot;DOMContentLoaded&quot;, buildFontHelpers);
        }

        return pkg;
    };

    if (typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof module.exports !== &#x27;undefined&#x27;) {
        module.exports.zebkitEnvironment = zebkitEnvironment;

        // TODO:
        // typeof the only way to make environment visible is makling it global
        // since module cannot be applied in the ase of browser context
        if (typeof global !== &#x27;undefined&#x27;) {
            global.zebkitEnvironment = zebkitEnvironment;
        }
    } else {
        window.zebkitEnvironment = zebkitEnvironment;
    }
})();
(function() {
/**
 * This is the core package that provides powerful easy OOP concept, packaging
 * and number of utility methods. The package doesn&#x27;t have any dependencies
 * from others zebkit packages and can be used independently. Briefly the
 * package possibilities are listed below:

   - **easy OOP concept**. Use &quot;zebkit.Class&quot; and &quot;zebkit.Interface&quot; to declare
     classes and interfaces

    &#x60;&#x60;&#x60;JavaScript
        // declare class A
        var ClassA = zebkit.Class([
            function() { // class constructor
                ...
            },
            // class method
            function a(p1, p2, p3) { ... }
        ]);

        var ClassB = zebkit.Class(ClassA, [
            function() {  // override constructor
                this.$super(); // call super constructor
            },

            function a(p1, p2, p3) { // override method &quot;a&quot;
                this.$super(p1, p2, p3);  // call super implementation of method &quot;a&quot;
            }
        ]);

        var b = new ClassB(); // instantiate classB
        b.a(1,2,3); // call &quot;a&quot;

        // instantiate anonymous class with new method &quot;b&quot; declared and
        // overridden method &quot;a&quot;
        var bb = new ClassB([
            function a(p1, p2, p3) { // override method &quot;a&quot;
                this.$super(p1, p2, p3);  // call super implementation of method &quot;a&quot;
            },

            function b() { ... } // declare method &quot;b&quot;
        ]);

        b.a();
        b.b();
    &#x60;&#x60;&#x60;

   - **Packaging.** Zebkit uses Java-like packaging system where your code is bundled in
      the number of hierarchical packages.

    &#x60;&#x60;&#x60;JavaScript
        // declare package &quot;zebkit.test&quot;
        zebkit.package(&quot;test&quot;, function(pkg) {
            // declare class &quot;Test&quot; in the package
            pkg.Test = zebkit.Class([ ... ]);
        });

        ...
        // Later on use class &quot;Test&quot; from package &quot;zebkit.test&quot;
        zebkit.require(&quot;test&quot;, function(test) {
            var test = new test.Test();
        });
    &#x60;&#x60;&#x60;

    - **Resources loading.** Resources should be loaded with a special method to guarantee
      its proper loading in zebkit sequence and the loading completeness.

    &#x60;&#x60;&#x60;JavaScript
        // declare package &quot;zebkit.test&quot;
        zebkit.resources(&quot;http://my.com/test.jpg&quot;, function(img) {
            // handle completely loaded image here
            ...
        });

        zebkit.package(&quot;test&quot;, function(pkg, Class) {
            // here we can be sure all resources are loaded and ready
        });
    &#x60;&#x60;&#x60;

   - **Declaring number of core API method and classes**
      - **&quot;zebkit.DoIt&quot;** - improves Promise like alternative class
      - **&quot;zebkit.URI&quot;** - URI helper class
      - **&quot;zebkit.Dummy&quot;** - dummy class
      - **instanceOf(...)** method to evaluate zebkit classes and and interfaces inheritance.
        The method has to be used instead of JS &quot;instanceof&quot; operator to provide have valid
        result.
      - **zebkit.newInstance(...)** method
      - **zebkit.clone(...)**  method
      - etc

 * @class zebkit
 * @access package
 */

    // Environment specific stuff
    var zenv = {},
        isInBrowser = typeof navigator !== &quot;undefined&quot;,
        $global     = (typeof window !== &quot;undefined&quot; &amp;&amp; window !== null) ? window
                                                                         : (typeof global !== &#x27;undefined&#x27; ? global
                                                                                                          : this);
    if (typeof zebkitEnvironment === &#x27;function&#x27;) {
        zenv = zebkitEnvironment();
    } else {
        if (typeof window !== &#x27;undefined&#x27;) {
            zenv = window;
        }
    }

    // ( (http) :// (host)? (:port)? (/)? )? (path)? (?query_string)?
    //
    //  [1] scheme://host/
    //  [2] scheme
    //  [3] host
    //  [4]  port
    //  [5] /
    //  [6] path
    //  [7] ?query_string
    //
    var $uriRE = /^(([a-zA-Z]+)\:\/\/([^\/:]+)?(\:[0-9]+)?(\/)?)?([^?]+)?(\?.+)?/;

    /**
     * URI class. Pass either a full uri (as a string or zebkit.URI) or number of an URI parts
     * (scheme, host, etc) to constructor it.
     * @param {String} [uri] an URI.
     * @param {String} [scheme] a scheme.
     * @param {String} [host] a host.
     * @param {String|Integer} [port] a port.
     * @param {String} [path] a path.
     * @param {String} [qs] a query string.
     * @constructor
     * @class zebkit.URI
     */
    function URI(uri) {
        if (arguments.length &gt; 1) {
            if (arguments[0] !== null) {
                this.scheme = arguments[0].toLowerCase();
            }

            if (arguments[1] !== null) {
                this.host = arguments[1];
            }

            var ps = false;
            if (arguments.length &gt; 2) {
                if (isNumber(arguments[2])) {
                    this.port = arguments[2];
                } else if (arguments[2] !== null) {
                    this.path = arguments[2];
                    ps = true;
                }
            }

            if (arguments.length &gt; 3) {
                if (ps === true) {
                    this.qs = arguments[3];
                } else {
                    this.path = arguments[3];
                }
            }

            if (arguments.length &gt; 4) {
                this.qs = arguments[4];
            }
        } else if (uri instanceof URI) {
            this.host   = uri.host;
            this.path   = uri.path;
            this.qs     = uri.qs;
            this.port   = uri.port;
            this.scheme = uri.scheme;
        } else {
            var m = uri.match($uriRE);
            if (m === null) {
                throw new Error(&quot;Invalid URI &#x27;&quot; + uri + &quot;&#x27;&quot;);
            }

            // fetch scheme
            if (typeof m[1] !== &#x27;undefined&#x27;) {
                this.scheme = m[2].toLowerCase();

                if (typeof m[3] === &#x27;undefined&#x27;) {
                    if (this.scheme !== &quot;file&quot;) {
                        throw new Error(&quot;Invalid host name : &#x27;&quot; + uri + &quot;&#x27;&quot;);
                    }
                } else {
                    this.host = m[3];
                }

                if (typeof m[4] !== &#x27;undefined&#x27;) {
                    this.port = parseInt(m[4].substring(1), 10);
                }
            }

            // fetch path
            if (typeof m[6] !== &#x27;undefined&#x27;) {
                this.path = m[6];
            } else if (typeof m[1] !== &#x27;undefined&#x27;) {
                throw new Error(&quot;Invalid URL &#x27;&quot; + uri + &quot;&#x27;&quot;);
            }

            if (typeof m[7] !== &#x27;undefined&#x27; &amp;&amp; m[7].length &gt; 1) {
                this.qs = m[7].substring(1).trim();
            }
        }

        if (this.path !== null) {
            this.path = this.path.replace(/\/\/*/g, &#x27;/&#x27;);

            var l = this.path.length;
            if (l &gt; 1 &amp;&amp; this.path[l - 1] === &#x27;/&#x27;) {
                this.path = this.path.substring(0, l - 1);
            }

            if ((this.host !== null || this.scheme !== null) &amp;&amp; this.path[0] !== &#x27;/&#x27;) {
                this.path = &quot;/&quot; + this.path;
            }
        }

        /**
         * URI path.
         * @attribute path
         * @type {String}
         * @readOnly
         */

        /**
         * URI host.
         * @attribute host
         * @type {String}
         * @readOnly
         */

        /**
         * URI port number.
         * @attribute port
         * @type {Integer}
         * @readOnly
         */

        /**
         * URI query string.
         * @attribute qs
         * @type {String}
         * @readOnly
         */

         /**
          * URI scheme (e.g. &#x27;http&#x27;, &#x27;ftp&#x27;, etc).
          * @attribute scheme
          * @type {String}
          * @readOnly
          */
    }

    URI.prototype = {
        scheme   : null,
        host     : null,
        port     : -1,
        path     : null,
        qs       : null,

        /**
         * Serialize URI to its string representation.
         * @method  toString
         * @return {String} an URI as a string.
         */
        toString : function() {
            return (this.scheme !== null ? this.scheme + &quot;://&quot; : &#x27;&#x27;) +
                   (this.host !== null ? this.host : &#x27;&#x27; ) +
                   (this.port !== -1   ? &quot;:&quot; + this.port : &#x27;&#x27; ) +
                   (this.path !== null ? this.path : &#x27;&#x27; ) +
                   (this.qs   !== null ? &quot;?&quot; + this.qs : &#x27;&#x27; );
        },

        /**
         * Get a parent URI.
         * @method getParent
         * @return {zebkit.URI} a parent URI.
         */
        getParent : function() {
            if (this.path === null) {
                return null;
            } else {
                var i = this.path.lastIndexOf(&#x27;/&#x27;);
                return (i &lt; 0 || this.path === &#x27;/&#x27;) ? null
                                                    : new zebkit.URI(this.scheme,
                                                                     this.host,
                                                                     this.port,
                                                                     this.path.substring(0, i),
                                                                     this.qs);
            }
        },

        /**
         * Append the given parameters to a query string of the URI.
         * @param  {Object} obj a dictionary of parameters to be appended to
         * the URL query string
         * @method appendQS
         */
        appendQS : function(obj) {
            if (obj !== null) {
                if (this.qs === null) {
                    this.qs = &#x27;&#x27;;
                }

                if (this.qs.length &gt; 0) {
                    this.qs = this.qs + &quot;&amp;&quot; + URI.toQS(obj);
                } else {
                    this.qs = URI.toQS(obj);
                }
            }
        }
    };

    /**
     * Test if the given string is absolute path or URI.
     * @param  {String|zebkit.URI}  u an URI
     * @return {Boolean} true if the string is absolute path or URI.
     * @method isAbsolute
     * @static
     */
    URI.isAbsolute = function(u) {
        return u[0] === &#x27;/&#x27; || /^[a-zA-Z]+\:\/\//i.test(u);
    };

    /**
     * Test if the given string is URL.
     * @param  {String}  u a string to be checked.
     * @return {Boolean} true if the string is URL
     * @method isURL
     * @static
     */
    URI.isURL = function(u) {
        return /^[a-zA-Z]+\:\/\//i.test(u);
    };

    /**
     * Parse the specified query string of the given URI.
     * @param  {String} url an URI
     * @param  {Boolean} [decode] pass true if query string has to be decoded.
     * @return {Object} a parsed query string as a dictionary of parameters
     * @method parseQS
     * @static
     */
    URI.parseQS = function(qs, decode) {
        var mqs      = qs.match(/[a-zA-Z0-9_.]+=[^?&amp;=]+/g),
            parsedQS = {};

        if (mqs !== null) {
            for(var i = 0; i &lt; mqs.length; i++) {
                var q = mqs[i].split(&#x27;=&#x27;);
                this.parsedQS[q[0].substring(1)] = (decode === true ? zebkit.environment.decodeURIComponent(q[1])
                                                                    : q[1]);
            }
        }

        return parsedQS;
    };

    /**
     * Convert the given dictionary of parameters to a query string.
     * @param  {Object} obj a dictionary of parameters
     * @param  {Boolean} [encode] pass true if the parameters values have to be
     * encoded
     * @return {String} a query string built from parameters list
     * @static
     * @method toQS
     */
    URI.toQS = function(obj, encode) {
        if (zebkit.isString(obj) || zebkit.isBoolean(obj) || zebkit.isNumber(obj)) {
            return &quot;&quot; + obj;
        }

        var p = [];
        for(var k in obj) {
            if (obj.hasOwnProperty(k)) {
                p.push(k + &#x27;=&#x27; + (encode === true ? zebkit.environment.encodeURIComponent(obj[k].toString())
                                                  : obj[k].toString()));
            }
        }
        return p.join(&quot;&amp;&quot;);
    };


    /**
     * Join the given  paths
     * @param  {String} p* relative paths
     * @return {String} an absolute URI
     * @method join
     * @static
     */
    URI.join = function() {
        var pu = new URI(arguments[0]);

        for(var i = 1; i &lt; arguments.length; i++) {
            var p = arguments[i].toString().trim();
            if (p.length === 0 || URI.isAbsolute(p)) {
                throw new Error(&quot;Absolute path &#x27;&quot; + p + &quot;&#x27; cannot be joined&quot;);
            }

            p = p.replace(/\/\/*/g, &#x27;/&#x27;);
            if (p[p.length - 1] === &#x27;/&#x27; ) {
                p = p.substring(0, p.length - 1);
            }

            if (pu.path === null) {
                pu.path = p;
                if ((pu.host !== null || pu.scheme !== null) &amp;&amp; pu.path[0] !== &#x27;/&#x27;) {
                    pu.path = &quot;/&quot; + pu.path;
                }
            } else {
                pu.path = pu.path + &quot;/&quot; + p;
            }
        }

        return pu.toString();
    };

    /**
     * Sequential tasks runner (D-then). Allows developers to execute number of steps (async and sync) in the
     * exact order they have been called by runner. The ideas of the runner implementation is making the
     * code more readable and plain nevertheless it includes asynchronous parts:
     * @example

        var r = new zebkit.DoIt();

        // step 1
        r.then(function() {
            // call three asynchronous HTTP GET requests to read three files
            // pass join to every async. method to be notified when the async.
            // part is completed
            asyncHttpCall(&quot;http://test.com/a.txt&quot;, this.join());
            asyncHttpCall(&quot;http://test.com/b.txt&quot;, this.join());
            asyncHttpCall(&quot;http://test.com/c.txt&quot;, this.join());
        })
        .  // step 2
        then(function(r1, r2, r3) {
            // handle completely read on previous step files
            r1.responseText  // &quot;a.txt&quot; file content
            r2.responseText  // &quot;b.txt&quot; file content
            r3.responseText  // &quot;c.txt&quot; file content
        })
        . // handle error
        catch(function(e) {
            // called when an exception has occurred
            ...
        });


     * @class zebkit.DoIt
     * @param {Boolean} [ignore] flag to rule error ignorance
     * @constructor
     */
    function DoIt(body, ignore) {
        this.recover();

        if (arguments.length === 1) {
            if (zebkit.isBoolean(body)) {
                this.$ignoreError = body;
                body = null;
            } else {
                this.then(body);
            }
        } else if (arguments.length === 2) {
            this.$ignoreError = ignore;
            this.then(body);
        }
    }

    DoIt.prototype = {
        // TODO: not stable API
        recover : function(body) {
            if (this.$error !== null) {
                var err = this.$error;
                this.$error = null;
                this.$tasks   = [];
                this.$results = [];
                this.$taskCounter = this.$level = this.$busy = 0;

                if (arguments.length === 1) {
                    body.call(this, err);
                }
            }
        },

        /**
         * Restart the do it object to clear error that has happened and
         * continue tasks that has not been run yet because of the error.
         * @method  restart
         * @chainable
         */
        restart : function() {
            if (this.$error !== null) {
                this.$error = null;
            }
            this.$schedule();
            return this;
        },

        /**
         * Run the given method as one of the sequential step of the doit execution.
         * @method  then
         * @param  {Function} body a method to be executed. The method can get results
         * of previous step execution as its arguments. The method is called in context
         * of instance of a DoIt instance.
         * @chainable
         */
        then : function(body, completed) {
            var level = this.$level;  // store level then was executed for the given task
                                      // to be used to compute correct the level inside the
                                      // method below
            if (body instanceof DoIt) {
                if (body.$error !== null) {
                    this.error(body.$error);
                } else {
                    var $this = this;
                    this.then(function() {
                        var jn = $this.join();
                        body.then(function() {
                            if (arguments.length &gt; 0) {
                                // also pass result to body DoIt
                                this.join.apply(this, arguments);
                            }
                        }, function() {
                            if ($this.$error === null) {
                                jn.apply($this, arguments);
                            }
                        }).catch(function(e) {
                            $this.error(e);
                        });
                    });
                }

                return this;
            } else {
                var task = function() {
                    // clean results of execution of a previous task

                    this.$busy = 0;
                    var pc = this.$taskCounter, args = null, r;

                    if (this.$error === null) {
                        if (typeof this.$results[level] !== &#x27;undefined&#x27;) {
                            args = this.$results[level];
                        }

                        this.$taskCounter    = 0;  // we have to count the tasks on this level
                        this.$level          = level + 1;
                        this.$results[level] = [];

                        // it is supposed the call is embedded with other call, no need to
                        // catch it one more time
                        if (level &gt; 0) {
                            r = body.apply(this, args);
                        } else {
                            try {
                                r = body.apply(this, args);
                            } catch(e) {
                                this.error(e);
                            }
                        }

                        // this.$busy === 0 means we have called synchronous task
                        // and make sure the task has returned a result
                        if (this.$busy === 0 &amp;&amp; this.$error === null &amp;&amp; typeof r !== &quot;undefined&quot;) {
                            this.$results[level] = [ r ];
                        }
                    }

                    if (level === 0) {
                        // zero level is responsible for handling exception
                        try {
                            this.$schedule();
                        } catch(e) {
                            this.error(e);
                        }
                    } else {
                        this.$schedule();
                    }

                    this.$level = level; // restore level
                    this.$taskCounter = pc;  // restore counter

                    // TODO: not a graceful solution. It has been done to let call &quot;join&quot; out
                    // outside of body. Sometimes it is required to provide proper level of
                    // execution since join calls schedule
                    if (typeof completed === &#x27;function&#x27;) {
                        if (level === 0) {
                            try {
                                if (args === null) {
                                    completed.call(this);
                                } else {
                                    completed.apply(this, args);
                                }
                            } catch(e) {
                                this.error(e);
                            }
                        } else {
                            if (args === null) {
                                completed.call(this);
                            } else {
                                completed.apply(this, args);
                            }
                        }
                    }
                    if (args !== null) {
                        args.length = 0;
                    }
                };

                if (this.$error === null) {
                    if (level === 0 &amp;&amp; this.$busy === 0) {
                        if (this.$results[level] != null &amp;&amp; this.$results[level].length &gt; 0) {
                            task.apply(this, this.$results[level]);
                        } else {
                            task.call(this);
                        }
                    } else {
                        // put task in list
                        if (this.$level &gt; 0) {
                            this.$tasks.splice(this.$taskCounter++, 0, task);
                        } else {
                            this.$tasks.push(task);
                        }
                    }
                }
            }

            if (this.$level === 0) {
                this.$schedule();
            }

            return this;
        },

        $ignored : function(e) {
            zebkit.dumpError(e);
        },

        /**
         * Force to fire error.
         * @param  {Error} e an error to be fired
         * @method error
         * @chainable
         */
        error : function(e, pr) {
            if (arguments.length === 0) {
                if (this.$error !== null) {
                    zebkit.dumpError(e);
                }
            } else {
                if (this.$error === null) {
                    if (this.$ignoreError) {
                        this.$ignored(e);
                    } else {
                        this.$taskCounter = this.$level = this.$busy = 0;
                        this.$error   = e;
                        this.$results = [];
                    }

                    this.$schedule();
                } else {
                    if (arguments.length &lt; 2 || pr === true) {
                        zebkit.dumpError(e);
                    }
                }
            }

            return this;
        },

        /**
         * Wait before the given doit is ready to be called.
         * @param  {zebkit.DoIt} r a runner
         * @example
         *
         *      var async = new DoIt().then(function() {
         *          // imagine we do asynchronous ajax call
         *          ajaxCall(&quot;http://test.com/data&quot;, this.join());
         *      });
         *
         *      var doit = new DoIt().till(async).then(function(res) {
         *          // handle result that has been fetched
         *          // by &quot;async&quot; do it
         *          ...
         *      });
         *
         * @chainable
         * @method till
         */
        till : function(r) {
            // wait till the given DoIt is executed
            this.then(function() {
                var $this = this,
                    jn    = this.join(), // block execution of the runner
                    res   = arguments.length &gt; 0 ? Array.prototype.slice.call(arguments) : []; // save arguments to restore it later

                // call &quot;doit&quot; we are waiting for
                r.then(function() {
                    if ($this.$error === null) {
                        // unblock the doit that waits for the runner we are in and
                        // restore its arguments
                        if (res.length &gt; 0) {
                            jn.apply($this, res);
                        } else {
                            jn.call($this);
                        }

                        // preserve arguments for the next call
                        if (arguments.length &gt; 0) {
                            this.join.apply(this, arguments);
                        }
                    }
                }).catch(function(e) {
                    // delegate error to a waiting runner
                    $this.error(e);
                });
            });

            return this;
        },

        /**
         * Returns join callback for asynchronous parts of the doit. The callback
         * has to be requested and called by an asynchronous method to inform the
         * doit the given method is completed.
         * @example
         *
         *      var d = new DoIt().then(function() {
         *          // imagine we call ajax HTTP requests
         *          ajaxCall(&quot;http://test.com/data1&quot;, this.join());
         *          ajaxCall(&quot;http://test.com/data2&quot;, this.join());
         *      }).then(function(res1, res2) {
         *          // handle results of ajax requests from previous step
         *          ...
         *      });
         *
         * @return {Function} a method to notify doit the given asynchronous part
         * has been completed. The passed to the method arguments will be passed
         * to the next step of the runner.         *
         * @method join
         */
        join : function() {
            // if join is called outside runner than level is set to 0
            var level = this.$level === 0 ? 0 : this.$level - 1;

            if (arguments.length &gt; 0) {
                this.$results[level] = [];
                for(var i = 0; i &lt; arguments.length; i++) {
                    this.$results[level][i] = arguments[i];
                }
            } else {
                // TODO: join uses busy flag to identify the result index the given join will supply
                // what triggers a potential result overwriting  problem (jn2 overwrite jn1  result):
                //    var jn1 = join(); jn1();
                //    var jn2 = join(); jn2();

                var $this = this,
                    index = this.$busy++;

                return function() {
                    if ($this.$results[level] == null) {
                        $this.$results[level] = [];
                    }

                    // since error can occur and times variable
                    // can be reset to 0 we have to check it
                    if ($this.$busy &gt; 0) {
                        var i = 0;

                        if (arguments.length &gt; 0) {
                            $this.$results[level][index] = [];
                            for(i = 0; i &lt; arguments.length; i++) {
                                $this.$results[level][index][i] = arguments[i];
                            }
                        }

                        if (--$this.$busy === 0) {
                            // collect result
                            if ($this.$results[level].length &gt; 0) {
                                var args = $this.$results[level],
                                    res  = [];

                                for(i = 0; i &lt; args.length; i++) {
                                    Array.prototype.push.apply(res, args[i]);
                                }
                                $this.$results[level] = res;
                            }

                            // TODO: this code can bring to unexpected scheduling for a situation when
                            // doit is still in then:
                            //    then(function () {
                            //        var jn1 = join();
                            //        ...
                            //        jn1()  // unexpected scheduling of the next then since busy is zero
                            //        ...
                            //        var jn2 = join(); // not actual
                            //    })

                            $this.$schedule();
                        }
                    }
                };
            }
        },

        /**
         * Method to catch error that has occurred during the doit sequence execution.
         * @param  {Function} [body] a callback to handle the error. The method
         * gets an error that has happened as its argument. If there is no argument
         * the error will be printed in output. If body is null then no error output
         * is expected.
         * @chainable
         * @method catch
         */
        catch : function(body) {
            var level = this.$level;  // store level then was executed for the given task
                                      // to be used to compute correct the level inside the
                                      // method below

            var task = function() {
                // clean results of execution of a previous task

                this.$busy = 0;
                var pc = this.$taskCounter;
                if (this.$error !== null) {
                    this.$taskCounter = 0;  // we have to count the tasks on this level
                    this.$level       = level + 1;

                    try {
                        if (typeof body === &#x27;function&#x27;) {
                            body.call(this, this.$error);
                        } else if (body === null) {

                        } else {
                            zebkit.dumpError(this.$error);
                        }
                    } catch(e) {
                        this.$level       = level; // restore level
                        this.$taskCounter = pc;    // restore counter
                        throw e;
                    }
                }

                if (level === 0) {
                    try {
                        this.$schedule();
                    } catch(e) {
                        this.error(e);
                    }
                } else {
                    this.$schedule();
                }

                this.$level       = level; // restore level
                this.$taskCounter = pc;    // restore counter
            };

            if (this.$level &gt; 0) {
                this.$tasks.splice(this.$taskCounter++, 0, task);
            } else {
                this.$tasks.push(task);
            }

            if (this.$level === 0) {
                this.$schedule();
            }

            return this;
        },

        /**
         * Throw an exception if an error has happened before the method call,
         * otherwise fo nothing.
         * @method  throw
         * @chainable
         */
        throw : function() {
            return this.catch(function(e) {
                throw e;
            });
        },

        $schedule : function() {
            if (this.$tasks.length &gt; 0 &amp;&amp; this.$busy === 0) {
                this.$tasks.shift().call(this);
            }
        },

        end : function() {
            this.recover();
        }
    };

    //  Faster match operation analogues:
    //  Math.floor(f)  =&gt;  ~~(a)
    //  Math.round(f)  =&gt;  (f + 0.5) | 0
    function isString(o)  {
        return typeof o !== &quot;undefined&quot; &amp;&amp; o !== null &amp;&amp;
              (typeof o === &quot;string&quot; || o.constructor === String);
    }

    function isNumber(o)  {
        return typeof o !== &quot;undefined&quot; &amp;&amp; o !== null &amp;&amp;
              (typeof o === &quot;number&quot; || o.constructor === Number);
    }

    function isBoolean(o) {
        return typeof o !== &quot;undefined&quot; &amp;&amp; o !== null &amp;&amp;
              (typeof o === &quot;boolean&quot; || o.constructor === Boolean);
    }

    function lookupObjValue(obj, name) {
        if (arguments.length === 1) {
            name = obj;
            obj  = $global;
        }

        if (typeof name === &#x27;undefined&#x27; || name.trim().length === 0) {
            throw new Error(&quot;Invalid field name: &#x27;&quot; + name + &quot;&#x27;&quot;);
        }

        var names = name.trim().split(&#x27;.&#x27;);
        for(var i = 0; i &lt; names.length; i++) {
            obj = obj[names[i]];

            if (typeof obj === &#x27;undefined&#x27; || ((i + 1) === names.length &amp;&amp; obj === null)) {
                throw new Error(&quot;&#x27;&quot; + name + &quot;&#x27; value cannot be detected&quot;);
            }
        }
        return obj;
    }

    function $ls(callback, all) {
        for (var k in this) {
            var v = this[k];
            if (this.hasOwnProperty(k) &amp;&amp; (v instanceof Package) === false)  {
                if ((k[0] !== &#x27;$&#x27; &amp;&amp; k[0] !== &#x27;_&#x27;) || all === true) {
                    if (callback.call(this, k, this[k]) === true) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function $lsall(fn) {
        return $ls.call(this, function(k, v) {
            if (typeof v === &#x27;undefined&#x27;) {
                throw new Error(fn + &quot;,&quot; + k);
            }

            if (v !== null &amp;&amp; v.clazz === zebkit.Class) {
                if (typeof v.$name === &quot;undefined&quot;) {
                    v.$name = fn + k;
                    v.$pkg  = lookupObjValue($global, fn.substring(0, fn.length - 1));
                }
                return $lsall.call(v, v.$name + &quot;.&quot;);
            }
        });
    }

    /**
     *  Package is a special class to declare zebkit packages. Global variable &quot;zebkit&quot; is
     *  root package for all other packages. To declare a new package use &quot;zebkit&quot; global
     *  variable:
     *
     *      // declare new &quot;mypkg&quot; package
     *      zebkit.package(&quot;mypkg&quot;, function(pkg, Class) {
     *          // put the package entities in
     *          pkg.packageVariable = 10;
     *          ...
     *      });
     *      ...
     *
     *      // now we can access package and its entities directly
     *      zebkit.mypkg.packageVariable
     *
     *      // or it is preferable to wrap a package access with &quot;require&quot;
     *      // method
     *      zebkit.require(&quot;mypkg&quot;, function(mypkg) {
     *          mypkg.packageVariable
     *      });
     *
     *  @class zebkit.Package
     *  @constructor
     */
    function Package(name, parent) {
        /**
         * URL the package has been loaded
         * @attribute $url
         * @readOnly
         * @type {String}
         */
        this.$url = null;

        /**
         * Name of the package
         * @attribute $name
         * @readOnly
         * @type {String}
         */
        this.$name = name;

        /**
         * Package configuration parameters.
         * @attribute config
         * @readOnly
         * @type {Object}
         */
        this.config = {};

        this.$ready = new DoIt();

        /**
         * Reference to a parent package
         * @attribute $parent
         * @private
         * @type {zebkit.Package}
         */
        this.$parent = arguments.length &lt; 2 ? null : parent;
    }

    Package.prototype.$detectLocation = function() {
        if (typeof __dirname !== &#x27;undefined&#x27;) {
            this.$url = __dirname;
        } else if (typeof document !== &quot;undefined&quot;) {
            //
            var s  = document.getElementsByTagName(&#x27;script&#x27;),
                ss = s[s.length - 1].getAttribute(&#x27;src&#x27;),
                i  = ss === null ? -1 : ss.lastIndexOf(&quot;/&quot;),
                a  = document.createElement(&#x27;a&#x27;);

            a.href = (i &gt; 0) ? ss.substring(0, i + 1)
                             : document.location.toString();

            this.$url = a.href.toString();
        }
    };

    /**
     * Get full name of the package. Full name includes not the only the given
     * package name, but also all parent packages separated with &quot;.&quot; character.
     * @return {String} a full package name
     * @method fullname
     */
    Package.prototype.fullname = function() {
        var n = [ this.$name ], p = this;
        while (p.$parent !== null) {
            p = p.$parent;
            n.unshift(p.$name);
        }
        return n.join(&quot;.&quot;);
    };

    /**
     * Find a package with the given file like path relatively to the given package.
     * @param {String} path a file like path
     * @return {String} path a path
     * @example
     *
     *      // declare &quot;zebkit.test&quot; package
     *      zebkit.package(&quot;test&quot;, function(pkg, Class) {
     *          ...
     *      });
     *      ...
     *
     *      zebkit.require(&quot;test&quot;, function(test) {
     *          var parent = test.cd(&quot;..&quot;); // parent points to zebkit package
     *          ...
     *      });
     *
     * @method cd
     */
    Package.prototype.cd = function(path) {
        if (path[0] === &#x27;/&#x27;) {
            path = path.substring(1);
        }

        var paths = path.split(&#x27;/&#x27;),
            pk    = this;

        for (var i = 0; i &lt; paths.length; i++) {
            var pn = paths[i];
            if (pn === &quot;..&quot;) {
                pk = pk.$parent;
            } else {
                pk = pk[pn];
            }

            if (typeof pk === &#x27;undefined&#x27; || pk === null) {
                throw new Error(&quot;Package path &#x27;&quot; + path + &quot;&#x27; cannot be resolved&quot;);
            }
        }

        return pk;
    };

    /**
     * List the package sub-packages.
     * @param  {Function} callback    callback function that gets a sub-package name and the
     * sub-package itself as its arguments
     * @param  {boolean}  [recursively]  indicates if sub-packages have to be traversed recursively
     * @method packages
     */
    Package.prototype.packages = function(callback, recursively) {
        for (var k in this) {
            var v = this[k];
            if (k !== &quot;$parent&quot; &amp;&amp; this.hasOwnProperty(k) &amp;&amp; v instanceof Package) {

                if (callback.call(this, k, v) === true || (recursively === true &amp;&amp; v.packages(callback, recursively) === true)) {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * List classes, variables and interfaces defined in the given package.
     * If second parameter &quot;all&quot; passed to the method is false, the method
     * will skip package entities whose name starts from &quot;$&quot; or &quot;_&quot; character.
     * These entities are considered as private ones. Pay attention sub-packages
     * are not listed.
     * @param  {Function} cb a callback method that get the package entity key
     * and the entity value as arguments.
     * @param  {Boolean}  [all] flag that specifies if private entities are
     * should be listed.
     * @method ls
     */
    Package.prototype.ls = function(cb, all) {
        return $ls.call(this, cb, all);
    };

    /**
     * Build import JS code string that can be evaluated in a local space to make visible
     * the given package or packages classes, variables and methods.
     * @example
     *
     *     (function() {
     *         // make visible variables, classes and methods declared in &quot;zebkit.ui&quot;
     *         // package in the method local space
     *         eval(zebkit.import(&quot;ui&quot;));
     *
     *         // use imported from &quot;zebkit.ui.Button&quot; class without necessity to specify
     *         // full path to it
     *         var bt = new Button(&quot;Ok&quot;);
     *     })();
     *
     * @param {String} [pkgname]* names of packages to be imported
     * @return {String} an import string to be evaluated in a local JS space
     * @method  import
     */
    Package.prototype.import = function() {
        var code = [];
        if (arguments.length &gt; 0) {
            for(var i = 0; i &lt; arguments.length; i++) {
                var v = lookupObjValue(this, arguments[i]);
                if ((v instanceof Package) === false) {
                    throw new Error(&quot;Package &#x27;&quot; + arguments[i] + &quot; &#x27; cannot be found&quot;);
                }
                code.push(v.import());
            }

            return code.length &gt; 0 ?  code.join(&quot;;&quot;) : null;
        } else {
            var fn = this.fullname();
            this.ls(function(k, v) {
                code.push(k + &#x27;=&#x27; + fn + &#x27;.&#x27; + k);
            });

            return code.length &gt; 0 ?  &quot;var &quot; + code.join(&quot;,&quot;) + &quot;;&quot; : null;
        }
    };

    /**
     * Method to request sub-package or sub-packages be ready and visible in
     * passed callback. The method guarantees the callbacks be called the time
     * all zebkit data is loaded and ready.
     * @param {String} [packages]* name or names of sub-packages to make visible
     * in callback method
     * @param {Function} [callback] a method to be called. The method is called
     * in context of the given package and gets requested packages passed as the
     * method arguments in order they have been requested.
     * @method  require
     * @example
     *
     *     zebkit.require(&quot;ui&quot;, function(ui) {
     *         var b = new ui.Button(&quot;Ok&quot;);
     *         ...
     *     });
     *
     */
    Package.prototype.require = function() {
        var pkgs  = [],
            $this = this,
            fn    = arguments[arguments.length - 1];

        if (typeof fn !== &#x27;function&#x27;) {
            throw new Error(&quot;Invalid callback function&quot;);
        }

        for(var i = 0; isString(arguments[i]) &amp;&amp; i &lt; arguments.length; i++) {
            var pkg = lookupObjValue(this, arguments[i]);
            if ((pkg instanceof Package) === false) {
                throw new Error(&quot;Package &#x27;&quot; + arguments[i] + &quot;&#x27; cannot be found&quot;);
            }
            pkgs.push(pkg);
        }

        return this.then(function() {
            fn.apply($this, pkgs);
        });
    };

    var $textualFileExtensions = [
        &quot;txt&quot;, &quot;json&quot;, &quot;htm&quot;, &quot;html&quot;, &quot;md&quot;, &quot;properties&quot;, &quot;conf&quot;, &quot;xml&quot;
    ];

    /**
     * This method loads resources (images, textual files, etc) and call callback
     * method with completely loaded resources as input arguments.
     * @example
     *
     *     zebkit.resources(
     *         &quot;http://test.com/image1.jpg&quot;,
     *         &quot;http://test.com/text.txt&quot;,
     *         function(image, text) {
     *             // handle resources here
     *             ...
     *         }
     *     );
     *
     * @param  {String} paths*  paths to resources to be loaded
     * @param  {Function} cb callback method that is executed when all listed
     * resources are loaded and ready to be used.
     * @method resources
     */
    Package.prototype.resources = function() {
        var args  = Array.prototype.slice.call(arguments),
            $this = this,
            fn    = args.pop();

        if (typeof fn !== &#x27;function&#x27;) {
            throw new Error(&quot;Invalid callback function&quot;);
        }

        this.then(function() {
            for(var i = 0; i &lt; args.length ; i++) {
                (function(path, jn) {
                    var m    = path.match(/^(\&lt;[a-z]+\&gt;\s*)?(.*)$/),
                        type = &quot;img&quot;,
                        p    = m[2].trim();

                    if (typeof m[1] !== &#x27;undefined&#x27;) {
                        type = m[1].trim().substring(1, m[1].length - 1).trim();
                    } else {
                        var li = p.lastIndexOf(&#x27;.&#x27;);
                        if (li &gt; 0) {
                            var ext = p.substring(li + 1).toLowerCase();
                            if ($textualFileExtensions.indexOf(ext) &gt;= 0) {
                                type = &quot;txt&quot;;
                            }
                        }
                    }

                    if (type === &quot;img&quot;) {
                        zebkit.environment.loadImage(p, function(img) {
                            jn(img);
                        }, function(img, e) {
                            jn(img);
                        });
                    } else if (type === &quot;txt&quot;) {
                        // TODO: this part has to be replaced with less low-level code
                        var req  = zebkit.environment.getHttpRequest();
                        req.open(&quot;GET&quot;, p, true);
                        req.onreadystatechange = function() {
                            if (req.readyState === 4) {
                                if (req.status &gt;= 400 || req.status &lt; 100) {
                                    console.log(&quot;HTTP error &#x27;&quot; + req.statusText + &quot;&#x27;, code = &quot; + req.status + &quot; &#x27;&quot; + path + &quot;&#x27;&quot;);
                                    jn(null);
                                } else {
                                    jn(req.responseText);
                                }
                            }
                        };

                        try {
                            req.send(null);
                        } catch(e) {
                            jn(null);
                        }
                    } else {
                        console.log(&quot;Invalid path &#x27;&quot; + path + &quot;&#x27;&quot;);
                        jn(null);
                    }

                })(args[i], this.join());
            }
        }).then(function() {
            fn.apply($this, arguments);
        });
    };

    /**
     * This method helps to sync accessing to package entities with the
     * package internal state. For instance package declaration can initiate
     * loading resources that happens asynchronously. In this case to make sure
     * the package completed loading its configuration we should use package
     * &quot;then&quot; method.
     * @param  {Function} f a callback method where we can safely access the
     * package entities
     * @chainable
     * @private
     * @example
     *
     *     zebkit.then(function() {
     *         // here we can make sure all package declarations
     *         // are completed and we can start using it
     *     });
     *
     * @method  then
     */
    Package.prototype.then = function(f) {
        this.$ready.then(f).catch(function(e) {
            zebkit.dumpError(e);
            // re-start other waiting tasks
            this.restart();
        });
        return this;
    };

    Package.prototype.join = function() {
        return this.$ready.join.apply(this.$ready, arguments);
    };

    /**
     * Method that has to be used to declare packages.
     * @param  {String}   name     a name of the package
     * @param  {Function} [callback] a call back method that is called in package
     * context. The method has to be used to populate the given package classes,
     * interfaces and variables.
     * @example
     *     // declare package &quot;zebkit.log&quot;
     *     zebkit.package(&quot;log&quot;, function(pkg) {
     *         // declare the package class Log
     *         pkg.Log = zebkit.Class([
     *              function error() { ... },
     *              function warn()  { ... },
     *              function info()  { ... }
     *         ]);
     *     });
     *
     *     // later on you can use the declared package stuff as follow
     *     zebkit.require(&quot;log&quot;, function(log) {
     *         var myLog = new log.Log();
     *         ...
     *         myLog.warn(&quot;Warning&quot;);
     *     });
     *
     * @return {zebkit.Package} a package
     * @method package
     */
    Package.prototype.package = function(name, callback) {
        // no arguments than return the package itself
        if (arguments.length === 0) {
            return this;
        }

        var target = this;
        if (typeof arguments[0] !== &#x27;function&#x27;) {
            if (typeof name === &#x27;undefined&#x27; || name === null) {
                throw new Error(&quot;Null package name&quot;);
            }

            name = name.trim();
            if (name.match(/^[a-zA-Z_][a-zA-Z0-9_]+(\.[a-zA-Z_][a-zA-Z0-9_]+)*$/) === null) {
                throw new Error(&quot;Invalid package name &#x27;&quot; + name + &quot;&#x27;&quot;);
            }

            var names = name.split(&#x27;.&#x27;);
            for(var i = 0, k = names[0]; i &lt; names.length; i++, k = k + &#x27;.&#x27; + names[i]) {
                var n = names[i], p = target[n];
                if (typeof p === &quot;undefined&quot;) {
                    p = new Package(n, target);
                    target[n] = p;
                } else if ((p instanceof Package) === false) {
                    throw new Error(&quot;Requested package &#x27;&quot; + name +  &quot;&#x27; conflicts with variable &#x27;&quot; + n + &quot;&#x27;&quot;);
                }
                target = p;
            }
        }

        // detect url later then sonner since
        if (target.$url === null) {
            target.$detectLocation();
        }

        if (typeof arguments[arguments.length - 1] === &#x27;function&#x27;) {
            var f = arguments[arguments.length - 1];

            this.then(function() {
                f.call(target, target, typeof zebkit !== &#x27;undefined&#x27; ? zebkit.Class : null);
                $lsall.call(target, target.fullname() + &quot;.&quot;); // resolve &quot;clazz.$name&quot; properties of the package classes
            });
        }

        return target;
    };

    // =================================================================================================
    //
    //   Zebkit root package declaration
    //
    // =================================================================================================
    var zebkit = new Package(&quot;zebkit&quot;);

    /**
     * Reference to zebkit environment. Environment is basic, minimal API
     * zebkit and its components require.
     * @for  zebkit
     * @attribute environment
     * @readOnly
     * @type {Object}
     */
    zebkit.environment = zenv;

    // declaring zebkit as a global variable has to be done before calling &quot;package&quot; method
    // otherwise the method cannot find zebkit to resolve class names
    //
    // nodejs
    if (typeof module !== &#x27;undefined&#x27; &amp;&amp; typeof module.exports !== &#x27;undefined&#x27;) {
        module.exports = zebkit;

        // TODO: not a good pattern to touch global space, but zebkit has to be visible
        // globally
        if (typeof global !== &#x27;undefined&#x27;) {
            global.zebkit = zebkit;
        }
    } else {
        window.zebkit = zebkit;
    }

    zebkit.package(function(pkg) {
        var $$$     = 11,  // hash code counter
            $caller = null; // currently called method reference

        // single method proxy wrapper
        function ProxyMethod(name, f, clazz) {
            if (typeof f.methodBody !== &quot;undefined&quot;) {
                throw new Error(&quot;Proxy method &#x27;&quot; + name + &quot;&#x27; cannot be wrapped&quot;);
            }

            var a = function() {
                var cm = $caller;
                $caller = a;
                // don&#x27;t use finally section it is slower than try-catch
                try {
                    var r = f.apply(this, arguments);
                    $caller = cm;
                    return r;
                } catch(e) {
                    $caller = cm;
                    console.log(name + &quot;(&quot; + arguments.length + &quot;) &quot; + (e.stack ? e.stack : e));
                    throw e;
                }
            };

            a.methodBody = f;
            a.methodName = name;
            a.boundTo    = clazz;
            return a;
        }

        // copy methods from source to destination
        function cpMethods(src, dest, clazz) {
            var overriddenAbstractMethods = 0;
            for(var name in src) {
                if (name   !== pkg.CNAME     &amp;&amp;
                    name   !== &quot;clazz&quot;       &amp;&amp;
                    src.hasOwnProperty(name)   )
                {
                    var method = src[name];
                    if (typeof method === &quot;function&quot; &amp;&amp; method !== $toString) {
                        if (name === &quot;$prototype&quot;) {
                            method.call(dest, clazz);
                        } else {
                            // TODO analyze if we overwrite existent field
                            if (typeof dest[name] !== &#x27;undefined&#x27;) {
                                // abstract method is overridden, let&#x27;s skip abstract method
                                // stub implementation
                                if (method.$isAbstract === true) {
                                    overriddenAbstractMethods++;
                                    continue;
                                }

                                if (dest[name].boundTo === clazz) {
                                    throw new Error(&quot;Method &#x27;&quot; + name + &quot;(...)&#x27;&#x27; bound to this class already exists&quot;);
                                }
                            }

                            if (typeof method.methodBody !== &quot;undefined&quot;) {
                                dest[name] = ProxyMethod(name, method.methodBody, clazz);
                            } else {
                                dest[name] = ProxyMethod(name, method, clazz);
                            }

                            // save information about abstract method
                            if (method.$isAbstract === true) {
                                dest[name].$isAbstract = true;
                            }
                        }
                    }
                }
            }

            return overriddenAbstractMethods;
        }

        function $toString() {
            return this.$hash$;
        }

        // return function that is meta class
        //  instanceOf      - parent template function (can be null)
        //  templateConstructor - template function,
        //  inheritanceList     - parent class and interfaces
        function make_template(instanceOf, templateConstructor, inheritanceList) {
            // supply template with unique identifier that is returned with toString() method
            templateConstructor.$hash$   = &quot;$zEk$&quot; + ($$$++);
            templateConstructor.toString = $toString;
            templateConstructor.prototype.clazz = templateConstructor; // instances of the template has to point to the template as a class

            templateConstructor.clazz = templateConstructor.constructor = instanceOf;

            /**
             *  Unique string hash code. The property is not defined if the class was not
             *  maid hashable by calling &quot;hashable()&quot; method.
             *  @attribute $hash$
             *  @private
             *  @type {String}
             *  @for  zebkit.Class
             *  @readOnly
             */

            /**
             * Dictionary of all inherited interfaces where key is unique interface hash code and the value
             * is interface itself.
             * @private
             * @readOnly
             * @for zebkit.Class
             * @type {Object}
             * @attribute $parents
             * @type {Object}
             */
            templateConstructor.$parents = {};

            // instances of the constructor also has to be unique
            // so force toString method population
            templateConstructor.prototype.constructor = templateConstructor; // set constructor of instances to the template

            // setup parent entities
            if (arguments.length &gt; 2 &amp;&amp; inheritanceList.length &gt; 0) {
                for(var i = 0; i &lt; inheritanceList.length; i++) {
                    var toInherit = inheritanceList[i];
                    if (typeof toInherit === &#x27;undefined&#x27;        ||
                        toInherit === null                      ||
                        typeof toInherit        !== &quot;function&quot;  ||
                        typeof toInherit.$hash$ === &quot;undefined&quot;   )
                    {
                        throw new ReferenceError(&quot;Invalid parent class or interface:&quot; + toInherit);
                    }

                    if (typeof templateConstructor.$parents[toInherit.$hash$] !== &quot;undefined&quot;) {
                        throw Error(&quot;Duplicate toInherit class or interface: &quot; + toInherit);
                    }

                    templateConstructor.$parents[toInherit.$hash$] = toInherit;

                    // if parent has own parents copy the parents references
                    for(var k in toInherit.$parents) {
                        if (typeof templateConstructor.$parents[k] !== &quot;undefined&quot;) {
                            throw Error(&quot;Duplicate inherited class or interface: &quot; + k);
                        }

                        templateConstructor.$parents[k] = toInherit.$parents[k];
                    }
                }
            }
            return templateConstructor;
        }

        /**
         * Dump the given error to output.
         * @param  {Exception | Object} e an error.
         * @method dumpError
         * @for  zebkit
         */
        pkg.dumpError = function(e) {
            if (typeof console !== &quot;undefined&quot; &amp;&amp; typeof console.log !== &quot;undefined&quot;) {
                var msg = &quot;zebkit.err [&quot;;
                if (typeof Date !== &#x27;undefined&#x27;) {
                    var date = new Date();
                    msg = msg + date.getDate()   + &quot;/&quot; +
                          (date.getMonth() + 1) + &quot;/&quot; +
                          date.getFullYear() + &quot; &quot; +
                          date.getHours() + &quot;:&quot; + date.getMinutes() + &quot;:&quot; + date.getSeconds();
                }

                console.log(msg + &quot;] : &quot; + e);
                if (e === null || typeof e === &#x27;undefined&#x27;) {
                    console.log(&quot;Unknown error&quot;);
                } else {
                    console.log((e.stack ? e.stack : e));
                }
            }
        };

        pkg.URI = URI;

        pkg.CNAME = &#x27;$&#x27;;
        pkg.CDNAME = &#x27;&#x27;;

        pkg.$FN = (isString.name !== &quot;isString&quot;) ? (function(f) {  // IE stuff
                                                        if (typeof f.$methodName === &#x27;undefined&#x27;) { // test if name has been earlier detected
                                                            var mt = f.toString().match(/^function\s+([^\s(]+)/);
                                                            f.$methodName = (mt === null) ? pkg.CDNAME
                                                                                          : (typeof mt[1] === &quot;undefined&quot; ? pkg.CDNAME
                                                                                                                          : mt[1]);
                                                        }
                                                        return f.$methodName;
                                                    })
                                                 : (function(f) { return f.name; });


        pkg.isIE    = isInBrowser &amp;&amp; (Object.hasOwnProperty.call(window, &quot;ActiveXObject&quot;) || !!window.ActiveXObject || window.navigator.userAgent.indexOf(&quot;Edge&quot;) &gt; -1);
        pkg.isFF    = isInBrowser &amp;&amp; window.mozInnerScreenX !== null;
        pkg.isMacOS = isInBrowser &amp;&amp; navigator.platform.toUpperCase().indexOf(&#x27;MAC&#x27;) !== -1;

        /**
         * Check if the given value is string
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is string
         * @method isString
         * @for zebkit
         */
        pkg.isString = isString;

        /**
         * Check if the given value is number
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is number
         * @method isNumber
         * @for zebkit
         */
        pkg.isNumber = isNumber;

        /**
         * Check if the given value is boolean
         * @param {Object} v a value.
         * @return {Boolean} true if the given value is boolean
         * @method isBoolean
         * @for zebkit
         */
        pkg.isBoolean = isBoolean;

        /**
         * Reference to global space.
         * @attribute $global
         * @private
         * @readOnly
         * @type {Object}
         * @for zebkit
         */
        pkg.$global = $global;


        pkg.$Map = function() {
            var Map = function() {
                this.keys   = [];
                this.values = [];
                this.size   = 0 ;
            };

            Map.prototype = {
                set : function(key, value) {
                    var i = this.keys.indexOf(key);
                    if (i &lt; 0) {
                        this.keys.push(key);
                        this.values.push(value);
                        this.size++;
                    } else {
                       this.values[i] = value;
                    }
                    return this;
                 },

                delete: function(key) {
                    var i = this.keys.indexOf(key);
                    if (i &lt; 0) {
                       return false;
                    }

                    this.keys.splice(i, 1);
                    this.values.splice(i, 1);
                    this.size--;
                    return true;
                },

                get : function(key) {
                    var i = this.keys.indexOf(key);
                    return i &lt; 0 ? undefined : this.values[i];
                },

                clear : function() {
                    this.keys = [];
                    this.keys.length = 0;
                    this.values = [];
                    this.values.length = 0;
                    this.size = 0;
                },

                has : function(key) {
                    return this.keys.indexOf(key) &gt;= 0;
                },

                forEach: function(callback, context) {
                    var $this = arguments.length &lt; 2 ? this : context;
                    for(var i = 0 ; i &lt; this.size; i++) {
                        callback.call($this, this.values[i], this.keys[i], this);
                    }
                }
            };

            return Map;
        };

        // ES6 Map is class
        if (typeof Map === &#x27;undefined&#x27; &amp;&amp; (typeof pkg.$global !== &#x27;undefined&#x27; || typeof pkg.$global.Map === &quot;undefined&quot;)) {
            pkg.$global.Map = pkg.$Map();
        }

        /**
         * Clone the given object. The method tries to perform deep cloning by
         * traversing the given object structure recursively. Any part of an
         * object can be marked as not cloneable by adding  &quot;$notCloneable&quot;
         * field that equals to true. Also at any level of object structure
         * the cloning can be customized with adding &quot;$clone&quot; method. In this
         * case the method will be used to clone the part of object.
         * clonable
         * @param  {Object} obj an object to be cloned
         * @return {Object} a cloned object
         * @method  clone
         * @for  zebkit
         */
        pkg.clone = function (obj, map) {
            // clone atomic type
            // TODO: to speedup cloning we don&#x27;t use isString, isNumber, isBoolean
            if (obj === null || typeof obj === &#x27;undefined&#x27; || obj.$notCloneable === true ||
                                                              (typeof obj === &quot;string&quot;  || obj.constructor === String  ) ||
                                                              (typeof obj === &quot;boolean&quot; || obj.constructor === Boolean ) ||
                                                              (typeof obj === &quot;number&quot;  || obj.constructor === Number  )    )
            {
                return obj;
            }

            map = map || new Map();
            var t = map.get(obj);
            if (typeof t !== &quot;undefined&quot;) {
                return t;
            }

            // clone with provided custom &quot;clone&quot; method
            if (typeof obj.$clone !== &quot;undefined&quot;) {
                return obj.$clone(map);
            }

            // clone array
            if (Array.isArray(obj)) {
                var naobj = [];

                map.set(obj, naobj);
                map[obj] = naobj;

                for(var i = 0; i &lt; obj.length; i++) {
                    naobj[i] = pkg.clone(obj[i], map);
                }
                return naobj;
            }

            // clone class
            if (obj.clazz === pkg.Class) {
                var clazz = pkg.Class(obj, []);
                clazz.inheritProperties = true;
                return clazz;
            }

            // function cannot be cloned
            if (typeof obj === &#x27;function&#x27; || obj.constructor !==  Object) {
                return obj;
            }

            var nobj = {};
            map.set(obj, nobj);

            // clone object fields
            for(var k in obj) {
                if (obj.hasOwnProperty(k) === true) {
                    nobj[k] = pkg.clone(obj[k], map);
                }
            }

            return nobj;
        };

        /**
         * Instantiate a new class instance of the given class with the specified constructor
         * arguments.
         * @param  {Function} clazz a class
         * @param  {Array} [args] an arguments list
         * @return {Object}  a new instance of the given class initialized with the specified arguments
         * @method newInstance
         * @for  zebkit
         */
        pkg.newInstance = function(clazz, args) {
            if (arguments.length &gt; 1 &amp;&amp; args.length &gt; 0) {
                var f = function () {};
                f.prototype = clazz.prototype;
                var o = new f();
                clazz.apply(o, args);
                return o;
            }
            return new clazz();
        };

        /**
         * Get a property setter method if it is declared with the class of the specified object for the
         * given property. Setter is a method whose name matches the following pattern: &quot;set&lt;PropertyName&gt;&quot;
         * where the first letter of the property name is in upper case. For instance setter method for
         * property &quot;color&quot; has to have name &quot;setColor&quot;.
         * @param  {Object} obj an object instance
         * @param  {String} name a property name
         * @return {Function}  a method that can be used as a setter for the given property
         * @method  getPropertySetter
         * @protected
         * @for  zebkit
         */
        pkg.getPropertySetter = function(obj, name) {
            var pi = obj.constructor.$propertyInfo, m = null;
            if (typeof pi !== &#x27;undefined&#x27;) {
                if (typeof pi[name] === &quot;undefined&quot;) {
                    m = obj[ &quot;set&quot; + name[0].toUpperCase() + name.substring(1) ];
                    pi[name] = (typeof m  === &quot;function&quot;) ? m : null;
                }
                return pi[name];
            }

            m = obj[ &quot;set&quot; + name[0].toUpperCase() + name.substring(1) ];
            return (typeof m  === &quot;function&quot;) ? m : null;
        };

        /**
         * Populate the given target object with the properties set. The properties set
         * is a dictionary that keeps properties names and its corresponding values.
         * The method detects if a property setter method exits and call it to apply
         * the property value. Otherwise property is initialized as a field. Setter
         * method is a method that matches &quot;set&lt;PropertyName&gt;&quot; pattern.
         * @param  {Object} target a target object
         * @param  {Object} p   a properties set
         * @return {Object} an object with the populated properties set.
         * @method  properties
         * @for  zebkit
         */
        pkg.properties = function(target, p) {
            for(var k in p) {
                // skip private properties( properties that start from &quot;$&quot;)
                if (k !== &quot;clazz&quot; &amp;&amp; k[0] !== &#x27;$&#x27; &amp;&amp; p.hasOwnProperty(k) &amp;&amp; typeof p[k] !== &quot;undefined&quot; &amp;&amp; typeof p[k] !== &#x27;function&#x27;) {
                    if (k[0] === &#x27;-&#x27;) {
                        delete target[k.substring(1)];
                    } else {
                        var v = p[k],
                            m = zebkit.getPropertySetter(target, k);

                        // value factory detected
                        if (v !== null &amp;&amp; typeof v.$new !== &#x27;undefined&#x27;) {
                            v = v.$new();
                        }

                        if (m === null) {
                            target[k] = v;  // setter doesn&#x27;t exist, setup it as a field
                        } else {
                            // property setter is detected, call setter to
                            // set the property value
                            if (Array.isArray(v)) {
                                m.apply(target, v);
                            } else {
                                m.call(target, v);
                            }
                        }
                    }
                }
            }
            return target;
        };

        function $make_proto(props, superProto) {
            if (superProto === null) {
                return function $prototype(clazz) {
                    for(var k in props) {
                        if (props.hasOwnProperty(k)) {
                            this[k] = props[k];
                        }
                    }
                };
            } else {
                return function $prototype(clazz) {
                    superProto.call(this, clazz);
                    for(var k in props) {
                        if (props.hasOwnProperty(k)) {
                            this[k] = props[k];
                        }
                    }
                };
            }
        }

        /**
         * Interface is way to share common functionality by avoiding multiple inheritance.
         * It allows developers to mix number of methods to different classes. For instance:

        // declare &quot;I&quot; interface that contains one method a
        var I = zebkit.Interface([
            function a() {

            }
        ]);

        // declare &quot;A&quot; class
        var A = zebkit.Class([]);

        // declare &quot;B&quot; class that inherits class A and mix interface &quot;I&quot;
        var B = zebkit.Class(A, I, []);

        // instantiate &quot;B&quot; class
        var b = new B();
        zebkit.instanceOf(b, I);  // true
        zebkit.instanceOf(b, A);  // true
        zebkit.instanceOf(b, B);  // true

        // call mixed method
        b.a();

         * @return {Function} an interface
         * @param {Array} [methods] list of methods declared in the interface
         * @constructor
         * @class  zebkit.Interface
         */
        pkg.Interface = make_template(null, function() {
            var $Interface = make_template(pkg.Interface, function() {
                // Clone interface  parametrized with the given properties set
                if (typeof this === &#x27;undefined&#x27; || this.constructor !== $Interface) {  // means the method execution is not a result of &quot;new&quot; method
                    if (arguments.length !== 1) {
                        throw new Error(&quot;Invalid number of arguments. Properties set is expected&quot;);
                    }

                    if (arguments[0].constructor !== Object) {
                        throw new Error(&quot;Invalid argument type. Properties set is expected&quot;);
                    }

                    var clone = $Interface.$clone();
                    clone.prototype.$prototype = $make_proto(arguments[0],
                                                             $Interface.prototype.$prototype);
                    return clone;
                } else {
                    // Create a class that inherits the interface and instantiate it
                    if (arguments.length &gt; 1) {
                        throw new Error(&quot;One or zero argument is expected&quot;);
                    }
                    return new (pkg.Class($Interface, arguments.length &gt; 0 ? arguments[0] : []))();
                }
            });

            if (arguments.length &gt; 1) {
                throw new Error(&quot;Invalid number of arguments. List of methods or properties is expected&quot;);
            }

            // abstract method counter, not used now, but can be used in the future
            // to understand if the given class override all abstract methods (should be
            // controlled in the places of &quot;cpMethods&quot; call)
            $Interface.$abstractMethods = 0;

            var arg = arguments.length === 0 ? [] : arguments[0];
            if (arg.constructor === Object) {
                arg = [ $make_proto(arg, null) ];
            } else if (Array.isArray(arg) === false) {
                throw new Error(&quot;Invalid argument type. List of methods pr properties is expected&quot;);
            }

            if (arg.length &gt; 0) {
                var  proto      = $Interface.prototype,
                     isAbstract = false;

                for(var i = 0; i &lt; arg.length; i++) {
                    var method = arg[i];

                    if (method === &quot;abstract&quot;) {
                        isAbstract = true;
                    } else {
                        if (typeof method !== &quot;function&quot;) {
                            throw new Error(&quot;Method is expected instead of &quot; + method);
                        }

                        var name = pkg.$FN(method);
                        if (name === pkg.CDNAME) {
                            throw new Error(&quot;Constructor declaration is not allowed in interface&quot;);
                        }

                        if (typeof proto[name] !== &#x27;undefined&#x27;) {
                            throw new Error(&quot;Duplicated interface method &#x27;&quot; + name + &quot;(...)&#x27;&quot;);
                        }

                        if (name === &quot;$clazz&quot;) {
                            method.call($Interface, $Interface);
                        } else if (isAbstract === true) {
                            (function(name) {
                                proto[name] = function() {
                                    throw new Error(&quot;Abstract method &#x27;&quot; + name + &quot;(...)&#x27; is not implemented&quot;);
                                };

                                // mark method as abstract
                                proto[name].$isAbstract = true;

                                // count abstract methods
                                $Interface.$abstractMethods++;
                            })(name);
                        } else {
                            proto[name] = method;
                        }
                    }
                }
            }

            /**
             * Private implementation of an interface cloning.
             * @return {zebkit.Interface} a clone of the interface
             * @method $clone
             * @private
             */
            $Interface.$clone = function() {
                var clone = pkg.Interface(), k = null; // create interface

                // clone interface level variables
                for(k in this) {
                    if (this.hasOwnProperty(k)) {
                        clone[k] = pkg.clone(this[k]);
                    }
                }

                // copy methods from proto
                var proto = this.prototype;
                for(k in proto) {
                    if (k !== &quot;clazz&quot; &amp;&amp; proto.hasOwnProperty(k) === true) {
                        clone.prototype[k] = pkg.clone(proto[k]);
                    }
                }

                return clone;
            };

            $Interface.clazz.$name = &quot;zebkit.Interface&quot;; // assign name
            return $Interface;
        });

        /**
         * Core method method to declare a zebkit class following easy OOP approach. The easy OOP concept
         * supports the following OOP features:
         *
         *
         *  __Single class inheritance.__ Any class can extend an another zebkit class

        // declare class &quot;A&quot; that with one method &quot;a&quot;
        var A = zebkit.Class([
            function a() { ... }
        ]);

        // declare class &quot;B&quot; that inherits class &quot;A&quot;
        var B = zebkit.Class(A, []);

        // instantiate class &quot;B&quot; and call method &quot;a&quot;
        var b = new B();
        b.a();


        * __Class method overriding.__ Override a parent class method implementation

        // declare class &quot;A&quot; that with one method &quot;a&quot;
        var A = zebkit.Class([
            function a() { ... }
        ]);

        // declare class &quot;B&quot; that inherits class &quot;A&quot;
        // and overrides method a with an own implementation
        var B = zebkit.Class(A, [
            function a() { ... }
        ]);


        * __Constructors.__ Constructor is a method with empty name

        // declare class &quot;A&quot; that with one constructor
        var A = zebkit.Class([
            function () { this.variable = 100; }
        ]);

        // instantiate &quot;A&quot;
        var a = new A();
        a.variable // variable is 100

        * __Static methods and variables declaration.__ Static fields and methods can be defined
            by declaring special &quot;$clazz&quot; method whose context is set to declared class

        var A = zebkit.Class([
            // special method where static stuff has to be declared
            function $clazz() {
                // declare static field
                this.staticVar = 100;
                // declare static method
                this.staticMethod = function() {};
            }
        ]);

        // access static field an method
        A.staticVar      // 100
        A.staticMethod() // call static method

        * __Access to super class context.__ You can call method declared in a parent class

        // declare &quot;A&quot; class with one class method &quot;a(p1,p2)&quot;
        var A = zebkit.Class([
            function a(p1, p2) { ... }
        ]);

        // declare &quot;B&quot; class that inherits &quot;A&quot; class and overrides &quot;a(p1,p2)&quot; method
        var B = zebkit.Class(A, [
            function a(p1, p2) {
                // call &quot;a(p1,p2)&quot; method implemented with &quot;A&quot; class
                this.$super(p1,p2);
            }
        ]);

         *
         *  One of the powerful feature of zebkit easy OOP concept is possibility to instantiate
         *  anonymous classes and interfaces. Anonymous class is an instance of an existing
         *  class that can override the original class methods with own implementations, implements
         *  own list of interfaces and methods. In other words the class instance customizes class
         *  definition for the particular instance of the class;

        // declare &quot;A&quot; class
        var A = zebkit.Class([
            function a() { return 1; }
        ]);

        // instantiate anonymous class that add an own implementation of &quot;a&quot; method
        var a = new A([
            function a() { return 2; }
        ]);
        a.a() // return 2

         * @param {zebkit.Class} [inheritedClass] an optional parent class to be inherited
         * @param {zebkit.Interface} [inheritedInterfaces]* an optional list of interfaces for
         * the declared class to be mixed in the class
         * @param {Array} methods list of declared class methods. Can be empty array.
         * @return {Function} a class definition
         * @constructor
         * @class zebkit.Class
         */
        var mixing = pkg.$mixing = function(clazz, methods) {
            if (Array.isArray(methods) === false) {
                throw new Error(&quot;Methods array is expected (&quot; + methods + &quot;)&quot;);
            }

            var names = {};
            for(var i = 0; i &lt; methods.length; i++) {
                var method     = methods[i],
                    methodName = pkg.$FN(method);

                // detect if the passed method is proxy method
                if (typeof method.methodBody !== &#x27;undefined&#x27;) {
                    throw new Error(&quot;Proxy method &#x27;&quot; + methodName + &quot;&#x27; cannot be mixed in a class&quot;);
                }

                // map user defined constructor to internal constructor name
                if (methodName === pkg.CDNAME) {
                    methodName = pkg.CNAME;
                } else if (methodName[0] === &#x27;$&#x27;) {
                    // populate prototype fields if a special method has been defined
                    if (methodName === &quot;$prototype&quot;) {
                        method.call(clazz.prototype, clazz);
                        if (clazz.prototype[pkg.CDNAME]) {
                            clazz.prototype[pkg.CNAME] = clazz.prototype[pkg.CDNAME];
                            delete clazz.prototype[pkg.CDNAME];
                        }
                        continue;
                    }

                    // populate class level fields if a special method has been defined
                    if (methodName === &quot;$clazz&quot;) {
                        method.call(clazz);
                        continue;
                    }
                }

                if (names[methodName] === true) {
                    throw new Error(&quot;Duplicate declaration of &#x27;&quot; + methodName+ &quot;(...)&#x27; method&quot;);
                }

                var existentMethod = clazz.prototype[methodName];
                if (typeof existentMethod !== &#x27;undefined&#x27; &amp;&amp; typeof existentMethod !== &#x27;function&#x27;) {
                    throw new Error(&quot;&#x27;&quot; + methodName + &quot;(...)&#x27; method clash with a field&quot;);
                }

                // if constructor doesn&#x27;t have super definition than let&#x27;s avoid proxy method
                // overhead
                if (typeof existentMethod === &#x27;undefined&#x27; &amp;&amp; methodName === pkg.CNAME) {
                    clazz.prototype[methodName] = method;
                } else {
                    // Create and set proxy method that is bound to the given class
                    clazz.prototype[methodName] = ProxyMethod(methodName, method, clazz);
                }

                // save method we have already added to check double declaration error
                names[methodName] = true;
            }
        };

        // create Class template what means we define a function (meta class) that has to be used to define
        // Class. That means we define a function that returns another function that is a Class
        pkg.Class = make_template(null, function() {
            if (arguments.length === 0) {
                throw new Error(&quot;No class method list was found&quot;);
            }

            if (Array.isArray(arguments[arguments.length - 1]) === false) {
                throw new Error(&quot;No class methods have been passed&quot;);
            }

            if (arguments.length &gt; 1 &amp;&amp; typeof arguments[0] !== &quot;function&quot;)  {
                throw new ReferenceError(&quot;Invalid parent class or interface &#x27;&quot; + arguments[0] + &quot;&#x27;&quot;);
            }

            var classMethods = arguments[arguments.length - 1],
                parentClass  = null,
                toInherit    = [];

            // detect parent class in inheritance list as the first argument that has &quot;clazz&quot; set to Class
            if (arguments.length &gt; 0 &amp;&amp; (arguments[0] === null || arguments[0].clazz === pkg.Class)) {
                parentClass = arguments[0];
            }

            // use instead of slice for performance reason
            for(var i = 0; i &lt; arguments.length - 1; i++) {
                toInherit[i] = arguments[i];

                // let&#x27;s make sure we inherit interface
                if (parentClass === null || i &gt; 0) {
                    if (typeof toInherit[i] === &#x27;undefined&#x27; || toInherit[i] === null) {
                        throw new ReferenceError(&quot;Undefined inherited interface [&quot; + i + &quot;] &quot; );
                    } else if (toInherit[i].clazz !== pkg.Interface) {
                        throw new ReferenceError(&quot;Inherited interface is not an Interface ( [&quot; + i + &quot;] &#x27;&quot; + toInherit[i] + &quot;&#x27;&#x27;)&quot;);
                    }
                }
            }

            // define Class (function) that has to be used to instantiate the class instance
            var classTemplate = make_template(pkg.Class, function() {
                if (classTemplate.$uniqueness === true) {
                    this.$hash$ = &quot;$ZkIo&quot; + ($$$++);
                }

                if (arguments.length &gt; 0) {
                    var a = arguments[arguments.length - 1];

                    // anonymous is customized class instance if last arguments is array of functions
                    if (Array.isArray(a) === true &amp;&amp; typeof a[0] === &#x27;function&#x27;) {
                        a = a[0];

                        // prepare arguments list to declare an anonymous class
                        var args = [ classTemplate ],      // first of all the class has to inherit the original class
                            k    = arguments.length - 2;

                        // collect interfaces the anonymous class has to implement
                        for(; k &gt;= 0 &amp;&amp; arguments[k].clazz === pkg.Interface; k--) {
                            args.push(arguments[k]);
                        }

                        // add methods list
                        args.push(arguments[arguments.length - 1]);

                        var cl = pkg.Class.apply(null, args),  // declare new anonymous class
                            // create a function to instantiate an object that will be made the
                            // anonymous class instance. The intermediate object is required to
                            // call constructor properly since we have arguments as an array
                            f  = function() {};

                        cl.$name = classTemplate.$name; // the same class name for anonymous
                        f.prototype = cl.prototype; // the same prototypes

                        var o = new f();

                        // call constructor
                        // use array copy instead of cloning with slice for performance reason
                        // (Array.prototype.slice.call(arguments, 0, k + 1))
                        args = [];
                        for (var i = 0; i &lt; k + 1; i++) {
                            args[i] = arguments[i];
                        }
                        cl.apply(o, args);

                        // set constructor field for consistency
                        o.constructor = cl;
                        return o;
                    }
                }

                // call class constructor
                if (typeof this.$ !== &#x27;undefined&#x27;) { // TODO: hard-coded constructor name to speed up
                    return this.$.apply(this, arguments);
                }
            }, toInherit);


            /**
             *  Internal attribute that caches properties setter references.
             *  @attribute $propertyInfo
             *  @type {Object}
             *  @private
             *  @for zebkit.Class
             *  @readOnly
             */
            // prepare fields that caches the class properties. existence of the property
            // force getPropertySetter method to cache the method
            classTemplate.$propertyInfo = {};

            /**
             *  Reference to a parent class
             *  @attribute $parent
             *  @type {zebkit.Class}
             *  @protected
             *  @readOnly
             */

            // copy parents prototype methods and fields into
            // new class template
            classTemplate.$parent = parentClass;
            if (parentClass !== null) {
                for(var k in parentClass.prototype) {
                    if (parentClass.prototype.hasOwnProperty(k)) {
                        var f = parentClass.prototype[k];
                        classTemplate.prototype[k] = (typeof f !== &#x27;undefined&#x27; &amp;&amp;
                                                      f !== null &amp;&amp;
                                                      f.hasOwnProperty(&quot;methodBody&quot;)) ? ProxyMethod(f.methodName, f.methodBody, f.boundTo)
                                                                                      : f;
                    }
                }
            }

            /**
             * Extend existent class instance with the given methods and interfaces
             * For example:

                var A = zebkit.Class([ // declare class A that defines one &quot;a&quot; method
                    function a() {
                        console.log(&quot;A:a()&quot;);
                    }
                ]);

                var a = new A();
                a.a();  // show &quot;A:a()&quot; message

                A.a.extend([
                    function b() {
                        console.log(&quot;EA:b()&quot;);
                    },

                    function a() {   // redefine &quot;a&quot; method
                        console.log(&quot;EA:a()&quot;);
                    }
                ]);

                a.b(); // show &quot;EA:b()&quot; message
                a.a(); // show &quot;EA:a()&quot; message

             * @param {zebkit.Interface} [interfaces]* interfaces to be implemented with the
             * class instance
             * @param {Array} methods list of methods the class instance has to be extended
             * with
             * @method extend
             * @for zebkit.Class.zObject
             */
            classTemplate.prototype.extend = function() {
                var clazz = this.clazz,
                    l = arguments.length,
                    f = arguments[l - 1],
                    hasArray = Array.isArray(f),
                    i = 0;

                // replace the instance class with a new intermediate class
                // that inherits the replaced class. it is done to support
                // $super method calls.
                if (this.$isExtended !== true) {
                    clazz = pkg.Class(clazz, []);
                    this.$isExtended = true;         // mark the instance as extended to avoid double extending.
                    clazz.$name = this.clazz.$name;
                    this.clazz = clazz;
                }

                if (hasArray) {
                    var init = null;
                    for(i = 0; i &lt; f.length; i++) {
                        var n = pkg.$FN(f[i]);
                        if (n === pkg.CDNAME) {
                            init = f[i];  // postpone calling initializer before all methods will be defined
                        } else {
                            if (typeof this[n] !== &#x27;undefined&#x27; &amp;&amp; typeof this[n] !== &#x27;function&#x27;) {
                                throw new Error(&quot;Method &#x27;&quot; + n + &quot;&#x27; clash with a property&quot;);
                            }
                            this[n] = ProxyMethod(n, f[i], clazz);
                        }
                    }

                    if (init !== null) {
                        init.call(this);
                    }
                    l--;
                }

                // add new interfaces if they has been passed
                for (i = 0; i &lt; arguments.length - (hasArray ? 1 : 0); i++) {
                    if (arguments[i].clazz !== pkg.Interface) {
                        throw new Error(&quot;Invalid argument &quot; + arguments[i] + &quot; Interface is expected.&quot;);
                    }

                    var I = arguments[i];
                    if (typeof clazz.$parents[I.$hash$] !== &#x27;undefined&#x27;) {
                        throw new Error(&quot;Interface has been already inherited&quot;);
                    }

                    cpMethods(I.prototype, this, clazz);
                    clazz.$parents[I.$hash$] = I;
                }
                return this;
            };

            /**
             * Call super method implementation.
             * @param {Function} [superMethod]? optional parameter that should be a method of the class instance
             * that has to be called
             * @param {Object} [args]* arguments list to pass the executed method
             * @return {Object} return what super method returns
             * @method $super
             * @example
             *
             *    var A = zebkit.Class([
             *        function a(p) { return 10 + p; }
             *    ]);
             *
             *    var B = zebkit.Class(A, [
             *        function a(p) {
             *            return this.$super(p) * 10;
             *        }
             *    ]);
             *
             *    var b = new B();
             *    b.a(10) // return 200
             *
             * @for zebkit.Class.zObject
             */
            classTemplate.prototype.$super = function() {
               if ($caller !== null) {
                    for (var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== &#x27;undefined&#x27;) {
                            return m.apply(this, arguments);
                        }
                    }

                    // handle method not found error
                    var cln = this.clazz &amp;&amp; this.clazz.$name ? this.clazz.$name + &quot;.&quot; : &quot;&quot;;
                    throw new ReferenceError(&quot;Method &#x27;&quot; +
                                             cln +
                                             ($caller.methodName === pkg.CNAME ? &quot;constructor&quot;
                                                                               : $caller.methodName) + &quot;(&quot; + arguments.length + &quot;)&quot; + &quot;&#x27; not found&quot;);
                } else {
                    throw new Error(&quot;$super is called outside of class context&quot;);
                }
            };

            // TODO: not stable API
            classTemplate.prototype.$supera = function(args) {
               if ($caller !== null) {
                    for (var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== &#x27;undefined&#x27;) {
                            return m.apply(this, args);
                        }
                    }

                    // handle method not found error
                    var cln = this.clazz &amp;&amp; this.clazz.$name ? this.clazz.$name + &quot;.&quot; : &quot;&quot;;
                    throw new ReferenceError(&quot;Method &#x27;&quot; +
                                             cln +
                                             ($caller.methodName === pkg.CNAME ? &quot;constructor&quot;
                                                                               : $caller.methodName) + &quot;(&quot; + arguments.length + &quot;)&quot; + &quot;&#x27; not found&quot;);
                } else {
                    throw new Error(&quot;$super is called outside of class context&quot;);
                }
            };

            // TODO: not stable API, $super that doesn&#x27;t throw exception is there is no super implementation
            classTemplate.prototype.$$super = function() {
               if ($caller !== null) {
                    for(var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[$caller.methodName];
                        if (typeof m !== &#x27;undefined&#x27;) {
                            return m.apply(this, arguments);
                        }
                    }
                } else {
                    throw new Error(&quot;$super is called outside of class context&quot;);
                }
            };

            /**
             * Get a first super implementation of the given method in a parent classes hierarchy.
             * @param  {String} name a name of the method
             * @return {Function} a super method implementation
             * @method  $getSuper
             * @for  zebkit.Class.zObject
             */
            classTemplate.prototype.$getSuper = function(name) {
               if ($caller !== null) {
                    for(var $s = $caller.boundTo.$parent; $s !== null; $s = $s.$parent) {
                        var m = $s.prototype[name];
                        if (typeof m === &#x27;function&#x27;) {
                            return m;
                        }
                    }
                    return null;
                }
                throw new Error(&quot;$super is called outside of class context&quot;);
            };

            classTemplate.prototype.$genHash = function() {
                if (typeof this.$hash$ === &#x27;undefined&#x27;) {
                    this.$hash$ = &quot;$ZeInGen&quot; + ($$$++);
                }
                return this.$hash$;
            };

            classTemplate.prototype.$clone = function(map) {
                map = map || new Map();

                var f = function() {};
                f.prototype = this.constructor.prototype;
                var nobj = new f();
                map.set(this, nobj);

                for(var k in this) {
                    if (this.hasOwnProperty(k)) {
                        // obj&#x27;s layout is obj itself
                        var t = map.get(this[k]);
                        if (t !== undefined) {
                            nobj[k] = t;
                        } else {
                            nobj[k] = zebkit.clone(this[k], map);
                        }
                    }
                }

                // speed up clearing resources
                map.clear();

                nobj.constructor = this.constructor;

                if (typeof nobj.$hash$ !== &#x27;undefined&#x27;) {
                    nobj.$hash$ = &quot;$zObj_&quot; + ($$$++);
                }

                nobj.clazz = this.clazz;
                return nobj;
            };

            /**
             * The instance class.
             * @attribute clazz
             * @type {zebkit.Class}
             */
            classTemplate.prototype.clazz = classTemplate;

            // check if the method has been already defined in the class
            if (typeof classTemplate.prototype.properties === &#x27;undefined&#x27;) {
                classTemplate.prototype.properties = function(p) {
                    return pkg.properties(this, p);
                };
            }

            // copy methods from interfaces before mixing class methods
            if (toInherit.length &gt; 0) {
                for(var i = toInherit[0].clazz === pkg.Interface ? 0 : 1; i &lt; toInherit.length; i++) {
                    var  ic = toInherit[i];
                    cpMethods(ic.prototype, classTemplate.prototype, classTemplate);

                    // copy static fields from interface to the class
                    for(var sk in ic) {
                        if (sk[0] !== &#x27;$&#x27; &amp;&amp;
                            ic.hasOwnProperty(sk) === true &amp;&amp;
                            classTemplate.hasOwnProperty(sk) === false)
                        {
                            classTemplate[sk] = pkg.clone(ic[sk]);
                        }
                    }
                }
            }

            // add class declared methods
            mixing(classTemplate, classMethods);

            // populate static fields
            // TODO: exclude the basic static methods and static constant
            // static inheritance

            classTemplate.$uniqueness = false;
            if (parentClass !== null) {
                for (var key in parentClass) {
                    if (key[0] !== &#x27;$&#x27; &amp;&amp;
                        parentClass.hasOwnProperty(key) &amp;&amp;
                        classTemplate.hasOwnProperty(key) === false)
                    {
                        classTemplate[key] = pkg.clone(parentClass[key]);
                    }
                }

                if (parentClass.$uniqueness === true) {
                    classTemplate.hashable();
                }
            }

            /**
             * Makes the class hashable. Hashable class instances are automatically
             * gets unique hash code that is returned with its overridden &quot;toString()&quot;
             * method. The hash code is stored in special &quot;$hash$&quot; field. The feature
             * can be useful when you want to store class instances in &quot;{}&quot; object
             * where key is the hash and the value is the instance itself.
             * @method hashable
             * @chainable
             * @for zebkit.Class
             */
            classTemplate.hashable = function() {
                if (this.$uniqueness !== true) {
                    this.$uniqueness = true;
                    this.prototype.toString = $toString;
                }
                return this;
            };

            /**
             * Makes the class hashless. Prevents generation of hash code for
             * instances of the class.
             * @method hashless
             * @chainable
             * @for zebkit.Class
             */
            classTemplate.hashless = function() {
                if (this.$uniqueness === true) {
                    this.$uniqueness = false;
                    this.prototype.toString = Object.prototype.toString;
                }
                return this;
            };

            /**
             * Extend the class with new method and implemented interfaces.
             * @param {zebkit.Interface} [interfaces]*  number of interfaces the class has to implement.
             * @param {Array} methods set of methods the given class has to be extended.
             * @method extend
             * @for  zebkit.Class
             */

            // add extend method later to avoid the method be inherited as a class static field
            classTemplate.extend = function() {
                var methods    = arguments[arguments.length - 1],
                    hasMethod  = Array.isArray(methods);

                // inject class
                if (hasMethod &amp;&amp; this.$isExtended !== true) {
                    // create intermediate class
                    var A = this.$parent !== null ? pkg.Class(this.$parent, [])
                                                  : pkg.Class([]);

                    // copy this class prototypes methods to intermediate class A and re-define
                    // boundTo to the intermediate class A if they were bound to source class
                    // methods that have been  moved from source class to class have to be re-bound
                    // to A class
                    for(var name in this.prototype) {
                        if (name !== &quot;clazz&quot; &amp;&amp; this.prototype.hasOwnProperty(name) ) {
                            var f = this.prototype[name];
                            if (typeof f === &#x27;function&#x27;) {
                                A.prototype[name] = typeof f.methodBody !== &#x27;undefined&#x27; ? ProxyMethod(name, f.methodBody, f.boundTo)
                                                                                        : f;

                                if (A.prototype[name].boundTo === this) {
                                    A.prototype[name].boundTo = A;
                                    if (f.boundTo === this) {
                                        f.boundTo = A;
                                    }
                                }
                            }
                        }
                    }

                    this.$parent = A;
                    this.$isExtended = true;
                }

                if (hasMethod) {
                    mixing(this, methods);
                }

                // add passed interfaces
                for(var i = 0; i &lt; arguments.length - (hasMethod ? 1 : 0); i++) {
                    var I = arguments[i];
                    if (I === null || typeof I === &#x27;undefined&#x27; || I.clazz !== zebkit.Interface) {
                        throw new Error(&quot;Interface is expected&quot;);
                    }

                    if (typeof this.$parents[I.$hash$] !== &#x27;undefined&#x27;) {
                        throw new Error(&quot;Interface has been already inherited&quot;);
                    }

                    cpMethods(I.prototype, this.prototype, this);
                    this.$parents[I.$hash$] = I;
                }
            };

            /**
             * Tests if the given class inherits the given class or interface.
             * @param  {zebkit.Class | zebkit.Interface}  clazz a class or interface.
             * @return {Boolean} true if the class or interface is inherited with
             * the class.
             * @method  isInherit
             * @for  zebkit.Class
             */
            classTemplate.isInherit = function(clazz) {
                if (this !== clazz) {
                    // detect class
                    if (clazz.clazz === this.clazz) {
                        for (var p = this.$parent; p !== null; p = p.$parent) {
                            if (p === clazz) {
                                return true;
                            }
                        }
                    } else { // detect interface
                        if (this.$parents[clazz.$hash$] === clazz) {
                            return true;
                        }
                    }
                }
                return false;
            };

            // assign proper name to class
            classTemplate.clazz.$name = &quot;zebkit.Class&quot;;

            // copy methods from interfaces
            if (toInherit.length &gt; 0) {
                // notify inherited class and interfaces that they have been inherited with the given class
                for(var i = 0; i &lt; toInherit.length; i++) {
                    if (typeof toInherit[i].inheritedWidth === &#x27;function&#x27;) {
                        toInherit[i].inheritedWidth(classTemplate);
                    }
                }
            }

            return classTemplate;
        });

        var $cachedO = pkg.$cachedO = {},
            $cachedE = pkg.$cachedE = [];

        /**
         * maximal cache size (cache is primary used to keep references to class).
         * @attribute $cacheSize
         * @private
         * @default 7777
         * @type {Number}
         * @for  zebkit
         */
        pkg.$cacheSize = 7777;

        /**
         * Get an object by the given key from cache (and cached it if necessary)
         * @param  {String} key a key to an object. The key is hierarchical reference starting with the global
         * name space as root. For instance &quot;test.a&quot; key will fetch $global.test.a object.
         * @return {Object}  an object
         * @for  zebkit
         * @private
         * @method  $cache
         */
        pkg.$cache = function(key) {
            // don&#x27;t cache global objects
            if (pkg.$global.hasOwnProperty(key)) {
                return pkg.$global[key];
            }

            if ($cachedO.hasOwnProperty(key) === true) {
                // read cached entry
                var e = $cachedO[key];
                if (e.i &lt; ($cachedE.length-1)) { // cached entry is not last one

                    // move accessed entry to the list tail to increase its access weight
                    var pn = $cachedE[e.i + 1];
                    $cachedE[e.i]   = pn;
                    $cachedE[++e.i] = key;
                    $cachedO[pn].i--;
                }
                return e.o;
            }

            var ctx = pkg.$global, i = 0, j = 0;
            for( ;ctx != null; ) {
                i = key.indexOf(&#x27;.&#x27;, j);

                if (i &lt; 0) {
                    ctx = ctx[key.substring(j, key.length)];
                    break;
                }

                ctx = ctx[key.substring(j, i)];
                j = i + 1;
            }

            if (ctx != null) {
                if ($cachedE.length &gt;= pkg.$cacheSize) {
                    // cache is full, replace first element with the new one
                    var n = $cachedE[0];
                    $cachedE[0]   = key;
                    $cachedO[key] = { o: ctx, i: 0 };
                    delete $cachedO[n];
                } else {
                    $cachedO[key] = { o: ctx, i: $cachedE.length };
                    $cachedE[$cachedE.length] = key;
                }
                return ctx;
            }

            throw new Error(&quot;Reference &#x27;&quot; + key + &quot;&#x27; not found&quot;);
        };

        /**
         * Get class by the given class name
         * @param  {String} name a class name
         * @return {Function} a class. Throws exception if the class cannot be
         * resolved by the given class name
         * @method forName
         * @throws Error
         * @for  zebkit.Class
         */
        pkg.Class.forName = function(name) {
            return pkg.$cache(name);
        };

        /**
         * Create an instance of the class
         * @param  {Object} [arguments]* arguments to be passed to the class constructor
         * @return {Object} an instance of the class.
         * @method newInstance
         * @for  zebkit.Class
         */
        pkg.Class.newInstance = function() {
            return pkg.newInstance(this, arguments);
        };

        /**
         * Test if the given object is instance of the specified class or interface. It is preferable
         * to use this method instead of JavaScript &quot;instanceof&quot; operator whenever you are dealing with
         * zebkit classes and interfaces.
         * @param  {Object} obj an object to be evaluated
         * @param  {Function} clazz a class or interface
         * @return {Boolean} true if a passed object is instance of the given class or interface
         * @method instanceOf
         * @for  zebkit
         */
        pkg.instanceOf = function(obj, clazz) {
            if (clazz !== null &amp;&amp; typeof clazz !== &#x27;undefined&#x27;) {
                if (obj === null || typeof obj === &#x27;undefined&#x27;)  {
                    return false;
                } else if (typeof obj.clazz === &#x27;undefined&#x27;) {
                    return (obj instanceof clazz);
                } else {
                    return typeof obj.clazz !== &#x27;undefined&#x27; &amp;&amp; obj.clazz !== null &amp;&amp;
                           (obj.clazz === clazz ||
                            obj.clazz.$parents.hasOwnProperty(clazz.$hash$));
                }
            }

            throw new Error(&quot;instanceOf(): null class&quot;);
        };

        /**
         * Dummy class that implements nothing but can be useful to instantiate
         * anonymous classes with some on &quot;the fly&quot; functionality:
         *
         *     // instantiate and use zebkit class with method &quot;a()&quot; implemented
         *     var ac = new zebkit.Dummy([
         *          function a() {
         *             ...
         *          }
         *     ]);
         *
         *     // use it
         *     ac.a();
         *
         * @constructor
         * @class zebkit.Dummy
         */
        pkg.Dummy = pkg.Class([]);

        pkg.DoIt = DoIt;

        /**
         * Event producer interface. This interface provides number of methods
         * to register, un-register, fire events. It follows on/off notion like
         * JQuery does it. It is expected an event producer class implementation
         * has a special field  &quot;_&quot; that keeps listeners.
         *
         *     var MyClass = zebkit.Class(zebkit.EventProducer, [
         *         function() {
         *             // &quot;fired&quot; events listeners container
         *             this._ = new zebkit.util.Listeners();
         *         }
         *     ]);
         *
         *     var a = new MyClass();
         *     a.on(&quot;fired&quot;, function(arg) {
         *         // handle &quot;fired&quot; events
         *     });
         *
         *     a.fire(10);
         *
         * @class zebkit.EventProducer
         * @interface zebkit.EventProducer
         */
        pkg.EventProducer = pkg.Interface([
            function $prototype() {
                // on(event, path, cb)  handle the given event for all elements identified with the path
                // on(cb)               handle all events
                // on(path | event, cb) handle the given event or all events for elements matched with the path


                /**
                 * Register listener for the given events types or/and the given nodes in tree-like
                 * structure or listen all events types.
                 * @param {String} [eventName] an event type name to listen. If the event name is not passed
                 * then listen all events types.
                 * @param {String} [path] a xpath-like path to traversing elements in tree and register event
                 * handlers for the found elements. The parameter can be used if the interface is implemented
                 * with tree-like structure (for instance zebkit UI components).
                 * @param {Function|Object} cb a listener method or an object that contains number of methods
                 * to listen the specified events types.
                 * @example
                 *     var comp = new zebkit.ui.Panel();
                 *     comp.add(new zebkit.ui.Button(&quot;Test 1&quot;).setId(&quot;c1&quot;));
                 *     comp.add(new zebkit.ui.Button(&quot;Test 2&quot;).setId(&quot;c2&quot;));
                 *     ...
                 *     // register event handler for children components of &quot;comp&quot;
                 *     comp.on(&quot;/*&quot;, function() {
                 *         // handle button fired event
                 *         ...
                 *     });
                 *
                 *     // register event handler for button component with id equals &quot;c1&quot;
                 *     comp.on(&quot;#c1&quot;, function() {
                 *         // handle button fired event
                 *         ...
                 *     });
                 *
                 * @method on
                 */
                this.on = function() {
                    var cb = arguments[arguments.length - 1],  // callback or object
                        pt = null,                             // path
                        nm = null;                             // event name

                    if (cb === null || isString(cb)) {
                        throw new Error(&quot;Invalid event handler&quot;);
                    }

                    if (arguments.length === 1) {
                        return this._.add(cb);
                    } else if (arguments.length === 2) {
                        if (arguments[0] === null) {
                            throw new Error(&quot;Invalid event or path&quot;);
                        } else if (arguments[0][0] === &#x27;.&#x27; || arguments[0][0] === &#x27;/&#x27; || arguments[0][0] === &#x27;#&#x27;) { // detect path
                            pt = arguments[0];
                        } else {
                            return this._.add(arguments[0], cb);
                        }
                    } else if (arguments.length === 3) {
                        pt = arguments[1];
                        nm = arguments[0];
                        if (pt === null) {
                            return this._.add(nm, cb);
                        }
                    }

                    this.byPath(pt, function(node) {
                        if (typeof node._ !== &#x27;undefined&#x27;) {
                            if (nm !== null) {
                                if (typeof node._[nm] !== &#x27;undefined&#x27;) {
                                    node._.add(nm, cb);
                                }
                            } else {
                                node._.add(cb);
                            }
                        }
                        return false;
                    });

                    return cb;
                };

                // off()            remove all events handler
                // off(event)       remove the event handler
                // off(event, path)  remove the event handler for all nodes detected with the path
                // off(path)
                // off(cb)
                // off(path, cb)
                //
                /**
                 * Stop listening the given event type.
                 * @param {String} [eventName] an event type name to stop listening. If the event name is not passed
                 * then stop listening all events types.
                 * @param {String} [path] a xpath-like path to traversing elements in tree and stop listening
                 * the event type for the found in the tree elements. The parameter can be used if the interface
                 * is implemented with tree-like structure (for instance zebkit UI components).
                 * @param [cb] remove the given event handler.
                 * @method off
                 */
                this.off = function() {
                    var pt = null,  // path
                        fn = null,  // handler
                        nm = null;  // event name or listener

                    if (arguments.length === 0) {
                        return this._.remove();
                    } else if (arguments.length === 1) {
                        if (isString(arguments[0]) &amp;&amp; (arguments[0][0] === &#x27;.&#x27; || arguments[0][0] === &#x27;/&#x27; || arguments[0][0] === &#x27;#&#x27;)) {
                            pt = arguments[0];
                        } else {
                            return this._.remove(arguments[0]);
                        }
                    } else if (arguments.length === 2) {
                        if (isString(arguments[1])) { // detect path
                            pt = arguments[1];
                            nm = arguments[0];
                        } else {
                            if (isString(arguments[1])) {
                                nm = arguments[1];
                            } else {
                                fn = arguments[1];
                            }

                            if (arguments[0][0] === &#x27;.&#x27; || arguments[0][0] === &#x27;/&#x27; || arguments[0][0] === &#x27;#&#x27;) {
                                pt = arguments[0];
                            } else {
                                throw new Error(&quot;Path is expected&quot;);
                            }
                        }
                    }

                    this.byPath(pt, function(node) {
                        if (typeof node._ !== &#x27;undefined&#x27;) {
                            if (fn !== null) {
                                node._.remove(fn);
                            } else if (nm !== null) {
                                if (typeof node._[nm] !== &#x27;undefined&#x27;) {
                                    node._.remove(nm);
                                }
                            } else {
                                node._.remove();
                            }
                        }
                        return false;
                    });
                };

                // fire(event, [ a1, a2, ...])
                // fire(event, e)
                // fire(event, path, e)
                // fire(event, path, [a1, a2 ...])
                this.fire = function() {
                    var pt   = null,  // path
                        args = null,
                        nm   = arguments[0];  // event name or listener

                    if (arguments.length &gt;= 0 &amp;&amp; arguments.length &lt; 3) {
                        if (arguments.length === 0) {
                            nm = &quot;fired&quot;;
                        }

                        if (this._.hasEvent(nm) === false) {
                            throw new Error(&quot;Listener doesn&#x27;t &#x27;&quot; + nm + &quot;&#x27; support the event&quot;);
                        }

                        var fn = this._[nm];
                        args = (arguments.length === 2 ? arguments[1] : this);

                        return arguments.length === 2 &amp;&amp; Array.isArray(args) ? fn.apply(this._, args)
                                                                             : fn.call(this._, args);

                    } else if (arguments.length === 3) {
                        pt   = arguments[1];
                        args = arguments[2];
                    } else {
                        throw new Error(&quot;Invalid number of arguments&quot;);
                    }

                    this.byPath(pt, function(n) {
                        var ec = n._;
                        if (typeof ec !== &#x27;undefined&#x27; &amp;&amp; n._.hasEvent(nm)) {
                            if (args !== null &amp;&amp; Array.isArray(args)) {
                                ec[nm].apply(ec, args);
                            } else {
                                ec[nm].call(ec, args);
                            }
                        }
                        return false;
                    });
                };
            }
        ]);
    });

    if (isInBrowser) {
        zebkit.then(function() {
            var jn        = this.join(),
                $interval = zenv.setInterval(function () {
                if (document.readyState === &quot;complete&quot;) {
                    zenv.clearInterval($interval);
                    jn(zebkit);
                }
            }, 100);
        });
    }

    return zebkit;
})();

/**
 * This class represents a font and provides basic font metrics like height, ascent. Using
 * the class developers can compute string width.
 *
 *     // plain font
 *     var f = new zebkit.Font(&quot;Arial&quot;, 14);
 *
 *     // bold font
 *     var f = new zebkit.Font(&quot;Arial&quot;, &quot;bold&quot;, 14);
 *
 *     // defining font with CSS font name
 *     var f = new zebkit.Font(&quot;100px Futura, Helvetica, sans-serif&quot;);
 *
 * @constructor
 * @param {String} name a name of the font. If size and style parameters has not been passed
 * the name is considered as CSS font name that includes size and style
 * @param {String} [style] a style of the font: &quot;bold&quot;, &quot;italic&quot;, etc
 * @param {Integer} [size] a size of the font
 * @class zebkit.Font
 */
zebkit.Font = zebkit.Class([
    function(family, style, size) {
        if (arguments.length === 1) {
            this.size = this.clazz.decodeSize(family);
            if (this.size === null) {
                // trim
                family = family.trim();

                // check if a predefined style has been used
                if (family === &quot;bold&quot; || family === &quot;italic&quot;) {
                    this.style = family;
                } else {  // otherwise handle it as CSS-like font style
                    // try to parse font if possible
                    var re = /([a-zA-Z_\- ]+)?(([0-9]+px|[0-9]+em)\s+([,\&quot;&#x27;a-zA-Z_ \-]+))?/,
                        m  = family.match(re);

                    if (typeof m[4] !== &#x27;undefined&#x27;) {
                        this.family = m[4].trim();
                    }

                    if (typeof m[3] !== &#x27;undefined&#x27;) {
                        this.size = m[3].trim();
                    }

                    if (typeof m[1] !== &#x27;undefined&#x27;) {
                        this.style = m[1].trim();
                    }

                    this.s = family;
                }
            }
        } else if (arguments.length === 2) {
            this.family = family;
            this.size   = this.clazz.decodeSize(style);
            this.style  = this.size === null ? style : null;
        } else if (arguments.length === 3) {
            this.family = family;
            this.style  = style;
            this.size   = this.clazz.decodeSize(size);
        }

        if (this.size === null) {
            this.size = this.clazz.size + &quot;px&quot;;
        }

        if (this.s === null) {
            this.s = ((this.style !== null) ? this.style + &quot; &quot;: &quot;&quot;) +
                     this.size + &quot; &quot; +
                     this.family;
        }

        var mt = zebkit.environment.fontMetrics(this.s);

        /**
         * Height of the font
         * @attribute height
         * @readOnly
         * @type {Integer}
         */
        this.height = mt.height;

        /**
         * Ascent of the font
         * @attribute ascent
         * @readOnly
         * @type {Integer}
         */
        this.ascent = mt.ascent;
    },

    function $clazz() {

        // default values
        this.family = &quot;Arial, Helvetica&quot;;
        this.style  =  null;
        this.size   =  14;

        this.mergeable = false;

        this.decodeSize = function(s, defaultSize) {
            if (arguments.length &lt; 2) {
                defaultSize = this.size;
            }

            if (typeof s === &quot;string&quot; || s.constructor === String) {
                var size = Number(s);
                if (isNaN(size)) {
                    var m = s.match(/^([0-9]+)(%)$/);
                    if (m !== null &amp;&amp; typeof m[1] !== &#x27;undefined&#x27; &amp;&amp; m[2] !== &#x27;undefined&#x27;) {
                        size = Math.floor((defaultSize * parseInt(m[1], 10)) / 100);
                        return size + &quot;px&quot;;
                    } else {
                        return /^([0-9]+)(em|px)$/.test(s) === true ? s : null;
                    }
                } else {
                    if (s[0] === &#x27;+&#x27;) {
                        size = defaultSize + size;
                    } else if (s[0] === &#x27;-&#x27;) {
                        size = defaultSize - size;
                    }
                    return size + &quot;px&quot;;
                }
            }
            return s === null ? null : s + &quot;px&quot;;
        };
    },

    function $prototype(clazz) {
        this.s = null;

        /**
         *  Font family.
         *  @attribute family
         *  @type {String}
         *  @default null
         */
        this.family = clazz.family;

        /**
         *  Font style (for instance &quot;bold&quot;).
         *  @attribute style
         *  @type {String}
         *  @default null
         */
        this.style = clazz.style;
        this.size  = clazz.size;

        /**
         * Returns CSS font representation
         * @return {String} a CSS representation of the given Font
         * @method toString
         * @for zebkit.Font
         */
        this.toString = function() {
            return this.s;
        };

        /**
         * Compute the given string width in pixels basing on the
         * font metrics.
         * @param  {String} s a string
         * @return {Integer} a string width
         * @method stringWidth
         */
        this.stringWidth = function(s) {
            if (s.length === 0) {
                return 0;
            } else {
                var fm = zebkit.environment.fontMeasure;
                if (fm.font !== this.s) {
                    fm.font = this.s;
                }

                return Math.round(fm.measureText(s).width);
            }
        };

        /**
         * Calculate the specified substring width
         * @param  {String} s a string
         * @param  {Integer} off fist character index
         * @param  {Integer} len length of substring
         * @return {Integer} a substring size in pixels
         * @method charsWidth
         * @for zebkit.Font
         */
        this.charsWidth = function(s, off, len) {
            var fm = zebkit.environment.fontMeasure;
            if (fm.font !== this.s) {
                fm.font = this.s;
            }

            return Math.round((fm.measureText(len === 1 ? s[off]
                                                        : s.substring(off, off + len))).width );
        };

        /**
         * Resize font and return new instance of font class with new size.
         * @param  {Integer | String} size can be specified in pixels as integer value or as
         * a percentage from the given font:
         * @return {zebkit.Font} a font
         * @for zebkit.Font
         * @method resize
         * @example
         *
         * &#x60;&#x60;&#x60;javascript
         * var font = new zebkit.Font(10); // font 10 pixels
         * font = font.resize(&quot;200%&quot;); // two times higher font
         * &#x60;&#x60;&#x60;
         */
        this.resize = function(size) {
            var nsize = this.clazz.decodeSize(size, this.height);
            if (nsize === null) {
                throw new Error(&quot;Invalid font size : &quot; + size);
            }
            return new this.clazz(this.family, this.style, nsize);
        };

        /**
         * Restyle font and return new instance of the font class
         * @param  {String} style a new style
         * @return {zebkit.Font} a font
         */
        this.restyle = function(style) {
            return new this.clazz(this.family, style, this.height + &quot;px&quot;);
        };
    }
]);
zebkit.package(&quot;util&quot;, function(pkg, Class) {
    /**
     * Number of different utilities methods and classes. The package has alternative to JS promise approach
     * that helps to make your code more linear looking nevertheless it can contain asynchronous calling.
     * One more useful class is zebkit Zson that allows developer to describe number of objects
     * and its properties value in JSON format.
     * @class zebkit.util
     * @access package
     */

    /**
     * Validate the specified value to be equal one of the given values
     * @param  {value} value a value to be validated
     * @param  {Object} [value]* a number of valid values to test against
     * @throws Error if the value doesn&#x27;t match any valid value
     * @for  zebkit.util
     * @method  $validateValue
     * @example
     *      // test if the alignment is equal one of the possible values
     *      // throws error otherwise
     *      zebkit.util.$validateValue(alignment, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot;);
     * @protected
     */
    pkg.$validateValue = function(value) {
        if (arguments.length &lt; 2) {
            throw new Error(&quot;Invalid arguments list. List of valid values is expected&quot;);
        }

        for(var i = 1; i &lt; arguments.length; i++) {
            if (arguments[i] === value) {
                return value;
            }
        }

        var values = Array.prototype.slice.call(arguments).slice(1);
        throw new Error(&quot;Invalid value &#x27;&quot; + value + &quot;&#x27;,the following values are expected: &quot; + values.join(&#x27;,&#x27;));
    };

    pkg.format = function(s, obj, ph) {
        if (arguments.length &lt; 3) {
            ph = &#x27;&#x27;;
        }

        var rg = /\$\{([0-9]+\s*,)?(.?,)?([a-zA-Z_][a-zA-Z0-9_]*)\}/g,
            r  = [],
            i  = 0,
            j  = 0,
            m  = null;

        while ((m = rg.exec(s)) !== null) {
            r[i++] = s.substring(j, m.index);

            j = m.index + m[0].length;

            var v  = obj[m[3]],
                mn = &quot;get&quot; + m[3][0].toUpperCase() + m[3].substring(1),
                f  = obj[mn];

            if (typeof f === &quot;function&quot;) {
                v = f.call(obj);
            }

            if (typeof m[1] !== &#x27;undefined&#x27;) {
                var ml  = parseInt(m[1].substring(0, m[1].length - 1).trim()),
                    ph2 = typeof m[2] !== &#x27;undefined&#x27; ? m[2].substring(0, m[2].length - 1) : ph;

                if (v === null || typeof v === &#x27;undefined&#x27;) {
                    ph2 = ph;
                    v = &quot;&quot;;
                } else {
                    v = &quot;&quot; + v;
                }

                for(var k = v.length; k &lt; ml; k++) {
                    v = ph2 + v;
                }
            }

            if (v === null || typeof v === &#x27;undefined&#x27;) {
                v = ph;
            }

            r[i++] = v;
        }

        if (i &gt; 0) {
            if (j &lt; s.length) {
                r[i++] = s.substring(j);
            }

            return pkg.format(r.join(&#x27;&#x27;), obj, ph);
        }

        return s;
    };

    /**
     * Load image or complete the given image loading.
     * @param  {String|Image} ph path or image to complete loading.
     * @param  {Boolean} [fireErr] flag to force or preserve error firing.
     * @return {zebkit.DoIt}
     * @method image
     * @for  zebkit.util
     */
    pkg.image = function(ph, fireErr) {
        if (arguments.length &lt; 2) {
            fireErr = false;
        }

        var d  = new zebkit.DoIt(),
            jn = d.join();

        zebkit.environment.loadImage(ph,
            function(img) {
                jn(img);
            },
            function(img, e) {
                if (fireErr === true) {
                    d.error(e);
                } else {
                    jn(img);
                }
            }
        );

        return d;
    };

    /**
     * Abstract event class.
     * @class zebkit.util.Event
     * @constructor
     */
    pkg.Event = Class([
        function $prototype() {
            /**
             * Source of an event
             * @attribute source
             * @type {Object}
             * @default null
             * @readOnly
             */
            this.source = null;
        }
    ]);

    /**
     *  Finds an item by xpath-like simplified expression applied to a tree-like structure.
     *  Passed tree-like structure doesn&#x27;t have a special requirements except every item of
     *  the structure have to define its kids by exposing &quot;kids&quot; field. The field is array
     *  of children elements:
     *
     *      // example of tree-like structure
     *      var treeLikeRoot = {
     *          value : &quot;Root&quot;,
     *          kids : [
     *              { value: &quot;Item 1&quot; },
     *              { value: &quot;Item 2&quot; }
     *          ]
     *      };
     *
     *      zebkit.util.findInTree(treeLikeRoot,
     *          &quot;/item1&quot;,
     *          function(foundElement) {
     *             ...
     *             // returning true means stop lookup
     *             return true;
     *          },
     *          function(item, fragment) {
     *              return item.value === fragment;
     *          });
     *
     *
     * The find method traverse the tree-like structure according to the xpath-like
     * expression. To understand if the given tree item confronts with the currently
     * traversing path fragment a special equality method has to be passed. The method
     * gets the traversing tree item and a string path fragment. The method has to
     * decide if the given tree item complies the specified path fragment.
     *
     * @param  {Object} root a tree root element. If the element has a children elements
     * the children have to be stored in &quot;kids&quot; field as an array.
     * @param  {String}  path a path-like expression. The path has to satisfy number of requirements:

        - has to start with &quot;.&quot; or &quot;/&quot; or &quot;//&quot; character
        - has to define path part after &quot;/&quot; or &quot;//&quot;
        - path part can be either &quot;*&quot; or a name
        - optionally an attribute or/and its value can be defined as &quot;[@&lt;attr_name&gt;=&lt;attr_value&gt;]&quot;
        - attribute value is optional and can be boolean (true or false), integer, null or string value
        - string attribute value has to be wrapped with single quotes

     *
     * For examples:

        - &quot;//*&quot; traverse all tree elements
        - &quot;//*[@a=10]&quot; traverse all tree elements that has an attribute &quot;a&quot; that equals 10
        - &quot;//*[@a]&quot; traverse all tree elements that has an attribute &quot;a&quot; defined
        - &quot;/Item1/Item2&quot; find an element by exact path
        - &quot;.//&quot; traverse all tree elements including the root element

     * @param  {Function} cb callback function that is called every time a new tree element
     * matches the given path fragment. The function has to return true if the tree look up
     * has to be interrupted
     * @param  {Function}  [eq]  an equality function. The function gets current evaluated tree element
     * and a path fragment against which the tree element has to be evaluated. It is expected the method
     * returns boolean value to say if the given passed tree element matches the path fragment. If the
     * parameter is not passed or null then default equality method is used. The default method expects
     * a tree item has &quot;path&quot; field that is matched with  given path fragment.
     * @method findInTree
     * @for  zebkit.util
     */

    var PATH_RE = /^[.]?(\/[\/]?)([^\[\/]+)\s*(\[\s*\@([a-zA-Z_][a-zA-Z0-9_\.]*)\s*(\=\s*[0-9]+|\=\s*true|\=\s*false|\=\s*null|\=\s*\&#x27;[^&#x27;]*\&#x27;)?\s*\])?/;
    pkg.findInTree = function(root, path, cb, eq, m) {
        if (root === null || typeof root === &#x27;undefined&#x27;) {
            throw new Error(&quot;Null tree root&quot;);
        }

        // if the method called first time
        if (arguments.length &lt; 5) {
            path = path.trim();
            if (path[0] === &#x27;#&#x27;) {
                path = &quot;//*[@id=&#x27;&quot; + path.substring(1).trim() + &quot;&#x27;]&quot;;
            } else if (path === &#x27;.&#x27;) {
                return cb(root);
            } else if (path[0] === &#x27;.&#x27; &amp;&amp; path[1] === &#x27;/&#x27;) { // means we have to include root in search
                root = { kids: [ root ] };
                path = path.substring(1);
            }
            m = null;
        }

        if (eq === null || arguments.length &lt; 4) {
            eq = function(n, fragment) { return n.path === fragment; };
        }

        if (typeof root.kids !== &#x27;undefined&#x27; &amp;&amp;   // a node has children
            root.kids        !== null        &amp;&amp;
            root.kids.length &gt; 0                )
        {
            //
            // m == null                      : means this is the first call of the method
            // m[0].length !== m.input.length : means this is terminal part of the path
            //
            if (m === null ||  m[0].length !== m.input.length) {
                m = path.match(PATH_RE);

                if (m === null) {
                    throw new Error(&quot;Cannot resolve path &#x27;&quot; + path + &quot;&#x27;&quot;);
                }

                // check if the matched path is not terminal
                if (m[0].length !== path.length) {
                    path = path.substring(m[0].length);  // cut found fragment from the path
                }

                // normalize attribute value
                if (typeof m[3] !== &#x27;undefined&#x27; &amp;&amp; typeof m[5] !== &#x27;undefined&#x27;) {
                    m[5] = m[5].substring(1).trim();

                    if (m[5][0] === &quot;&#x27;&quot;) {
                        m[5] = m[5].substring(1, m[5].length - 1);
                    } else if (m[5] === &quot;true&quot;) {
                        m[5] = true;
                    } else if (m[5] === &quot;false&quot;) {
                        m[5] = false;
                    } else if (m[5] === &quot;null&quot;) {
                        m[5] = null;
                    } else {
                        var vv = parseInt(m[5], 10);
                        if (isNaN(vv) === false) {
                            m[5] = vv;
                        }
                    }
                }
            }

            var isTerminal = m[0].length === m.input.length,
                pathDelim  = m[1],
                pathValue  = m[2];

            for (var i = 0; i &lt; root.kids.length ; i++) {
                var kid     = root.kids[i],
                    isMatch = false;
                                            // XOR
                if (pathValue === &quot;*&quot; || (eq(kid, pathValue) ? pathValue[0] !== &#x27;!&#x27; : pathValue[0] === &#x27;!&#x27;)) {
                    if (typeof m[3] !== &#x27;undefined&#x27;) { // has attributes
                        var attrName = m[4].trim();

                        // leave if attribute doesn&#x27;t match
                        if (typeof kid[attrName] !== &#x27;undefined&#x27; &amp;&amp; (typeof m[5] === &#x27;undefined&#x27; || kid[attrName] === m[5])) {
                            isMatch = true;
                        }
                    } else {
                        isMatch = true;
                    }
                }

                // if the kid match the path fragment and this is a terminal node
                // let callback know we found a node
                if (isMatch === true &amp;&amp; isTerminal === true &amp;&amp; cb(kid) === true) {
                    return true;
                }

                // if path delimiter indicates it is recursive children search or
                // we matched not a terminal node let dig deeper in tree
                if ((isMatch === true &amp;&amp; isTerminal === false) || pathDelim === &quot;//&quot;) {
                    if (pkg.findInTree(kid, path, cb, eq, m) === true) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /**
     * Interface that provides path search functionality for a tree-like structure.
     * @class  zebkit.util.PathSearch
     * @interface zebkit.util.PathSearch
     */
    pkg.PathSearch = zebkit.Interface([
        function $prototype() {
            /**
             * Find all children items with the passed path expression.
             * @param  {String} path path expression. Path expression is simplified form
             * of XPath-like expression. See  {{#crossLink &quot;zebkit&quot;}}sdsd{{/crossLink}} method to
             * get more details.
             *
             * @param {Function} [cb] function that is called every time a new children
             * component has been found. If callback has not been passed then the method
             * return first found item or null.
             * @method byPath
             * @return {Object} found children item or null if no children items were found
             */
            this.byPath = function(path, cb) {
                if (typeof this.$normalizePath !== &#x27;undefined&#x27;) {
                    path = this.$normalizePath(path);
                }

                if (arguments.length === 2) {
                    if (arguments[1] === null) {
                        var r = [];
                        pkg.findInTree(this, path, function(n) {
                            r.push(n);
                            return false;
                        }, typeof this.$matchPath !== &#x27;undefined&#x27; ? this.$matchPath
                                                                  : null);
                        return r;
                    } else {
                        pkg.findInTree(this, path, cb, typeof this.$matchPath !== &#x27;undefined&#x27; ? this.$matchPath
                                                                                              : null);
                    }
                } else {
                    var res = null;
                    pkg.findInTree(this, path, function(n) {
                        res = n;
                        return true;
                    }, typeof this.$matchPath !== &#x27;undefined&#x27; ? this.$matchPath : null);
                    return res;
                }
            };
        }
    ]);

    /**
     * RGB color class. This class represents a rgb color as JavaScript structure:

           // rgb color
           var rgb1 = new zebkit.util.rgb(100,200,100);

           // rgb with transparency
           var rgb2 = new zebkit.util.rgb(100,200,100, 0.6);

           // encoded as a string rgb color
           var rgb3 = new zebkit.util.rgb(&quot;rgb(100,100,200)&quot;);

           // hex rgb color
           var rgb3 = new zebkit.util.rgb(&quot;#CCDDFF&quot;);

     * @param  {Integer|String} r  the meaning of the argument depends on number of arguments the
     * constructor gets:
     *
     *   - If constructor gets only this argument the argument is considered as encoded rgb color:
     *      - **String**  means its hex encoded (&quot;#CCFFDD&quot;) or rgb (&quot;rgb(100,10,122)&quot;, &quot;rgba(100,33,33,0.6)&quot;) encoded color
     *      - **Integer** means this is number encoded rgb color
     *   - Otherwise the argument is an integer value that depicts a red intensity of rgb color
     *
     * encoded in string rgb color
     * @param  {Integer} [g]  green color intensity
     * @param  {Integer} [b] blue color intensity
     * @param  {Float}   [a] alpha color intensity
     * @constructor
     * @class zebkit.util.rgb
     */
    pkg.rgb = Class([
        function (r, g, b, a) {
            /**
             * Red color intensity
             * @attribute r
             * @type {Integer}
             * @readOnly
             */

            /**
             * Green color intensity
             * @attribute g
             * @type {Integer}
             * @readOnly
             */

            /**
             * Blue color intensity
             * @attribute b
             * @type {Integer}
             * @readOnly
             */

            /**
             * Alpha
             * @attribute a
             * @type {Float}
             * @readOnly
             */
            if (arguments.length === 1) {
                if (zebkit.isString(r)) {
                    this.s = r;
                    if (r[0] === &#x27;#&#x27;) {
                        r = parseInt(r.substring(1), 16);
                    } else {
                        if (r[0] === &#x27;r&#x27; &amp;&amp; r[1] === &#x27;g&#x27; &amp;&amp; r[2] === &#x27;b&#x27;) {
                            var i = r.indexOf(&#x27;(&#x27;, 3), p = r.substring(i + 1, r.indexOf(&#x27;)&#x27;, i + 1)).split(&quot;,&quot;);
                            this.r = parseInt(p[0].trim(), 10);
                            this.g = parseInt(p[1].trim(), 10);
                            this.b = parseInt(p[2].trim(), 10);
                            if (p.length &gt; 3) {
                                this.a = parseInt(p[3].trim(), 10);
                                this.isOpaque = (this.a === 1);
                            }
                            return;
                        }
                    }
                }
                this.r =  r &gt;&gt; 16;
                this.g = (r &gt;&gt; 8) &amp; 0xFF;
                this.b = (r &amp; 0xFF);
            } else {
                this.r = r;
                this.g = g;
                this.b = b;
                if (arguments.length &gt; 3) {
                    this.a = a;
                }
            }

            if (this.s === null) {
                this.s = (typeof this.a !== &quot;undefined&quot;) ? &#x27;rgba(&#x27; + this.r + &quot;,&quot; + this.g +  &quot;,&quot; +
                                                                     this.b + &quot;,&quot; + this.a + &quot;)&quot;
                                                         : &#x27;#&#x27; +
                                                           ((this.r &lt; 16) ? &quot;0&quot; + this.r.toString(16) : this.r.toString(16)) +
                                                           ((this.g &lt; 16) ? &quot;0&quot; + this.g.toString(16) : this.g.toString(16)) +
                                                           ((this.b &lt; 16) ? &quot;0&quot; + this.b.toString(16) : this.b.toString(16));
            }
        },

        function $prototype() {
            this.s = null;

            /**
             * Indicates if the color is opaque
             * @attribute isOpaque
             * @readOnly
             * @type {Boolean}
             */
            this.isOpaque = true;

            this.toString = function() {
                return this.s;
            };
        },

        function $clazz() {
            /**
             * Black color constant
             * @attribute black
             * @type {zebkit.util.rgb}
             * @static
             */

            this.black       = new this(0);
            this.white       = new this(0xFFFFFF);
            this.red         = new this(255,0,0);
            this.blue        = new this(0,0,255);
            this.green       = new this(0,255,0);
            this.gray        = new this(128,128,128);
            this.lightGray   = new this(211,211,211);
            this.darkGray    = new this(169,169,169);
            this.orange      = new this(255,165,0);
            this.yellow      = new this(255,255,0);
            this.pink        = new this(255,192,203);
            this.cyan        = new this(0,255,255);
            this.magenta     = new this(255,0,255);
            this.darkBlue    = new this(0, 0, 140);
            this.transparent = new this(0, 0, 0, 0.0);

            this.mergeable = false;
        }
    ]);

    /**
     * Compute intersection of the two given rectangular areas
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @param  {Object}  r  an object to store result
     *
     *      { x: {Integer}, y:{Integer}, width:{Integer}, height:{Integer} }
     *
     * @method intersection
     * @for zebkit.util
     */
    pkg.intersection = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
        r.x = x1 &gt; x2 ? x1 : x2;
        r.width = Math.min(x1 + w1, x2 + w2) - r.x;
        r.y = y1 &gt; y2 ? y1 : y2;
        r.height = Math.min(y1 + h1, y2 + h2) - r.y;
    };

    /**
     * Test if two rectangular areas have intersection
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @return {Boolean} true if the given two rectangular areas intersect
     *
     * @method isIntersect
     * @for zebkit.util
     */
    pkg.isIntersect = function(x1,y1,w1,h1,x2,y2,w2,h2){
        return (Math.min(x1 + w1, x2 + w2) - (x1 &gt; x2 ? x1 : x2)) &gt; 0 &amp;&amp;
               (Math.min(y1 + h1, y2 + h2) - (y1 &gt; y2 ? y1 : y2)) &gt; 0;
    };

    /**
     * Unite two rectangular areas to one rectangular area.
     * @param  {Integer} x1 a x coordinate of the first rectangular area
     * @param  {Integer} y1 a y coordinate of the first rectangular area
     * @param  {Integer} w1 a width of the first rectangular area
     * @param  {Integer} h1 a height of the first rectangular area
     * @param  {Integer} x2 a x coordinate of the first rectangular area
     * @param  {Integer} y2 a y coordinate of the first rectangular area
     * @param  {Integer} w2 a width of the first rectangular area
     * @param  {Integer} h2 a height of the first rectangular area
     * @param  {Object}  r  an object to store result
     *
     *      { x: {Integer}, y:{Integer}, width:{Integer}, height:{Integer} }
     *
     * @method unite
     * @for zebkit.util
     */
    pkg.unite = function(x1,y1,w1,h1,x2,y2,w2,h2,r){
        r.x = x1 &lt; x2 ? x1 : x2;
        r.y = y1 &lt; y2 ? y1 : y2;
        r.width  = Math.max(x1 + w1, x2 + w2) - r.x;
        r.height = Math.max(y1 + h1, y2 + h2) - r.y;
    };

    var letterRE = /[A-Za-z]/;
    pkg.isLetter = function (ch) {
        if (ch.length !== 1) {
            throw new Error(&quot;Incorrect character&quot;);
        }
        return letterRE.test(ch);
    };

    /**
     * This method allows to declare a listeners container class for the given
     * dedicated event types.

        // create listener container to keep three different events
        // handlers
        var MyListenerContainerClass = zebkit.util.ListenersClass(&quot;event1&quot;,
                                                                  &quot;event2&quot;,
                                                                  &quot;event3&quot;);

        // instantiate listener class container
        var listeners = new MyListenerContainerClass();

        // add &quot;event1&quot; listener
        listeners.add(function event1() {
            ...
        });

        // add &quot;event2&quot; listener
        listeners.add(function event2() {
           ...
        });

        // add listener for both event1 and event2 events
        listeners.add(function() {
           ...
        });

        // and firing event1 to registered handlers
        listeners.event1(...);

        // and firing event2 to registered handlers
        listeners.event2(...);

     * @for zebkit.util
     * @method ListenersClass
     * @param {String} [events]* events types the listeners container has to support
     * @return {zebkit.util.Listener} a listener container class
     */
    var $NewListener = function() {
        var clazz = function() {};
        clazz.eventNames = arguments.length === 0 ? [ &quot;fired&quot; ]
                                                  : Array.prototype.slice.call(arguments);

        clazz.ListenersClass = function() {
            var args = this.eventNames.slice(); // clone
            for(var i = 0; i &lt; arguments.length; i++) {
                args.push(arguments[i]);
            }
            return $NewListener.apply(this, args);
        };

        if (clazz.eventNames.length === 1) {
            var $ename = clazz.eventNames[0];

            clazz.prototype.v = null;

            clazz.prototype.add = function() {
                var ctx = this,
                    l   = arguments[arguments.length - 1]; // last arguments are handler(s)

                if (typeof l !== &#x27;function&#x27;) {
                    ctx = l;
                    l   = l[$ename];

                    if (typeof l !== &quot;function&quot;) {
                        return null;
                    }
                }

                if (arguments.length &gt; 1 &amp;&amp; arguments[0] !== $ename) {
                    throw new Error(&quot;Unknown event type :&quot; + $ename);
                }

                if (this.v === null) {
                    this.v = [];
                }

                this.v.push(ctx, l);
                return l;
            };

            clazz.prototype.remove = function(l) {
                if (this.v !== null) {
                    if (arguments.length === 0) {
                        // remove all
                        this.v.length = 0;
                    } else {
                        var name = arguments.length &gt; 1 || zebkit.isString(arguments[0]) ? arguments[0]
                                                                                         : null,
                            fn   = arguments.length &gt; 1 ? arguments[1]
                                                        : (name === null ? arguments[0] : null),
                            i    = 0;

                        if (name !== null &amp;&amp; name !== $ename) {
                            throw new Error(&quot;Unknown event type :&quot; + name);
                        }

                        if (fn === null) {
                            this.v.length = 0;
                        } else {
                            while ((i = this.v.indexOf(fn)) &gt;= 0) {
                                if (i % 2 &gt; 0) {
                                    i--;
                                }
                                this.v.splice(i, 2);
                            }
                        }
                    }
                }
            };

            clazz.prototype.hasHandler = function(l) {
                if (zebkit.isString(l)) {
                    return this.v !== null &amp;&amp; l === $ename &amp;&amp; this.v.length &gt; 0;
                } else {
                    return this.v.length &gt; 0 &amp;&amp; this.v.indexOf(l) &gt;= 0;
                }
            };

            clazz.prototype[$ename] = function() {
                if (this.v !== null) {
                    for(var i = 0; i &lt; this.v.length; i +=2 ) {
                        if (this.v[i + 1].apply(this.v[i], arguments) === true) {
                            return true;
                        }
                    }
                }
                return false;
            };

            clazz.prototype.hasEvent = function(nm) {
                return nm === $ename;
            };
        } else {
            var names = {};
            for(var i = 0; i &lt; clazz.eventNames.length; i++) {
                names[clazz.eventNames[i]] = true;
            }

            clazz.prototype.$methods = null;

            clazz.prototype.add = function(l) {
                if (this.$methods === null) {
                    this.$methods = {};
                }

                var n   = null,
                    k   = null,
                    nms = typeof this.$names !== &#x27;undefined&#x27; ? this.$names : names;

                if (arguments.length &gt; 1) {
                    n = arguments[0];
                    l = arguments[arguments.length - 1]; // last arguments are handler(s)
                }

                if (typeof l === &#x27;function&#x27;) {
                    if (n !== null &amp;&amp; nms.hasOwnProperty(n) === false) {
                        throw new Error(&quot;Unknown event type &quot; + n);
                    }

                    if (n === null) {
                        for(k in nms) {
                            if (this.$methods.hasOwnProperty(k) === false) {
                                this.$methods[k] = [];
                            }
                            this.$methods[k].push(this, l);
                        }
                    } else {
                        if (this.$methods.hasOwnProperty(n) === false) {
                            this.$methods[n] = [];
                        }
                        this.$methods[n].push(this, l);
                    }
                } else {
                    var b = false;
                    for (k in nms) {
                        if (typeof l[k] === &quot;function&quot;) {
                            b = true;
                            if (this.$methods.hasOwnProperty(k) === false) {
                                this.$methods[k] = [];
                            }
                            this.$methods[k].push(l, l[k]);
                        }
                    }

                    if (b === false) {
                        return null;
                    }
                }
                return l;
            };

            clazz.prototype.hasHandler = function(l) {
                if (zebkit.isString(l)) {
                    return this.$methods !== null &amp;&amp;
                           this.$methods.hasOwnProperty(l) &amp;&amp;
                           this.$methods[l].length &gt; 0;
                } else {
                    for(var k in this.$methods) {
                        var v = this.$methods[k];
                        if (v.indexOf(l) &gt;= 0) {
                            return true;
                        }
                    }
                    return false;
                }
            };

            clazz.prototype.addEvents = function() {
                if (typeof this.$names === &#x27;undefined&#x27;) {
                    this.$names = {};
                    for (var k in names) {
                        this.$names[k] = names[k];
                    }
                }

                for(var i = 0; i &lt; arguments.length; i++) {
                    var name = arguments[i];

                    if (name === null || typeof name === &#x27;undefined&#x27; || typeof this[name] !== &#x27;undefined&#x27;) {
                        throw new Error(&quot;Invalid &quot; + name + &quot; (event name)&quot;);
                    }

                    this[name] = (function(name) {
                        return function() {
                            if (this.$methods !== null) {
                                if (this.$methods.hasOwnProperty(name)) {
                                    var c = this.$methods[name];
                                    for(var i = 0; i &lt; c.length; i += 2) {
                                        if (c[i + 1].apply(c[i], arguments) === true) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            return false;
                        };
                    })(name);

                    this.$names[name] = true;
                }
            };

            // populate methods that has to be called to send appropriate events to
            // registered listeners
            clazz.prototype.addEvents.apply(clazz.prototype, clazz.eventNames);

            clazz.prototype.remove = function() {
                if (this.$methods !== null) {
                    var k = null;
                    if (arguments.length === 0) {
                        for(k in this.$methods) {
                            if (this.$methods.hasOwnProperty(k)) {
                                this.$methods[k].length = 0;
                            }
                        }
                        this.$methods = {};
                    } else {
                        var name = arguments.length &gt; 1 || zebkit.isString(arguments[0]) ? arguments[0]
                                                                                         : null,
                            fn   = arguments.length &gt; 1 ? arguments[1]
                                                        : (name === null ? arguments[0] : null),
                            i    = 0,
                            v    = null;

                        if (name !== null) {
                            if (this.$methods.hasOwnProperty(name)) {
                                if (fn === null) {
                                    this.$methods[name].length = 0;
                                    delete this.$methods[name];
                                } else {
                                    v = this.$methods[name];
                                    while ((i = v.indexOf(fn)) &gt;= 0) {
                                        if (i % 2 &gt; 0) {
                                            i--;
                                        }
                                        v.splice(i, 2);
                                    }

                                    if (v.length === 0) {
                                        delete this.$methods[name];
                                    }
                                }
                            }
                        } else {
                            for (k in this.$methods) {
                                v = this.$methods[k];
                                while ((i = v.indexOf(fn)) &gt;= 0) {
                                    if (i % 2 &gt; 0) {
                                        i--;
                                    }
                                    v.splice(i, 2);
                                }

                                if (v.length === 0) {
                                    delete this.$methods[k];
                                }
                            }
                        }
                    }
                }
            };

            clazz.prototype.hasEvent = function(nm) {
                if (typeof this.$names !== &#x27;undefined&#x27;) {
                    return this.$names.hasOwnProperty(nm);
                } else {
                    return names.hasOwnProperty(nm);
                }
            };
        }


        return clazz;
    };

    /**
     * Listeners container class that can be handy to store number of listeners
     * for one type of event.
     * @param {String} [eventName] an event name the listeners container has been
     * created. By default &quot;fired&quot; is default event name. Event name is used to fire
     * the given event to a listener container.
     * @constructor
     * @class zebkit.util.Listeners
     * @example
     *
     *      // create container with a default event name
     *      var  container = new Listeners();
     *
     *      // register a listener
     *      var  listener = container.add(function(param1, param2) {
     *          // handle fired event
     *      });
     *
     *      ...
     *      // fire event
     *      container.fired(1, 2, 3);
     *
     *      // remove listener
     *      container.remove(listener);
     *
     * @extends zebkit.util.Listener
     */


    /**
     * Add listener
     * @param {Function|Object} l a listener method or object.
     * @return {Function} a listener that has been registered in the container. The result should
     * be used to un-register the listener
     * @method  add
     */


    /**
     * Remove listener or all registered listeners from the container
     * @param {Function} [l] a listener to be removed. If the argument has not been specified
     * all registered in the container listeners will be removed
     * @method  remove
     */
    pkg.Listeners = $NewListener();


    pkg.ListenersClass = $NewListener;


    /**
     * Useful class to track a virtual cursor position in a structure that has dedicated number of lines
     * where every line has a number of elements. The structure metric has to be described by providing
     * an instance of zebkit.util.Position.Metric interface that discovers how many lines the structure
     * has and how many elements every line includes.
     * @param {zebkit.util.Position.Metric} m a position metric
     * @constructor
     * @class zebkit.util.Position
     */

    /**
     * Fire when a virtual cursor position has been updated
     *
     *      position.on(function(src, prevOffset, prevLine, prevCol) {
     *          ...
     *      });
     *
     * @event posChanged
     * @param {zebkit.util.Position} src an object that triggers the event
     * @param {Integer} prevOffest a previous virtual cursor offset
     * @param {Integer} prevLine a previous virtual cursor line
     * @param {Integer} prevCol a previous virtual cursor column in the previous line
     */
    pkg.Position = Class(zebkit.EventProducer, [
        function(pi){
            this._ = new this.clazz.Listeners();

            /**
             * Shows if the position object is in valid state.
             * @private
             * @type {Boolean}
             * @attribute isValid
             */
            this.isValid = false;

            /**
             * Current virtual cursor line position
             * @attribute currentLine
             * @type {Integer}
             * @readOnly
             */

            /**
             * Current virtual cursor column position
             * @attribute currentCol
             * @type {Integer}
             * @readOnly
             */

            /**
             * Current virtual cursor offset
             * @attribute offset
             * @type {Integer}
             * @readOnly
             */

            this.currentLine = this.currentCol = this.offset = 0;
            this.setMetric(pi);
        },

        function $clazz() {
            this.Listeners = pkg.ListenersClass(&quot;posChanged&quot;);

            /**
             * Position metric interface. This interface is designed for describing
             * a navigational structure that consists on number of lines where
             * every line consists of number of elements
             * @class zebkit.util.Position.Metric
             * @interface zebkit.util.Position.Metric
             */

            /**
             * Get number of lines to navigate through
             * @return {Integer} a number of lines
             * @method  getLines
             */

             /**
              * Get a number of elements in the given line
              * @param {Integer} l a line index
              * @return {Integer} a number of elements in a line
              * @method  getLineSize
              */

             /**
              * Get a maximal element index (a last element of a last line)
              * @return {Integer} a maximal element index
              * @method  getMaxOffset
              */

            this.Metric = zebkit.Interface([
                &quot;abstract&quot;,
                    function getLines()     {

                    },

                    function getLineSize()  {

                    },

                    function getMaxOffset() {

                    }
            ]);
        },

        /**
         *  @for zebkit.util.Position
         */
        function $prototype() {
            /**
             * Set the specified virtual cursor offsest
             * @param {Integer} o an offset, pass null to set position to indefinite state.
             *
             *   - if offset is null than offset will set to -1 (undefined state)
             *   - if offset is less than zero than offset will be set to zero
             *   - if offset is greater or equal to maximal possible offset it will be set to maximal possible offset
             *
             *  @return {Integer} an offset that has been set
             * @method setOffset
             */
            this.setOffset = function(o){
                if (o &lt; 0) {
                    o = 0;
                } else if (o === null) {
                    o = -1;
                } else {
                    var max = this.metrics.getMaxOffset();
                    if (o &gt;= max) {
                        o = max;
                    }
                }

                if (o !== this.offset){
                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol,
                        p          = this.getPointByOffset(o);

                    this.offset = o;
                    if (p !== null){
                        this.currentLine = p[0];
                        this.currentCol  = p[1];
                    } else {
                        this.currentLine = this.currentCol = -1;
                    }
                    this.isValid = true;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }

                return o;
            };

            /**
             * Seek virtual cursor offset with the given shift
             * @param {Integer} off a shift
             * @return {Integer} an offset that has been set
             * @method seek
             */
            this.seek = function(off) {
                return this.setOffset(this.offset + off);
            };

            /**
             * Set the virtual cursor line and the given column in the line
             * @param {Integer} r a line
             * @param {Integer} c a column in the line
             * @method setRowCol
             */
            this.setRowCol = function(r, c) {
                if (r !== this.currentLine || c !== this.currentCol){
                    var prevOffset = this.offset,
                        prevLine = this.currentLine,
                        prevCol = this.currentCol;

                    this.offset = this.getOffsetByPoint(r, c);
                    this.currentLine = r;
                    this.currentCol = c;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }
            };

            /**
             * Special method to inform the position object that its state has to be adjusted
             * because of the given portion of data had been inserted .
             * @param  {Integer} off  an offset the insertion has happened
             * @param  {Integer} size a length of the inserted portion
             * @protected
             * @method  removed
             */
            this.inserted = function(off, size) {
                if (this.offset &gt;= 0 &amp;&amp; off &lt;= this.offset){
                    this.isValid = false;
                    this.setOffset(this.offset + size);
                }
            };

            /**
             * Special method to inform the position object that its state has to be adjusted
             * because of the given portion of data had been removed.
             * @param  {Integer} off  an offset the removal has happened
             * @param  {Integer} size a length of the removed portion
             * @protected
             * @method  removed
             */
            this.removed = function (off, size){
                if (this.offset &gt;= 0 &amp;&amp; this.offset &gt;= off){
                    this.isValid = false;
                    this.setOffset(this.offset &gt;= (off + size) ? this.offset - size
                                                               : off);
                }
            };

            /**
             * Calculate a line and line column by the given offset.
             * @param  {Integer} off an offset
             * @return {Array} an array that contains a line as the first
             * element and a column in the line as the second element.
             * @method getPointByOffset
             */
            this.getPointByOffset = function(off){
                if (off &gt;= 0) {
                    var m = this.metrics, max = m.getMaxOffset();
                    if (off &gt; max) {
                        throw new Error(&quot;Out of bounds:&quot; + off);
                    }

                    if (max === 0) {
                        return [(m.getLines() &gt; 0 ? 0 : -1), 0];
                    }

                    if (off === 0) {
                        return [0, 0];
                    }

                    var d = 0, sl = 0, so = 0;
                    if (this.isValid === true &amp;&amp; this.offset !== -1) {
                        sl = this.currentLine;
                        so = this.offset - this.currentCol;
                        if (off &gt; this.offset) {
                            d = 1;
                        } else {
                            if (off &lt; this.offset) {
                                d = -1;
                            } else {
                                return [sl, this.currentCol];
                            }
                        }
                    } else {
                        d = (Math.floor(max / off) === 0) ? -1 : 1;
                        if (d &lt; 0) {
                            sl = m.getLines() - 1;
                            so = max - m.getLineSize(sl);
                        }
                    }

                    for(; sl &lt; m.getLines() &amp;&amp; sl &gt;= 0; sl += d){
                        var ls = m.getLineSize(sl);
                        if (off &gt;= so &amp;&amp; off &lt; so + ls) {
                            return [sl, off - so];
                        }
                        so += d &gt; 0 ? ls : -m.getLineSize(sl - 1);
                    }
                }
                return null;
            };

            /**
             * Calculate an offset by the given line and column in the line
             * @param  {Integer} row a line
             * @param  {Integer} col a column in the line
             * @return {Integer} an offset
             * @method getOffsetByPoint
             */
            this.getOffsetByPoint = function (row, col){
                var startOffset = 0, startLine = 0, m = this.metrics, i = 0;

                if (row &gt;= m.getLines()) {
                    throw new RangeError(row);
                }

                if (col &gt;= m.getLineSize(row)) {
                    throw new RangeError(col);
                }

                if (this.isValid === true &amp;&amp; this.offset !==  -1) {
                    startOffset = this.offset - this.currentCol;
                    startLine = this.currentLine;
                }

                if (startLine &lt;= row) {
                    for(i = startLine;i &lt; row; i++) {
                        startOffset += m.getLineSize(i);
                    }
                } else {
                    for(i = startLine - 1;i &gt;= row; i--) {
                        startOffset -= m.getLineSize(i);
                    }
                }
                return startOffset + col;
            };

            /**
             * Seek virtual cursor to the next position. How the method has to seek to the next position
             * has to be denoted by one of the following constants:

        - **&quot;begin&quot;** seek cursor to the begin of the current line
        - **&quot;end&quot;** seek cursor to the end of the current line
        - **&quot;up&quot;** seek cursor one line up
        - **&quot;down&quot;** seek cursor one line down

             * If the current virtual position is not known (-1) the method always sets
             * it to the first line, the first column in the line (offset is zero).
             * @param  {Integer} t   an action the seek has to be done
             * @param  {Integer} num number of seek actions
             * @method seekLineTo
             */
            this.seekLineTo = function(t,num){
                if (this.offset &lt; 0){
                    this.setOffset(0);
                } else {
                    if (arguments.length === 1) {
                        num = 1;
                    }

                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol,
                        maxCol     = 0,
                        i          = 0;

                    switch(t) {
                        case &quot;begin&quot;:
                            if (this.currentCol &gt; 0){
                                this.offset -= this.currentCol;
                                this.currentCol = 0;
                            } break;
                        case &quot;end&quot;:
                            maxCol = this.metrics.getLineSize(this.currentLine);
                            if (this.currentCol &lt; (maxCol - 1)) {
                                this.offset += (maxCol - this.currentCol - 1);
                                this.currentCol = maxCol - 1;
                            } break;
                        case &quot;up&quot;:
                            if (this.currentLine &gt; 0) {
                                this.offset -= (this.currentCol + 1);
                                this.currentLine--;
                                for(i = 0; this.currentLine &gt; 0 &amp;&amp; i &lt; (num - 1); i++, this.currentLine--) {
                                    this.offset -= this.metrics.getLineSize(this.currentLine);
                                }

                                maxCol = this.metrics.getLineSize(this.currentLine);
                                if (this.currentCol &lt; maxCol) {
                                    this.offset -= (maxCol - this.currentCol - 1);
                                } else {
                                    this.currentCol = maxCol - 1;
                                }
                            } break;
                        case &quot;down&quot;:
                            if (this.currentLine &lt; (this.metrics.getLines() - 1)) {
                                this.offset += (this.metrics.getLineSize(this.currentLine) - this.currentCol);
                                this.currentLine++;
                                var size = this.metrics.getLines() - 1;
                                for (i = 0; this.currentLine &lt; size &amp;&amp; i &lt; (num - 1); i++ ,this.currentLine++ ) {
                                    this.offset += this.metrics.getLineSize(this.currentLine);
                                }

                                maxCol = this.metrics.getLineSize(this.currentLine);
                                if (this.currentCol &lt; maxCol) {
                                    this.offset += this.currentCol;
                                } else {
                                    this.currentCol = maxCol - 1;
                                    this.offset += this.currentCol;
                                }
                            } break;
                        default: throw new Error(&quot;&quot; + t);
                    }

                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }
            };

            /**
             * Set position metric. Metric describes how many lines
             * and elements in these line the virtual cursor can be navigated
             * @param {zebkit.util.Position.Metric} p a position metric
             * @method setMetric
             */
            this.setMetric = function (p){
                if (p === null || typeof p === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Null metric&quot;);
                }

                if (p !== this.metrics){
                    this.metrics = p;
                    this.setOffset(null);
                }
            };
        }
    ]);

    /**
     * Single column position implementation. More simple and more fast implementation of
     * position class for the cases when only one column is possible.
     * @param {zebkit.util.Position.Metric} m a position metric
     * @constructor
     * @class zebkit.util.SingleColPosition
     * @extends zebkit.util.Position
     */
    pkg.SingleColPosition = Class(pkg.Position, [
        function $prototype() {
            this.setRowCol = function(r,c) {
                this.setOffset(r);
            };

            this.setOffset = function(o) {
                if (o &lt; 0) { o = 0;
                } else if (o === null) {
                    o = -1;
                } else {
                    var max = this.metrics.getMaxOffset();
                    if (o &gt;= max) {
                        o = max;
                    }
                }


                if (o !== this.offset) {
                    var prevOffset = this.offset,
                        prevLine   = this.currentLine,
                        prevCol    = this.currentCol;

                    this.currentLine = this.offset = o;
                    this.isValid = true;
                    this._.posChanged(this, prevOffset, prevLine, prevCol);
                }

                return o;
            };

            this.seekLineTo = function(t, num){
                if (this.offset &lt; 0){
                    this.setOffset(0);
                } else {
                    if (arguments.length === 1) {
                        num = 1;
                    }

                    switch(t) {
                        case &quot;begin&quot;:
                        case &quot;end&quot;: break;
                        case &quot;up&quot;:
                            if (this.offset &gt; 0) {
                                this.setOffset(this.offset - num);
                            } break;
                        case &quot;down&quot;:
                            if (this.offset &lt; (this.metrics.getLines() - 1)){
                                this.setOffset(this.offset + num);
                            } break;
                        default: throw new Error(&quot;&quot; + t);
                    }
                }
            };
        }
    ]);

    /**
     * Task set is light-weight class to host number of callbacks methods that are called within a context of one JS interval
     * method execution. The class manages special tasks queue to run it one by one as soon as a dedicated interval for the
     * given task is elapsed

        var tasks = zebkit.util.TasksSet();

        tasks.run(function(t) {
            // task1 body
            ...
            if (condition) {
                t.shutdown();
            }
        }, 1000, 200);

        tasks.run(function(t) {
            // task2 body
            ...
            if (condition) {
                t.shutdown();
            }
        }, 2000, 300);

     * @constructor
     * @param  {Integer} [maxTasks] maximal possible number of active tasks in queue.
     * @class zebkit.util.TasksSet
     */
    pkg.TasksSet = Class([
        function(c) {
            this.tasks = Array(arguments.length &gt; 0 ? c : 5);

            // pre-fill tasks pool
            for(var i = 0; i &lt; this.tasks.length; i++) {
                this.tasks[i] = new this.clazz.Task(this);
            }
        },

        function $clazz() {
            /**
             * Task class
             * @class zebkit.util.TasksSet.Task
             * @for zebkit.util.TasksSet.Task
             * @param {zebkit.util.TasksSet} tasksSet a reference to tasks set that manages the task
             * @constructor
             */
            this.Task = Class([
                function(set) {
                    /**
                     * Reference to a tasks set that owns the task
                     * @type {zebkit.util.TasksSet}
                     * @attribute taskSet
                     * @private
                     * @readOnly
                     */
                    this.taskSet = set;

                    /**
                     * Indicates if the task is executed (active)
                     * @type {Boolean}
                     * @attribute isStarted
                     * @readOnly
                     */
                    this.isStarted = false;
                },

                function $prototype() {
                    this.task = null;
                    this.ri = this.si  = 0;

                    /**
                     * Shutdown the given task.
                     * @return {Boolean} true if the task has been stopped
                     * @method shutdown
                     */
                    this.shutdown = function() {
                        return this.taskSet.shutdown(this);
                    };

                    /**
                     * Pause the given task.
                     * @return {Boolean} true if the task has been paused
                     * @method pause
                     */
                    this.pause = function() {
                        if (this.task === null) {
                            throw new Error(&quot;Stopped task cannot be paused&quot;);
                        }

                        if (this.isStarted === true) {
                            this.isStarted = false;
                            return true;
                        }
                        return false;
                    };

                    /**
                     * Resume the given task
                     * @param {Integer} [startIn] a time in milliseconds to resume the task
                     * @return {Boolean} true if the task has been resumed
                     * @method resume
                     */
                    this.resume = function(t) {
                        if (this.task === null) {
                            throw new Error(&quot;Stopped task cannot be paused&quot;);
                        }

                        this.si = arguments.length &gt; 0 ? t : 0;
                        if (this.isStarted === true) {
                            return false;
                        }
                        this.isStarted = true;
                        return true;
                    };
                }
            ]);
        },

        /**
         *  @for  zebkit.util.TasksSet
         */
        function $prototype() {
            /**
             * Interval
             * @attribute quantum
             * @private
             * @type {Number}
             * @default 40
             */
            this.quantum = 40;

            /**
             * pid of executed JS interval method callback
             * @attribute pid
             * @private
             * @type {Number}
             * @default -1
             */
            this.pid = -1;

            /**
             * Number of run in the set tasks
             * @attribute count
             * @private
             * @type {Number}
             * @default 0
             */
            this.count = 0;

            /**
             * Shut down all active at the given moment tasks
             * body and the given context.
             * @method shutdownAll
             */
            this.shutdownAll = function() {
                for(var i = 0; i &lt; this.tasks.length; i++) {
                    this.shutdown(this.tasks[i]);
                }
            };

            /**
             * Shutdown the given task
             * @param  {zebkit.util.TasksSet.Task} t a task
             * @return {Boolean}  true if the task has been stopped, false if the task has not been started
             * to be stopped
             * @protected
             * @method shutdown
             */
            this.shutdown = function(t) {
                if (t.task !== null) {
                    this.count--;
                    t.task = null;
                    t.isStarted = false;
                    t.ri = t.si = 0;
                    return true;
                }

                if (this.count === 0 &amp;&amp; this.pid  &gt;= 0) {
                    zebkit.environment.clearInterval(this.pid);
                    this.pid = -1;
                }

                return false;
            };

            /**
             * Take a free task from tasks pool and run it once in the specified period of time.
             * @param  {Function|Object} f a task function that has to be executed. The task method gets the task
             * context as its argument. You can pass an object as the argument if the object has &quot;run&quot; method
             * implemented. In this cases &quot;run&quot; method will be used as the task body.
             * @param  {Integer} [startIn]  time in milliseconds the task has to be executed in
             * @method runOnce
             */
            this.runOnce = function(f, startIn) {
                this.run(f, startIn, -1);
            };

            /**
             * Take a free task from pool and run it with the specified body and the given context.
             * @param  {Function|Object} f a task function that has to be executed. The task method gets the task
             * context as its argument. You can pass an object as the argument if the object has &quot;run&quot; method
             * implemented. In this cases &quot;run&quot; method will be used as the task body.
             * @param {Integer} [si]  time in milliseconds the task has to be executed
             * @param {Integer} [ri]  the time in milliseconds the task has to be periodically repeated
             * @return {zebkit.util.Task} an allocated task
             * @example

        var tasks = new zebkit.util.TasksSet();

        // execute task
        var task = tasks.run(function (t) {
            // do something
            ...
            // complete task if necessary
            t.shutdown();
        }, 100, 300);

        // pause task
        task.pause(1000, 2000);

        ...
        // resume task in a second
        task.resume(1000);

             * @example

        var tasks = new zebkit.util.TasksSet();

        var a = new zebkit.Dummy([
            function run() {
                // task body
                ...
            }
        ]);

        // execute task
        var task = tasks.runOnce(a);

             * @method run
             */
            this.run = function(f, si, ri){
                if (f === null || typeof f === &#x27;undefined&#x27;) {
                    throw new Error(&quot;&quot; + f);
                }

                var $this = this;
                function dispatcher() {
                    var c = 0;
                    for(var i = 0; i &lt; $this.tasks.length; i++) {
                        var t = $this.tasks[i];

                        // count paused or run tasks
                        if (t.task !== null) {  // means task has been shutdown
                            c++;
                        }

                        if (t.isStarted === true) {
                            if (t.si &lt;= 0) {
                                try {
                                    if (typeof t.task.run !== &#x27;undefined&#x27;) {
                                        t.task.run(t);
                                    } else {
                                        t.task(t);
                                    }

                                    if (t.ri &lt; 0) {
                                        t.shutdown();
                                    }
                                } catch(e) {
                                    zebkit.dumpError(e);
                                }

                                t.si += t.ri;
                            } else {
                                t.si -= $this.quantum;
                            }
                        }
                    }

                    if (c === 0 &amp;&amp; $this.pid &gt;= 0) {
                        zebkit.environment.clearInterval($this.pid);
                        $this.pid = -1;
                    }
                }

                // find free and return free task
                for(var i = 0; i &lt; this.tasks.length; i++) {
                    var j = (i + this.count) % this.tasks.length,
                        t = this.tasks[j];

                    if (t.task === null) {
                        // initialize internal variables start in and repeat in
                        // arguments
                        t.si = (arguments.length &gt; 1) ? si : 0;
                        t.ri = (arguments.length &gt; 2) ? ri : -1;
                        t.isStarted = true;
                        t.task = f;
                        this.count++;

                        if (this.count &gt; 0 &amp;&amp; this.pid &lt; 0) {
                            this.pid = zebkit.environment.setInterval(dispatcher, this.quantum);
                        }

                        return t;
                    }
                }

                throw new Error(&quot;Out of active tasks limit (&quot; +  this.tasks.length + &quot;)&quot;);
            };
        }
    ]);

    /**
     * Predefined default tasks set.
     * @attribute tasksSet
     * @type {zebkit.util.TasksSet}
     * @for zebkit.util
     */
    pkg.tasksSet = new pkg.TasksSet(7);


    pkg.Fireable = zebkit.Interface();

    /**
     * JSON object loader class is a handy way to load hierarchy of objects encoded with
     * JSON format. The class supports standard JSON types plus it extends JSON with a number of
     * features that helps to make object creation more flexible. Zson allows developers
     * to describe creation of any type of object. For instance if you have a class &quot;ABC&quot; with
     * properties &quot;prop1&quot;, &quot;prop2&quot;, &quot;prop3&quot; you can use instance of the class as a value of
     * a JSON property as follow:
     *
     *      { &quot;instanceOfABC&quot;: {
     *              &quot;@ABC&quot;  : [],
     *              &quot;prop1&quot; : &quot;property 1 value&quot;,
     *              &quot;prop2&quot; : true,
     *              &quot;prop3&quot; : 200
     *          }
     *      }
     *
     *  And than:
     *
     *       // load JSON mentioned above
     *       zebkit.util.Zson.then(&quot;abc.json&quot;, function(zson) {
     *           zson.get(&quot;instanceOfABC&quot;);
     *       });
     *
     *  Features the JSON zson supports are listed below:
     *
     *    - **Access to hierarchical properties** You can use dot notation to get a property value. For
     *    instance:
     *
     *     { &quot;a&quot; : {
     *            &quot;b&quot; : {
     *                &quot;c&quot; : 100
     *            }
     *         }
     *     }
     *
     *     zebkit.util.Zson.then(&quot;abc.json&quot;, function(zson) {
     *         zson.get(&quot;a.b.c&quot;); // 100
     *     });
     *
     *
     *    - **Property reference** Every string JSON value that starts from &quot;@&quot; considers as reference to
     *    another property value in the given JSON.
     *
     *     {  &quot;a&quot; : 100,
     *        &quot;b&quot; : {
     *            &quot;c&quot; : &quot;%{a.b}&quot;
     *        }
     *     }
     *
     *    here property &quot;b.c&quot; equals to 100 since it refers to  property &quot;a.b&quot;
     *     *
     *    - **Class instantiation**  Property can be easily initialized with an instantiation of required class. JSON
     *    zson considers all properties whose name starts from &quot;@&quot; character as a class name that has to be instantiated:
     *
     *     {  &quot;date&quot;: {
     *           { &quot;@Date&quot; : [] }
     *         }
     *     }
     *
     *   Here property &quot;date&quot; is set to instance of JS Date class.
     *
     *   - **Factory classes** JSON zson follows special pattern to describe special type of property whose value
     *   is re-instantiated every time the property is requested. Definition of the property value is the same
     *   to class instantiation, but the name of class has to prefixed with &quot;*&quot; character:
     *
     *
     *     {  &quot;date&quot; : {
     *           &quot;@ *Date&quot; : []
     *        }
     *     }
     *
     *
     *   Here, every time you call get(&quot;date&quot;) method a new instance of JS date object will be returned. So
     *   every time will have current time.
     *
     *   - **JS Object initialization** If you have an object in your code you can easily fulfill properties of the
     *   object with JSON zson. For instance you can create zebkit UI panel and adjust its background, border and so on
     *   with what is stored in JSON:
     *
     *
     *     {
     *       &quot;background&quot;: &quot;red&quot;,
     *       &quot;layout&quot;    : { &quot;@zebkit.layout.BorderLayout&quot;: [] },
     *       &quot;border&quot;    : { &quot;@zebkit.draw.RoundBorder&quot;: [ &quot;black&quot;, 2 ] }
     *     }
     *
     *     var pan = new zebkit.ui.Panel();
     *     new zebkit.util.Zson(pan).then(&quot;pan.json&quot;, function(zson) {
     *         // loaded and fullil panel
     *         ...
     *     });
     *
     *
     *   - **Expression** You can evaluate expression as a property value:
     *
     *
     *     {
     *         &quot;a&quot;: { &quot;.expr&quot;:  &quot;100*10&quot; }
     *     }
     *
     *
     *   Here property &quot;a&quot; equals 1000
     *
     *
     *   - **Load external resources** You can combine Zson from another Zson:
     *
     *
     *     {
     *         &quot;a&quot;: &quot;%{&lt;json&gt; embedded.json}&quot;,
     *         &quot;b&quot;: 100
     *     }
     *
     *
     *   Here property &quot;a&quot; is loaded with properties set with loading external &quot;embedded.json&quot; file
     *
     * @class zebkit.util.Zson
     * @constructor
     * @param {Object} [obj] a root object to be loaded with
     * the given JSON configuration
     */
    pkg.Zson = zebkit.Class([
        function (root) {
            if (arguments.length &gt; 0) {
                this.root = root;
            }

            /**
             * Map of aliases and appropriate classes
             * @attribute classAliases
             * @protected
             * @type {Object}
             * @default {}
             */
            this.classAliases = {};
        },

        function $prototype() {
            this.url = null;


            /**
             * Object that keeps loaded and resolved content of a JSON
             * @readOnly
             * @attribute root
             * @type {Object}
             * @default {}
             */
            this.root = null;

            /**
             * Original JSON as a JS object
             * @attribute content
             * @protected
             * @type {Object}
             * @default null
             */
            this.content = null;

            /**
             * The property says if the object introspection is required to try find a setter
             * method for the given key. For instance if an object is loaded with the
             * following JSON:

             {
                &quot;color&quot;: &quot;red&quot;
             }

             * the introspection will cause zson class to try finding &quot;setColor(c)&quot; method in
             * the loaded with the JSON object and call it to set &quot;red&quot; property value.
             * @attribute usePropertySetters
             * @default true
             * @type {Boolean}
             */
            this.usePropertySetters = true;

            /**
             * Get a property value by the given key. The property name can point to embedded fields:
             *
             *      new zebkit.util.Zson().then(&quot;my.json&quot;, function(zson) {
             *          zson.get(&quot;a.b.c&quot;);
             *      });
             *
             *
             * @param  {String} key a property key.
             * @return {Object} a property value
             * @throws Error if property cannot be found and it  doesn&#x27;t start with &quot;?&quot;
             * @method  get
             */
            this.get = function(key) {
                if (key === null || typeof key === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Null key&quot;);
                }

                var ignore = false;
                if (key[0] === &#x27;?&#x27;) {
                    key = key.substring(1).trim();
                    ignore = true;
                }

                var v = this.$get(key.split(&#x27;.&#x27;), this.root);
                if (ignore === false &amp;&amp; typeof v === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Property &#x27;&quot; + key + &quot;&#x27; not found&quot;);
                }

                return v;
            };

            /**
             * Internal implementation of fetching a property value.
             * @param  {Array} keys array of a key path parts
             * @param  {Object} root an object to start resolving a property value
             * @method  $get
             * @protected
             * @return {Object} a property value or undefined if the property  cannot be fetched from the
             * object
             */
            this.$get = function(keys, root) {
                if (keys.length === 0) {
                    throw new Error(&quot;No keys were found&quot;);
                }

                var v = root;
                for(var i = 0; i &lt; keys.length; i++) {
                    v = v[keys[i]];
                    if (typeof v === &quot;undefined&quot;) {
                        return undefined;
                    }
                }
                return v !== null &amp;&amp; v.$new ? v.$new() : v;
            };

            /**
             * Test if the given value has atomic type (String, Number or Boolean).
             * @param  {Object}  v a value
             * @return {Boolean} true if the value has atomic type
             * @protected
             * @method  $isAtomic
             */
            this.$isAtomic = function(v) {
                return v === null || typeof v === &#x27;undefined&#x27; ||
                       (typeof v === &quot;string&quot;  || v.constructor === String)  ||
                       (typeof v === &quot;number&quot;  || v.constructor === Number)  ||
                       (typeof v === &quot;boolean&quot; || v.constructor === Boolean)  ;
            };

            /**
             * Call method.
             * @param  {String} name a method name
             * @param  {Object} d arguments
             * @return {Object} a method execution result
             * @method callMethod
             */
            this.callMethod = function(name, d) {
                var m  = this[name.substring(1).trim()],
                    ts = this.$runner.$tasks.length,
                    bs = this.$runner.$busy;

                if (typeof m !== &#x27;function&#x27;) {
                    throw new Error(&quot;Method &#x27;&quot; + name + &quot;&#x27; cannot be found&quot;);
                }

                var args = this.buildValue(Array.isArray(d) ? d
                                                            : [ d ]),
                    $this = this;

                if (this.$runner.$tasks.length === ts &amp;&amp;
                    this.$runner.$busy === bs           )
                {
                    var res = m.apply(this, args);
                    if (res instanceof zebkit.DoIt) {
                        return new zebkit.DoIt().till(this.$runner).then(function() {
                            var jn = this.join();
                            res.then(function(res) {
                                jn(res);
                                return res;
                            }).then(function(res) {
                                return res;
                            });
                        }).catch(function(e) {
                            $this.$runner.error(e);
                        });
                    } else {
                        return res;
                    }
                } else {
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        if (args instanceof zebkit.DoIt) {
                            var jn = this.join();
                            args.then(function(res) {
                                jn(res);
                                return res;
                            });
                        } else {
                            return args;
                        }
                    }).then(function(args) {
                        var res = m.apply($this, args);
                        if (res instanceof zebkit.DoIt) {
                            var jn = this.join();
                            res.then(function(res) {
                                jn(res);
                                return res;
                            });
                        } else {
                            return res;
                        }
                    }).then(function(res) {
                        return res;
                    }).catch(function(e) {
                        $this.$runner.error(e);
                    });
                }
            };

            this.$resolveRef = function(target, names) {
                var fn = function(ref, rn) {
                    rn.then(function(target) {
                        if (target != null &amp;&amp; target.hasOwnProperty(ref) === true) {
                            var v = target[ref];
                            if (v instanceof zebkit.DoIt) {
                                var jn = this.join();
                                v.then(function(res) {
                                    jn.call(rn, res);
                                    return res;
                                });
                            } else {
                                return v;
                            }
                        } else {
                            return undefined;
                        }
                    });
                };

                for (var j = 0; j &lt; names.length; j++) {
                    var ref = names[j];

                    if (target.hasOwnProperty(ref)) {
                        var v = target[ref];

                        if (v instanceof zebkit.DoIt) {
                            var rn      = new zebkit.DoIt(),
                                trigger = rn.join();

                            for(var k = j; k &lt; names.length; k++) {
                                fn(names[k], rn);
                            }

                            trigger.call(rn, target);
                            return rn;
                        } else {
                            target = target[ref];
                        }

                    } else {
                        return undefined;
                    }
                }

                return target;
            };

            this.$buildArray = function(d) {
                var hasAsync = false;
                for (var i = 0; i &lt; d.length; i++) {
                    var v = this.buildValue(d[i]);
                    if (v instanceof zebkit.DoIt) {
                        hasAsync = true;
                        this.$assignValue(d, i, v);
                    } else {
                        d[i] = v;
                    }
                }

                if (hasAsync) {
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        return d;
                    });
                } else {
                    return d;
                }
            };

            this.$buildClass = function(k, d) {
                var classname = k.substring(1).trim(),
                    args      = d[k],
                    clz       = null,
                    busy      = this.$runner.$busy,
                    tasks     = this.$runner.$tasks.length;

                delete d[k]; // delete class name

                // &#x27;?&#x27; means optional class instance.
                if (classname[0] === &#x27;?&#x27;) {
                    classname = classname.substring(1).trim();
                    try {
                        clz = this.resolveClass(classname[0] === &#x27;*&#x27; ? classname.substring(1).trim()
                                                                     : classname);
                    } catch (e) {
                        return null;
                    }
                } else {
                    clz = this.resolveClass(classname[0] === &#x27;*&#x27; ? classname.substring(1).trim()
                                                                 : classname);
                }

                args = this.buildValue(Array.isArray(args) ? args
                                                           : [ args ]);

                if (classname[0] === &#x27;*&#x27;) {
                    return (function(clazz, args) {
                        return {
                            $new : function() {
                                return zebkit.newInstance(clazz, args);
                            }
                        };
                    })(clz, args);
                }

                var props = this.buildValue(d);

                // let&#x27;s do optimization to avoid unnecessary overhead
                // equality means nor arguments neither properties has got async call
                if (this.$runner.$busy === busy &amp;&amp; this.$runner.$tasks.length === tasks) {
                    var inst = zebkit.newInstance(clz, args);
                    this.merge(inst, props, true);
                    return inst;
                } else {
                    var $this = this;
                    return new zebkit.DoIt().till(this.$runner).then(function() {
                        var jn1 = this.join(),  // create all join here to avoid result overwriting
                            jn2 = this.join();

                        if (args instanceof zebkit.DoIt) {
                            args.then(function(res) {
                                jn1(res);
                                return res;
                            });
                        } else {
                            jn1(args);
                        }

                        if (props instanceof zebkit.DoIt) {
                            props.then(function(res) {
                                jn2(res);
                                return res;
                            });
                        } else {
                            jn2(props);
                        }
                    }).then(function(args, props) {
                        var inst = zebkit.newInstance(clz, args);
                        $this.merge(inst, props, true);
                        return inst;
                    });
                }
            };

            this.$buildRef = function(d) {
                var idx = -1;

                if (d[2] === &quot;&lt;&quot; || d[2] === &#x27;.&#x27; || d[2] === &#x27;/&#x27;) { //TODO: not complete solution that cannot detect URLs
                    var path  = null,
                        type  = null,
                        $this = this;

                    if (d[2] === &#x27;&lt;&#x27;) {
                        // if the referenced path is not absolute path and the zson has been also
                        // loaded by an URL than build the full URL as a relative path from
                        // BAG URL
                        idx = d.indexOf(&#x27;&gt;&#x27;);
                        if (idx &lt;= 4) {
                            throw new Error(&quot;Invalid content type in URL &#x27;&quot; + d + &quot;&#x27;&quot;);
                        }

                        path = d.substring(idx + 1, d.length - 1).trim();
                        type = d.substring(3, idx).trim();
                    } else {
                        path = d.substring(2, d.length - 1).trim();
                        type = &quot;json&quot;;
                    }

                    if (type === &#x27;js&#x27;) {
                        return this.expr(path);
                    }

                    if (this.url !== null &amp;&amp; zebkit.URI.isAbsolute(path) === false) {
                        var pURL = new zebkit.URI(this.url).getParent();
                        if (pURL !== null) {
                            path = zebkit.URI.join(pURL, path);
                        }
                    }

                    if (type === &quot;json&quot;) {
                        var bag = new this.clazz();
                        bag.usePropertySetters = this.usePropertySetters;

                        var bg = bag.then(path).catch();
                        this.$runner.then(bg.then(function(res) {
                            return res.root;
                        }));
                        return bg;
                    } else if (type === &#x27;img&#x27;) {
                        if (this.url !== null &amp;&amp; zebkit.URI.isAbsolute(path) === false) {
                            path = zebkit.URI.join(new zebkit.URI(this.url).getParent(),
                                                   path);
                        }
                        return pkg.image(path, false);
                    } else if (type === &#x27;txt&#x27;) {
                        return new zebkit.io.GET(path).then(function(r) {
                            return r.responseText;
                        }).catch(function(e) {
                            $this.$runner.error(e);
                        });
                    } else {
                        throw new Error(&quot;Invalid content type &quot; + type);
                    }

                } else {
                    // ? means don&#x27;t throw exception if reference cannot be resolved
                    idx = 2;
                    if (d[2] === &#x27;?&#x27;) {
                        idx ++;
                    }

                    var name    = d.substring(idx, d.length - 1).trim(),
                        names   = name.split(&#x27;.&#x27;),
                        targets = [ this.content, this.root,  zebkit.$global ];

                    for(var i = 0; i &lt; targets.length; i++) {
                        var target = targets[i];
                        if (target !== null) {
                            var value = this.$resolveRef(target, names);
                            if (typeof value !== &#x27;undefined&#x27;) {
                                return value;
                            }
                        }
                    }

                    if (idx === 2) {
                        throw new Error(&quot;Reference &#x27;&quot; + name + &quot;&#x27; cannot be resolved&quot;);
                    } else {
                        return d;
                    }
                }
            };

            /**
             * Build a value by the given JSON description
             * @param  {Object} d a JSON description
             * @return {Object} a value
             * @protected
             * @method buildValue
             */
            this.buildValue = function(d) {
                if (typeof d === &#x27;undefined&#x27; || d === null || d instanceof zebkit.DoIt ||
                    (typeof d === &quot;number&quot;   || d.constructor === Number)              ||
                    (typeof d === &quot;boolean&quot;  || d.constructor === Boolean)                )
                {
                    return d;
                }

                if (Array.isArray(d)) {
                    return this.$buildArray(d);
                }

                if (typeof d === &quot;string&quot; || d.constructor === String) {
                    if (d[0] === &#x27;%&#x27; &amp;&amp; d[1] === &#x27;{&#x27; &amp;&amp; d[d.length - 1] === &#x27;}&#x27;) {
                        return this.$buildRef(d);
                    } else {
                        return d;
                    }
                }

                var k = null;

                // test whether we have a class definition
                for (k in d) {
                    // handle class definition
                    if (k[0] === &#x27;@&#x27; &amp;&amp; d.hasOwnProperty(k) === true) {
                        return this.$buildClass(k, d);
                    }

                    //!!!!  trust the name of class occurs first what in general
                    //      cannot be guaranteed by JSON spec but we can trust
                    //      since many other third party applications stands
                    //      on it too :)
                    break;
                }

                for (k in d) {
                    if (d.hasOwnProperty(k)) {
                        var v = d[k];

                        // special field name that says to call method to create a
                        // value by the given description
                        if (k[0] === &quot;.&quot; || k[0] === &#x27;#&#x27;) {
                            delete d[k];
                            if (k[0] === &#x27;#&#x27;) {
                                this.callMethod(k, v, d);
                            } else {
                                return this.callMethod(k, v, d);
                            }
                        } else if (k[0] === &#x27;%&#x27;) {
                            delete d[k];
                            this.mixin(d, this.$buildRef(k));
                        } else {
                            this.$assignValue(d, k, this.buildValue(v));
                        }
                    }
                }

                return d;
            };

            this.$assignValue = function(o, k, v) {
                o[k] = v;
                if (v instanceof zebkit.DoIt) {
                    this.$runner.then(v.then(function(res) {
                        o[k] = res;
                        return res;
                    }));
                }
            };

            this.$assignProperty = function(o, m, v) {
                // setter has to be placed in queue to let
                // value resolves its DoIts
                this.$runner.then(function(res) {
                    if (Array.isArray(v)) {
                        m.apply(o, v);
                    } else {
                        m.call (o, v);
                    }
                    return res;
                });
            };

            this.merge = function(dest, src, recursively) {
                if (arguments.length &lt; 3) {
                    recursively = true;
                }

                for (var k in src) {
                    if (src.hasOwnProperty(k)) {
                        var sv = src [k],
                            dv = dest[k];

                        if (this.usePropertySetters === true) {
                            var m = zebkit.getPropertySetter(dest, k);
                            if (m !== null) {
                                this.$assignProperty(dest, m, sv);
                                continue;
                            }
                        }


                        if (this.$isAtomic(dv) || Array.isArray(dv) ||
                            this.$isAtomic(sv) || Array.isArray(sv) ||
                            typeof sv.clazz !== &#x27;undefined&#x27;            )
                        {
                            this.$assignValue(dest, k, sv);
                        } else if (recursively === true) {
                            if (dv != null &amp;&amp; typeof dv.clazz !== &#x27;undefined&#x27; &amp;&amp; dv.clazz.mergeable === false) {
                                this.$assignValue(dest, k, sv);
                            } else {
                                this.merge(dv, sv);
                            }
                        }
                    }
                }
                return dest;
            };

            this.mixin = function(dest, src) {
                if (src instanceof zebkit.DoIt) {
                    var $this = this;
                    this.$runner.then(src.then(function(src) {
                        for (var k in src) {
                            if (src.hasOwnProperty(k) &amp;&amp; (typeof dest[k] === &#x27;undefined&#x27; || dest[k] === null)) {
                                $this.$assignValue(dest, k, src[k]);
                            }
                        }
                    }));
                } else {
                    for (var k in src) {
                        if (src.hasOwnProperty(k) &amp;&amp; (typeof dest[k] === &#x27;undefined&#x27; || dest[k] === null)) {
                            this.$assignValue(dest, k, src[k]);
                        }
                    }
                }
            };

            /**
             * Called every time the given class name has to be transformed into
             * the class object (constructor) reference. The method checks if the given class name
             * is alias that is mapped with the zson to a class.
             * @param  {String} className a class name
             * @return {Function} a class reference
             * @method resolveClass
             * @protected
             */
            this.resolveClass = function(className) {
                return this.classAliases.hasOwnProperty(className) ? this.classAliases[className]
                                                                   : zebkit.Class.forName(className);
            };

            /**
             * Adds class aliases
             * @param {Object} aliases dictionary where key is a class alias that can be referenced from
             * JSON and the value is class itself (constructor)
             * @method  addClassAliases
             */
            this.addClassAliases = function(aliases) {
                for(var k in aliases) {
                    this.classAliases[k] = Class.forName(aliases[k].trim());
                }
            };

            this.expr = function(expr) {
                if (expr.length &gt; 200) {
                    throw new Error(&quot;Out of evaluated script limit&quot;);
                }

                return eval(&quot;&#x27;use strict&#x27;;&quot; + expr);
            };

            /**
             * Load and parse the given JSON content.
             * @param  {String|Object} json a JSON content. It can be:
             *    - **String**
             *       - JSON string
             *       - URL to a JSON
             *    - **Object** JavaScript object
             * @return {zebkit.DoIt} a reference to the runner
             * @method then
             * @example
             *
             *     // load JSON in zson from a remote site asynchronously
             *     new zebkit.util.Zson().then(&quot;http://test.com/test.json&quot;, function(zson) {
             *             // zson is loaded and ready for use
             *             zson.get(&quot;a.c&quot;);
             *         }
             *     ).catch(function(error) {
             *         // handle error
             *         ...
             *     });
             */
            this.then = function(json, fn) {
                if (json === null || typeof json === &#x27;undefined&#x27; || (zebkit.isString(json) &amp;&amp; json.trim().length === 0)) {
                    throw new Error(&quot;Null content&quot;);
                }

                this.$runner = new zebkit.DoIt();

                var $this = this;
                this.$runner.then(function() {
                    if (zebkit.isString(json)) {
                        json = json.trim();

                        // detect if the passed string is not a JSON, but URL
                        if ((json[0] !== &#x27;[&#x27; || json[json.length - 1] !== &#x27;]&#x27;) &amp;&amp;
                            (json[0] !== &#x27;{&#x27; || json[json.length - 1] !== &#x27;}&#x27;)   )
                        {
                            $this.url = json + (json.lastIndexOf(&quot;?&quot;) &gt; 0 ? &quot;&amp;&quot; : &quot;?&quot;) + (new Date()).getTime().toString();

                            var join = this.join();
                            zebkit.io.GET($this.url).then(function(r) {
                                join.call($this, r.responseText);
                            }).catch(function(e) {
                                $this.$runner.error(e);
                            });
                        } else {
                            return json;
                        }
                    } else {
                        return json;
                    }
                }).then(function(json) { // populate JSON content
                    if (zebkit.isString(json)) {
                        try {
                            $this.content = JSON.parse(json);
                        } catch(e) {
                            throw new Error(&quot;JSON format error: &quot; + e);
                        }
                    } else {
                        $this.content = json;
                    }

                    $this.$assignValue($this, &quot;content&quot;, $this.buildValue($this.content));
                }).then(function() {
                    if ($this.root !== null) {
                        $this.merge($this.root, $this.content);
                    } else {
                        $this.root = $this.content;
                    }
                    return $this;
                });

                if (arguments.length &gt; 1) {
                    this.$runner.then(fn);
                }

                return this.$runner;
            };
        }
    ]);
});
zebkit.package(&quot;io&quot;, function(pkg, Class) {
    /**
     * The module provides number of classes to help to communicate with remote services and servers by HTTP,
     * JSON-RPC, XML-RPC protocols.
     *
     *       // shortcut method to perform HTTP GET request
     *       zebkit.io.GET(&quot;http://test.com&quot;).then(function(req) {
     *           // handle request
     *           req.responseText
     *           ...
     *       }).catch(function(exception) {
     *           // handle error
     *       });
     *
     * @class zebkit.io
     * @access package
     */

    // TODO: Web dependencies:
    //    -- Uint8Array
    //    -- ArrayBuffer

    // !!!
    // b64 is supposed to be used with binary stuff, applying it to utf-8 encoded data can bring to error
    // !!!

    var HEX    = &quot;0123456789ABCDEF&quot;,
        b64str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;

    /**
     * Generate UUID of the given length
     * @param {Integer} [size] the generated UUID length. The default size is 16 characters.
     * @return {String} an UUID
     * @method  UID
     * @for  zebkit.io
     */
    pkg.UID = function(size) {
        if (arguments.length === 0) {
            size = 16;
        }
        var id = &quot;&quot;;
        for (var i = 0; i &lt; size; i++) {
            id = id + HEX[~~(Math.random() * 16)];
        }
        return id;
    };

    /**
     * Encode the given string into base64
     * @param  {String} input a string to be encoded
     * @method  b64encode
     * @for zebkit.io
     */
    pkg.b64encode = function(input) {
        var out = [], i = 0, len = input.length, c1, c2, c3;
        if (typeof ArrayBuffer !== &quot;undefined&quot;) {
            if (input instanceof ArrayBuffer) {
                input = new Uint8Array(input);
            }
            input.charCodeAt = function(i) { return this[i]; };
        }

        if (Array.isArray(input)) {
            input.charCodeAt = function(i) { return this[i]; };
        }

        while(i &lt; len) {
            c1 = input.charCodeAt(i++) &amp; 0xff;
            out.push(b64str.charAt(c1 &gt;&gt; 2));
            if (i === len) {
                out.push(b64str.charAt((c1 &amp; 0x3) &lt;&lt; 4), &quot;==&quot;);
                break;
            }

            c2 = input.charCodeAt(i++);
            out.push(b64str.charAt(((c1 &amp; 0x3) &lt;&lt; 4) | ((c2 &amp; 0xF0) &gt;&gt; 4)));
            if (i === len) {
                out.push(b64str.charAt((c2 &amp; 0xF) &lt;&lt; 2), &quot;=&quot;);
                break;
            }

            c3 = input.charCodeAt(i++);
            out.push(b64str.charAt(((c2 &amp; 0xF) &lt;&lt; 2) | ((c3 &amp; 0xC0) &gt;&gt; 6)), b64str.charAt(c3 &amp; 0x3F));
        }

        return out.join(&#x27;&#x27;);
    };

    /**
     * Decode the base64 encoded string
     * @param {String} input base64 encoded string
     * @return {String} a string
     * @for zebkit.io
     * @method b64decode
     */
    pkg.b64decode = function(input) {
        var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;);

        while ((input.length % 4) !== 0) {
            input += &quot;=&quot;;
        }

        for(var i=0; i &lt; input.length;) {
            enc1 = b64str.indexOf(input.charAt(i++));
            enc2 = b64str.indexOf(input.charAt(i++));
            enc3 = b64str.indexOf(input.charAt(i++));
            enc4 = b64str.indexOf(input.charAt(i++));

            chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
            chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
            chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;
            output.push(String.fromCharCode(chr1));
            if (enc3 !== 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 !== 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        return output.join(&#x27;&#x27;);
    };

    pkg.dateToISO8601 = function(d) {
        function pad(n) { return n &lt; 10 ? &#x27;0&#x27;+ n : n; }
        return [ d.getUTCFullYear(), &#x27;-&#x27;, pad(d.getUTCMonth()+1), &#x27;-&#x27;, pad(d.getUTCDate()), &#x27;T&#x27;, pad(d.getUTCHours()), &#x27;:&#x27;,
                 pad(d.getUTCMinutes()), &#x27;:&#x27;, pad(d.getUTCSeconds()), &#x27;Z&#x27;].join(&#x27;&#x27;);
    };

    // http://webcloud.se/log/JavaScript-and-ISO-8601/
    pkg.ISO8601toDate = function(v) {
        var regexp = [&quot;([0-9]{4})(-([0-9]{2})(-([0-9]{2})&quot;, &quot;(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?&quot;,
                      &quot;(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?&quot;].join(&#x27;&#x27;), d = v.match(new RegExp(regexp)),
                      offset = 0, date = new Date(d[1], 0, 1);

        if (d[3]) {
            date.setMonth(d[3] - 1);
        }

        if (d[5]) {
            date.setDate(d[5]);
        }

        if (d[7])  {
            date.setHours(d[7]);
        }

        if (d[8])  {
            date.setMinutes(d[8]);
        }

        if (d[10]) {
            date.setSeconds(d[10]);
        }

        if (d[12]) {
            date.setMilliseconds(Number(&quot;0.&quot; + d[12]) * 1000);
        }

        if (d[14]) {
            offset = (Number(d[16]) * 60) + Number(d[17]);
            offset *= ((d[15] === &#x27;-&#x27;) ? 1 : -1);
        }

        offset -= date.getTimezoneOffset();
        date.setTime(Number(date) + (offset * 60 * 1000));
        return date;
    };

    /**
     * HTTP request class. This class provides API to generate different
     * (GET, POST, etc) HTTP requests
     * @class zebkit.io.HTTP
     * @constructor
     * @param {String} url an URL to a HTTP resource
     */
    pkg.HTTP = Class([
        function(url) {
            this.url = url;
            this.header = {};
        },

        function $prototype() {
            /**
             * Perform HTTP GET request with the given query parameters.
             * @param {Object} [q] a dictionary of query parameters
             * @return {zebkit.DoIt} an object to get response
             * @example
             *
             *     // GET request with the number of query parameters
             *     var result = zebkit.io.HTTP(&quot;google.com&quot;).GET({
             *         param1: &quot;var1&quot;,
             *         param3: &quot;var2&quot;,
             *         param3: &quot;var3&quot;
             *     }).then(function(req) {
             *         // handle response
             *         req.responseText;
             *     }).catch(function(e)  {
             *         // handle error
             *         ...
             *     });
             *
             * @method GET
             */
            this.GET = function(q) {
                var u = this.url + ((arguments.length === 0 || q === null) ? &#x27;&#x27;
                                                                           : ((this.url.indexOf(&quot;?&quot;) &gt; 0) ? &#x27;&amp;&#x27;
                                                                                                          : &#x27;?&#x27;) + zebkit.URI.toQS(q, true));
                return this.SEND(&quot;GET&quot;, u);
            };

            /**
             * Perform HTTP POST request with the give data to be sent.
             * @param {String|Object} d a data to be sent by HTTP POST request.  It can be
             * either a parameters set or a string.
             * @return {zebkit.DoIt} an object to get response
             * @example
             *
             *     // asynchronously send POST
             *     zebkit.io.HTTP(&quot;google.com&quot;).POST(&quot;Hello&quot;).then(function(req) {
             *         // handle HTTP GET response ...
             *     }).catch(function(e) {
             *         // handle error ...
             *     });
             *
             * Or you can pass a number of parameters to be sent:
             *
             *     // send parameters synchronously by HTTP POST request
             *     zebkit.io.HTTP(&quot;google.com&quot;).POST({
             *         param1: &quot;val1&quot;,
             *         param2: &quot;val3&quot;,
             *         param3: &quot;val3&quot;
             *     }).then(function(req) {
             *          // handle HTTP GET response ...
             *     }).catch(function(e) {
             *          // handle error ...
             *    });
             *
             * @method POST
             */
            this.POST = function(d) {
                // if the passed data is simple dictionary object encode it as POST
                // parameters
                //
                // TODO: think also about changing content type
                // &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;
                if (d !== null &amp;&amp; zebkit.isString(d) === false &amp;&amp; d.constructor === Object) {
                    d = zebkit.URI.toQS(d, false);
                }

                return this.SEND(&quot;POST&quot;, this.url, d);
            };

            /**
             * Universal HTTP request method that can be used to generate a HTTP request with
             * any HTTP method to the given URL with the given data to be sent asynchronously.
             * @param {String}   method   an HTTP method (GET, POST, DELETE, PUT, etc)
             * @param {String}   url      an URL
             * @param {String}   [data]   a data to be sent to the given URL
             * @return {zebkit.DoIt} an object to handle result
             * @method SEND
             */
            this.SEND = function(method, url, data) {
                var req = zebkit.environment.getHttpRequest();

                req.open(method, url, true);
                for (var k in this.header) {
                    req.setRequestHeader(k, this.header[k]);
                }

                return new zebkit.DoIt(function() {
                    var jn    = this.join(),
                        $this = this;

                    req.onreadystatechange = function() {
                        if (req.readyState === 4) {
                            // evaluate http response
                            if (req.status &gt;= 400 || req.status &lt; 100) {
                                var e = new Error(&quot;HTTP error &#x27;&quot; + req.statusText + &quot;&#x27;, code = &quot; + req.status + &quot; &#x27;&quot; + url + &quot;&#x27;&quot;);
                                e.status     = req.status;
                                e.statusText = req.statusText;
                                e.readyState = req.readyState;
                                $this.error(e);
                            } else {
                                jn(req);
                            }
                        }
                    };

                    try {
                        req.send(arguments.length &gt; 2 ? data : null);
                    } catch(e) {
                        this.error(e);
                    }
                });
            };
        }
    ]);

    /**
     * Shortcut method to perform HTTP GET requests.

        zebkit.io.GET(&quot;http://test.com&quot;).then(function(request) {
            // handle result ...
        }).catch(function(e) {
            // handle error ...
        });

        var res = zebkit.io.GET(&quot;http://test.com&quot;, {
            param1 : &quot;var1&quot;,
            param1 : &quot;var2&quot;,
            param1 : &quot;var3&quot;
        }).then(function(req) {
            // handle result ...
        });

     * @param {String|Object} url an URL
     * @param {Object} [parameters] a dictionary of query parameters
     * @return  {zebkit.DoIt} an object to handle result
     * @method GET
     * @for zebkit.io
     */
    pkg.GET = function(url) {
        var http = new pkg.HTTP(url);
        return http.GET.apply(http, Array.prototype.slice.call(arguments, 1));
    };

    /**
     * Shortcut method to perform HTTP POST requests.

        zebkit.io.POST(&quot;http://test.com&quot;, null).then(function(request) {
            // handle result
            ...
        }).catch(function(e) {
            // handle error ...
        });

        var res = zebkit.io.POST(&quot;http://test.com&quot;, {
            param1 : &quot;var1&quot;,
            param1 : &quot;var2&quot;,
            param1 : &quot;var3&quot;
        }).then(function(request) {
            // handle result
            ...
        });

        zebkit.io.POST(&quot;http://test.com&quot;, &quot;request&quot;).then(function(request) {
            // handle error
            ...
        });

     * @param {String} url an URL
     * @param {Object} [data] a data or form data parameters
     * @return  {zebkit.DoIt} an object to handle result
     * @method  POST
     * @for zebkit.io
     */
    pkg.POST = function(url) {
        var http = new pkg.HTTP(url);
        return http.POST.apply(http, Array.prototype.slice.call(arguments, 1));
    };

    /**
     * A remote service connector class. It is supposed the class has to be extended with
     * different protocols like RPC, JSON etc. The typical pattern of connecting to
     * a remote service is shown below:

        // create service connector that has two methods &quot;a()&quot; and &quot;b(param1)&quot;
        var service = new zebkit.io.Service(&quot;http://myservice.com&quot;, [
            &quot;a&quot;, &quot;b&quot;
        ]);

        // call the methods of the remote service
        service.a();
        service.b(10);

     * Also the methods of a remote service can be called asynchronously. In this case
     * a callback method has to be passed as the last argument of called remote methods:

        // create service connector that has two methods &quot;a()&quot; and &quot;b(param1)&quot;
        var service = new zebkit.io.Service(&quot;http://myservice.com&quot;, [
            &quot;a&quot;, &quot;b&quot;
        ]);

        // call &quot;b&quot; method from the remote service asynchronously
        service.b(10, function(res) {
            // handle a result of the remote method execution here
            ...
        });
     *
     * Ideally any specific remote service extension of &quot;zebkit.io.Service&quot;
     * class has to implement two methods:

        - **encode** to say how the given remote method with passed parameters have
        to be transformed into a concrete service side protocol (JSON, XML, etc)
        - **decode** to say how the specific service response has to be converted into
        JavaScript object

     * @class zebkit.io.Service
     * @constructor
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     */
    pkg.Service = Class([
        function(url, methods) {
            var $this = this;
            /**
             * Remote service url
             * @attribute url
             * @readOnly
             * @type {String}
             */
            this.url = url;

            /**
             * Remote service methods names
             * @attribute methods
             * @readOnly
             * @type {Array}
             */
            if (Array.isArray(methods) === false) {
                methods = [ methods ];
            }

            for(var i = 0; i &lt; methods.length; i++) {
                (function() {
                    var name = methods[i];
                    $this[name] = function() {
                        var args = Array.prototype.slice.call(arguments);
                        return this.send(url, this.encode(name, args)).then(function(req) {
                            if (req.status === 200) {
                                return $this.decode(req.responseText);
                            } else {
                                this.error(new Error(&quot;Status: &quot; + req.status + &quot;, &#x27;&quot; + req.statusText + &quot;&#x27;&quot;));
                            }
                        });
                    };
                })();
            }
        },

        function $prototype() {
            this.contentType = null;

             /**
              * Send the given data to the given url and return a response. Callback
              * function can be passed for asynchronous result handling.
              * @protected
              * @param  {String}   url an URL
              * @param  {String}   data  a data to be send
              * @return {zebkit.DoIt}  a result
              * @method  send
              */
            this.send = function(url, data) {
                var http = new pkg.HTTP(url);
                if (this.contentType !== null) {
                    http.header[&#x27;Content-Type&#x27;] = this.contentType;
                }
                return http.POST(data);
            };
        }

        /**
         * Transforms the given remote method execution with the specified parameters
         * to service specific protocol.
         * @param {String} name a remote method name
         * @param {Array} args an passed to the remote method arguments
         * @return {String} a remote service specific encoded string
         * @protected
         * @method encode
         */

        /**
         * Transforms the given remote method response to a JavaScript
         * object.
         * @param {String} name a remote method name
         * @return {Object} a result of the remote method calling as a JavaScript
         * object
         * @protected
         * @method decode
         */
    ]);

    /**
     * Build invoke method that calls a service method.
     * @param  {zebkit.Class} clazz a class
     * @param  {String} url an URL
     * @param  {String} a service method name
     * @return {Function} a wrapped method to call RPC method with
     * @private
     * @method  invoke
     * @static
     */
    pkg.Service.invoke = function(clazz, url, method) {
        var rpc = new clazz(url, method);
        return function() {
            return rpc[method].apply(rpc, arguments);
        };
    };

    /**
     * The class is implementation of JSON-RPC remote service connector.

        // create JSON-RPC connector to a remote service that
        // has three remote methods
        var service = new zebkit.io.JRPC(&quot;json-rpc.com&quot;, [
            &quot;method1&quot;, &quot;method2&quot;, &quot;method3&quot;
        ]);

        // synchronously call remote method &quot;method1&quot;
        service.method1();

        // asynchronously call remote method &quot;method1&quot;
        service.method1(function(res) {
            ...
        });

     * @class zebkit.io.JRPC
     * @constructor
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     * @extends zebkit.io.Service
     */
    pkg.JRPC = Class(pkg.Service, [
        function $prototype() {
            this.version     = &quot;2.0&quot;;
            this.contentType = &quot;application/json; charset=ISO-8859-1;&quot;;

            this.encode = function(name, args) {
                return zebkit.environment.stringifyJSON({
                    jsonrpc : this.version,
                    method  : name,
                    params  : args,
                    id      : pkg.UID() });
            };

            this.decode = function(r) {
                if (r === null || r.length === 0) {
                    throw new Error(&quot;Empty JSON result string&quot;);
                }

                r = zebkit.environment.parseJSON(r);
                if (typeof(r.error) !== &quot;undefined&quot;) {
                    throw new Error(r.error.message);
                }

                if (typeof r.result === &quot;undefined&quot; || typeof r.id === &quot;undefined&quot;) {
                    throw new Error(&quot;Wrong JSON response format&quot;);
                }
                return r.result;
            };
        }
    ]);

    /**
     * Shortcut to call the specified method of a JSON-RPC service.
     * @param  {String} url an URL
     * @param  {String} method a method name
     * @for zebkit.io.JRPC
     * @static
     * @method invoke
     */
    pkg.JRPC.invoke = function(url, method) {
        return pkg.Service.invoke(pkg.JRPC, url, method);
    };

    pkg.Base64 = function(s) {
        if (arguments.length &gt; 0) {
            this.encoded = pkg.b64encode(s);
        }
    };

    pkg.Base64.prototype.toString = function() { return this.encoded; };
    pkg.Base64.prototype.decode   = function() { return pkg.b64decode(this.encoded); };

    /**
     * The class is implementation of XML-RPC remote service connector.

        // create XML-RPC connector to a remote service that
        // has three remote methods
        var service = new zebkit.io.XRPC(&quot;xmlrpc.com&quot;, [
            &quot;method1&quot;, &quot;method2&quot;, &quot;method3&quot;
        ]);

        // synchronously call remote method &quot;method1&quot;
        service.method1();

        // asynchronously call remote method &quot;method1&quot;
        service.method1(function(res) {
            ...
        });

     * @class zebkit.io.XRPC
     * @constructor
     * @extends zebkit.io.Service
     * @param {String} url an URL of remote service
     * @param {Array} methods a list of methods names the remote service provides
     */
    pkg.XRPC = Class(pkg.Service, [
        function $prototype() {
            this.contentType = &quot;text/xml&quot;;

            this.encode = function(name, args) {
                var p = [&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;methodCall&gt;&lt;methodName&gt;&quot;, name, &quot;&lt;/methodName&gt;&lt;params&gt;&quot;];
                for(var i=0; i &lt; args.length;i++) {
                    p.push(&quot;&lt;param&gt;&quot;);
                    this.encodeValue(args[i], p);
                    p.push(&quot;&lt;/param&gt;&quot;);
                }
                p.push(&quot;&lt;/params&gt;&lt;/methodCall&gt;&quot;);
                return p.join(&#x27;&#x27;);
            };

            this.encodeValue = function(v, p)  {
                if (v === null) {
                    throw new Error(&quot;Null is not allowed&quot;);
                }

                if (zebkit.isString(v)) {
                    v = v.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;);
                    v = v.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;);
                    p.push(&quot;&lt;string&gt;&quot;, v, &quot;&lt;/string&gt;&quot;);
                } else {
                    if (zebkit.isNumber(v)) {
                        if (Math.round(v) === v) {
                            p.push(&quot;&lt;i4&gt;&quot;, v.toString(), &quot;&lt;/i4&gt;&quot;);
                        } else {
                            p.push(&quot;&lt;double&gt;&quot;, v.toString(), &quot;&lt;/double&gt;&quot;);
                        }
                    } else {
                        if (zebkit.isBoolean(v)) {
                            p.push(&quot;&lt;boolean&gt;&quot;, v?&quot;1&quot;:&quot;0&quot;, &quot;&lt;/boolean&gt;&quot;);
                        } else {
                            if (v instanceof Date)  {
                                p.push(&quot;&lt;dateTime.iso8601&gt;&quot;, pkg.dateToISO8601(v), &quot;&lt;/dateTime.iso8601&gt;&quot;);
                            } else {
                                if (Array.isArray(v))  {
                                    p.push(&quot;&lt;array&gt;&lt;data&gt;&quot;);
                                    for(var i=0;i&lt;v.length;i++) {
                                        p.push(&quot;&lt;value&gt;&quot;);
                                        this.encodeValue(v[i], p);
                                        p.push(&quot;&lt;/value&gt;&quot;);
                                    }
                                    p.push(&quot;&lt;/data&gt;&lt;/array&gt;&quot;);
                                } else {
                                    if (v instanceof pkg.Base64) {
                                        p.push(&quot;&lt;base64&gt;&quot;, v.toString(), &quot;&lt;/base64&gt;&quot;);
                                    } else {
                                        p.push(&quot;&lt;struct&gt;&quot;);
                                        for (var k in v) {
                                            if (v.hasOwnProperty(k)) {
                                                p.push(&quot;&lt;member&gt;&lt;name&gt;&quot;, k, &quot;&lt;/name&gt;&lt;value&gt;&quot;);
                                                this.encodeValue(v[k], p);
                                                p.push(&quot;&lt;/value&gt;&lt;/member&gt;&quot;);
                                            }
                                        }
                                        p.push(&quot;&lt;/struct&gt;&quot;);
                                    }
                                }
                            }
                        }
                    }
                }
            };

            this.decodeValue = function (node) {
                var tag = node.tagName.toLowerCase(), i = 0;

                if (tag === &quot;struct&quot;) {
                     var p = {};
                     for(i = 0; i &lt; node.childNodes.length; i++) {
                        var member = node.childNodes[i],  // &lt;member&gt;
                            key    = member.childNodes[0].childNodes[0].nodeValue.trim(); // &lt;name&gt;/text()
                        p[key] = this.decodeValue(member.childNodes[1].childNodes[0]);   // &lt;value&gt;/&lt;xxx&gt;
                    }
                    return p;
                }

                if (tag === &quot;array&quot;) {
                    var a = [];
                    node = node.childNodes[0]; // &lt;data&gt;
                    for(i = 0; i &lt; node.childNodes.length; i++) {
                        a[i] = this.decodeValue(node.childNodes[i].childNodes[0]); // &lt;value&gt;
                    }
                    return a;
                }

                var v = node.childNodes[0].nodeValue.trim();
                switch (tag) {
                    case &quot;datetime.iso8601&quot;: return pkg.ISO8601toDate(v);
                    case &quot;boolean&quot;: return v === &quot;1&quot;;
                    case &quot;int&quot;:
                    case &quot;i4&quot;:     return parseInt(v, 10);
                    case &quot;double&quot;: return Number(v);
                    case &quot;base64&quot;:
                        var b64 = new pkg.Base64();
                        b64.encoded = v;
                        return b64;
                    case &quot;string&quot;: return v;
                }
                throw new Error(&quot;Unknown tag &quot; + tag);
            };

            this.decode = function(r) {
                var p = zebkit.environment.parseXML(r),
                    c = p.getElementsByTagName(&quot;fault&quot;);

                if (c.length &gt; 0) {
                    var err = this.decodeValue(c[0].getElementsByTagName(&quot;struct&quot;)[0]);
                    throw new Error(err.faultString);
                }

                c = p.getElementsByTagName(&quot;methodResponse&quot;)[0];
                c = c.childNodes[0].childNodes[0]; // &lt;params&gt;/&lt;param&gt;
                if (c.tagName.toLowerCase() === &quot;param&quot;) {
                    return this.decodeValue(c.childNodes[0].childNodes[0]); // &lt;value&gt;/&lt;xxx&gt;
                }
                throw new Error(&quot;Incorrect XML-RPC response&quot;);
            };
        }
    ]);

    /**
     * Shortcut to call the specified method of a XML-RPC service.
     * @param  {String} url an URL
     * @param  {String} method a method name
     * @for zebkit.io.XRPC
     * @method invoke
     * @static
     */
    pkg.XRPC.invoke = function(url, method) {
        return pkg.Service.invoke(pkg.XRPC, url, method);
    };
});

zebkit.package(&quot;data&quot;, function(pkg, Class) {
    /**
     * Collection of various data models. The models are widely used by zebkit UI
     * components as part of model-view-controller approach, but the package doesn&#x27;t depend on
     * zebkit UI and can be used independently.
     *
     *      var model = new zebkit.data.TreeModel();
     *      model.on(&quot;itemInserted&quot;, function(model, item) {
     *          // handle item inserted tree model event
     *          ...
     *      });
     *
     *      model.add(model.root, new zebkit.data.Item(&quot;Child 1&quot;));
     *      model.add(model.root, new zebkit.data.Item(&quot;Child 2&quot;));
     *
     * @class zebkit.data
     * @access package
     */

    pkg.descent = function descent(a, b) {
        if (typeof a === &#x27;undefined&#x27; || a === null) {
            return 1;
        } else {
            return zebkit.isString(a) ? a.localeCompare(b) : a - b;
        }
    };

    pkg.ascent = function ascent(a, b) {
        if (b === null || typeof b === &#x27;undefined&#x27;) {
            return 1;
        } else {
            return zebkit.isString(b) ? b.localeCompare(a) : b - a;
        }
    };

    /**
     * Data model is marker interface. It has no methods implemented, but the interface
     * is supposed to be inherited with data models implementations
     * @class zebkit.data.DataModel
     * @interface zebkit.data.DataModel
     */
    pkg.DataModel = zebkit.Interface();

    /**
     * Abstract text model class
     * @class zebkit.data.TextModel
     * @uses zebkit.data.DataModel
     */

    /**
     * Get the given string line stored in the model
     * @method getLine
     * @param  {Integer} line a line number
     * @return {String}  a string line
     */

    /**
     * Get wrapped by the text model original text string
     * @method getValue
     * @return {String} an original text
     */

    /**
     * Get number of lines stored in the text model
     * @method getLines
     * @return {Integer} a number of lines
     */

    /**
     * Get number of characters stored in the model
     * @method getTextLength
     * @return {Integer} a number of characters
     */

    /**
     * Write the given string in the text model starting from the specified offset
     * @method write
     * @param  {String} s a string to be written into the text model
     * @param  {Integer} offset an offset starting from that the passed
     * string has to be written into the text model
     */

    /**
     * Remove substring from the text model.
     * @method remove
     * @param  {Integer} offset an offset starting from that a substring
     * will be removed
     * @param  {Integer} size a size of a substring to be removed
     */

    /**
     * Fill the text model with the given text
     * @method  setValue
     * @param  {String} text a new text to be set for the text model
     */

    /**
     * Fired when the text model has been updated: a string has been
     * inserted or removed

        text.on(function(src, b, off, len, startLine, lines) {
            ...
        });

     *
     * @event textUpdated
     * @param {zebkit.data.TextModel} src a text model that triggers the event
     * @param {Boolean}  b a flag that is true if a string has been written
     * in the text model, false if the model substring has been removed
     * @param {Integer}  off an offset starting form that the text update
     * took place
     * @param {Integer}  len a length of text that has been affected by
     * the text model update
     * @param {Integer}  startLine a first line that has been affected
     * by the text model update
     * @param {Integer}  lines a number of lines that has been affected
     * by the text model update
     */
    pkg.TextModel = Class(pkg.DataModel, [
        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;textUpdated&quot;);
        }
    ]);

    /**
     * Multi-lines text model implementation
     * @class zebkit.data.Text
     * @param  {String}  [s] the specified text the model has to be filled
     * @constructor
     * @extends zebkit.data.TextModel
     * @uses zebkit.EventProducer
     */
    pkg.Text = Class(pkg.TextModel, zebkit.EventProducer, [
        function(s) {
            /**
             * Array of lines
             * @attribute lines
             * @type {zebkit.data.Text.Line[]}
             * @private
             * @readOnly
             */
            this.$lines = [ new this.clazz.Line(&quot;&quot;) ];
            this._ = new this.clazz.Listeners();
            this.setValue(arguments.length === 0 || s === null ? &quot;&quot; : s);
        },

        function $clazz() {
            this.Line = function(s) {
                this.$s = s;
            };

            //  toString for array.join method
            this.Line.prototype.toString = function() {
                return this.$s;
            };
        },

        function $prototype() {
            /**
             * Text length
             * @attribute textLength
             * @private
             * @readOnly
             * @type {Integer}
             */
            this.textLength = 0;

            /**
             * Detect line by offset starting from the given line and offset.
             * @param  {Integer} [start]       start line
             * @param  {Integer} [startOffset] start offset of the start line
             * @param  {Integer} o             offset to detect line
             * @private
             * @method calcLineByOffset
             * @return {Array}  an array that consists of two elements: detected line index and its offset
             */
            this.calcLineByOffset = function(start, startOffset, o) {
                if (arguments.length === 1) {
                    startOffset = start = 0;
                }

                for(; start &lt; this.$lines.length; start++){
                    var line = this.$lines[start].$s;
                    if (o &gt;= startOffset &amp;&amp; o &lt;= startOffset + line.length){
                        return [start, startOffset];
                    }
                    startOffset += (line.length + 1);
                }
                return [];
            };

            /**
             * Calculate an offset in the text the first character of the specified line.
             * @param  {Integer} line a line index
             * @return {Integer} an offset
             * @protected
             * @method  calcLineOffset
             */
            this.calcLineOffset = function(line) {
                var off = 0;
                for(var i = 0; i &lt; line; i++){
                    off += (this.$lines[i].$s.length + 1);
                }
                return off;
            };

            this.$lineTags = function(i) {
                return this.$lines[i];
            };

            this.getLine = function(line) {
                if (line &lt; 0 || line &gt;= this.$lines.length) {
                    throw RangeError(line);
                }
                return this.$lines[line].$s;
            };

            this.getValue = function() {
                return this.$lines.join(&quot;\n&quot;);
            };

            this.toString = function() {
                return this.$lines.join(&quot;\n&quot;);
            };

            this.getLines = function () {
                return this.$lines.length;
            };

            this.getTextLength = function() {
                return this.textLength;
            };

            /**
             * Remove number of text lines starting form the specified line
             * @param  {Integer} start a starting line to remove text lines
             * @param  {Integer} [size]  a number of lines to be removed. If the
             * argument is not passed number equals 1
             * @method removeLines
             */
            this.removeLines = function(start, size) {
                if (start &lt; 0 || start &gt;= this.$lines.length) {
                    throw new RangeError(start);
                }

                if (arguments.length === 1) {
                    size = 1;
                } else if (size &lt;= 0) {
                    throw new Error(&quot;Invalid number of lines : &quot; + size);
                }

                // normalize number required lines to be removed
                if ((start + size) &gt; this.$lines.length) {
                    size = this.$lines.length - start;
                }

                var end  = start + size - 1,            // last line to be removed
                    off  = this.calcLineOffset(start),  // offset of the first line to be removed
                    olen = start !== end ? this.calcLineOffset(end) + this.$lines[end].$s.length + 1 - off
                                         : this.$lines[start].$s.length + 1;


                // if this is the last line we have to correct offset to point to &quot;\n&quot; character in text
                if (start === this.$lines.length - 1) {
                    off--;
                }

                this.$lines.splice(start, size);
                this._.textUpdated(this, false, off, olen, start, size);
            };

            /**
             * Insert number of lines starting from the given starting line
             * @param  {Integer} startLine a starting line to insert lines
             * @param  {String}  [lines]*  string lines to inserted
             * @method  insertLines
             */
            this.insertLines = function(startLine) {
                if (startLine &lt; 0 || startLine &gt; this.$lines.length) {
                    throw new RangeError(startLine);
                }

                var off = this.calcLineOffset(startLine), offlen = 0;
                if (startLine === this.$lines.length) {
                    off--;
                }

                for(var i = 1; i &lt; arguments.length; i++) {
                    offlen += arguments[i].length + 1;
                    this.$lines.splice(startLine + i - 1, 0, new this.clazz.Line(arguments[i]));
                }
                this._.textUpdated(this, true, off, offlen, startLine, arguments.length - 1);
            };

            this.write = function (s, offset) {
                if (s.length &gt; 0) {
                    var slen    = s.length,
                        info    = this.calcLineByOffset(0,0,offset),
                        line    = this.$lines[info[0]].$s,
                        j       = 0,
                        lineOff = offset - info[1],
                        tmp     = line.substring(0, lineOff) + s + line.substring(lineOff);

                    for(; j &lt; slen &amp;&amp; s[j] !== &#x27;\n&#x27;; j++) {

                    }

                    if (j &gt;= slen) {
                        this.$lines[info[0]].$s = tmp;
                        j = 1;
                    } else {
                        this.$lines.splice(info[0], 1);
                        j = this.parse(info[0], tmp, this.$lines);
                    }

                    if (slen &gt; 0) {
                        this.textLength += slen;
                        this._.textUpdated(this, true, offset, slen, info[0], j);
                        return true;
                    }
                }
                return false;
            };

            this.remove = function(offset, size) {
                if (size &gt; 0) {
                    var i1   = this.calcLineByOffset(0, 0, offset),
                        i2   = this.calcLineByOffset(i1[0], i1[1], offset + size),
                        l1   = this.$lines[i1[0]].$s,
                        l2   = this.$lines[i2[0]].$s,
                        off1 = offset - i1[1], off2 = offset + size - i2[1],
                        buf  = l1.substring(0, off1) + l2.substring(off2);

                    if (i2[0] === i1[0]) {
                        this.$lines.splice(i1[0], 1, new this.clazz.Line(buf));
                    } else {
                        this.$lines.splice(i1[0], i2[0] - i1[0] + 1);
                        this.$lines.splice(i1[0], 0, new this.clazz.Line(buf));
                    }

                    if (size &gt; 0) {
                        this.textLength -= size;
                        this._.textUpdated(this, false, offset, size, i1[0], i2[0] - i1[0] + 1);
                        return true;
                    }
                }
                return false;
            };

            this.parse = function (startLine, text, lines) {
                var size = text.length, prevIndex = 0, prevStartLine = startLine;
                for(var index = 0; index &lt;= size; prevIndex = index, startLine++){
                    var fi = text.indexOf(&quot;\n&quot;, index);
                    index = (fi &lt; 0 ? size : fi);
                    this.$lines.splice(startLine, 0, new this.clazz.Line(text.substring(prevIndex, index)));
                    index++;
                }
                return startLine - prevStartLine;
            };

            this.setValue = function(text) {
                var old = this.getValue();
                if (old !== text) {
                    if (old.length &gt; 0) {
                        var numLines = this.getLines(), txtLen = this.getTextLength();
                        this.$lines.length = 0;
                        this.$lines = [ new this.clazz.Line(&quot;&quot;) ];
                        this._.textUpdated(this, false, 0, txtLen, 0, numLines);
                    }

                    this.$lines = [];
                    this.parse(0, text, this.$lines);
                    this.textLength = text.length;
                    this._.textUpdated(this, true, 0, this.textLength, 0, this.getLines());
                    return true;
                }
                return false;
            };
        }
    ]);

    /**
     * Single line text model implementation
     * @param  {String}  [s] the specified text the model has to be filled
     * @param  {Integer} [max] the specified maximal text length
     * @constructor
     * @class zebkit.data.SingleLineTxt
     * @extends zebkit.data.TextModel
     * @uses zebkit.EventProducer
     */
    pkg.SingleLineTxt = Class(pkg.TextModel, zebkit.EventProducer,[
        function (s, max) {
            if (arguments.length &gt; 1) {
                this.maxLen = max;
            }

            this._ = new this.clazz.Listeners();
            this.setValue(arguments.length === 0 || s === null ? &quot;&quot; : s);
        },

        function $prototype() {
            this.$buf    = &quot;&quot;;
            this.extra  =  0;

            /**
             * Maximal text length. -1 means the text is not restricted
             * regarding its length.
             * @attribute maxLen
             * @type {Integer}
             * @default -1
             * @readOnly
             */
            this.maxLen = -1;

            this.$lineTags = function(i) {
                return this;
            };

            this.getValue = function(){
                return this.$buf;
            };

            this.toString = function() {
                return this.$buf;
            };

            /**
             * Get number of lines stored in the text model. The model
             * can have only one line
             * @method getLines
             * @return {Integer} a number of lines
             */
            this.getLines = function(){
                return 1;
            };

            this.getTextLength = function(){
                return this.$buf.length;
            };

            this.getLine = function(line){
                if (line !== 0) {
                    throw new RangeError(line);
                }
                return this.$buf;
            };

            this.write = function(s,offset) {
                // cut to the first new line character
                var j = s.indexOf(&quot;\n&quot;);
                if (j &gt;= 0) {
                    s = s.substring(0, j);
                }

                var l = (this.maxLen &gt; 0 &amp;&amp; (this.$buf.length + s.length) &gt;= this.maxLen) ? this.maxLen - this.$buf.length
                                                                                         : s.length;
                if (l !== 0) {
                    var nl = this.$buf.substring(0, offset) + s.substring(0, l) + this.$buf.substring(offset);
                    if (typeof this.validate !== &#x27;function&#x27; || this.validate(nl)) {
                        this.$buf = nl;
                        if (l &gt; 0) {
                            this._.textUpdated(this, true, offset, l, 0, 1);
                            return true;
                        }
                    }
                }
                return false;
            };

            this.remove = function(offset,size){
                if (size &gt; 0) {
                    var nl = this.$buf.substring(0, offset) +
                             this.$buf.substring(offset + size);

                    if (nl.length !== this.$buf.length &amp;&amp; (typeof this.validate !== &#x27;function&#x27; || this.validate(nl))) {
                        this.$buf = nl;
                        this._.textUpdated(this, false, offset, size, 0, 1);
                        return true;
                    }
                }
                return false;
            };

            this.setValue = function(text){
                if (typeof this.validate === &#x27;function&#x27; &amp;&amp; this.validate(text) === false) {
                    return false;
                }

                // cut to next line
                var i = text.indexOf(&#x27;\n&#x27;);
                if (i &gt;= 0) {
                    text = text.substring(0, i);
                }

                if ((this.$buf === null || this.$buf !== text) &amp;&amp; (typeof this.validate !== &#x27;function&#x27;  || this.validate(text))) {
                    if (this.$buf !== null &amp;&amp; this.$buf.length &gt; 0) {
                        this._.textUpdated(this, false, 0, this.$buf.length, 0, 1);
                    }

                    if (this.maxLen &gt; 0 &amp;&amp; text.length &gt; this.maxLen) {
                        text = text.substring(0, this.maxLen);
                    }

                    this.$buf = text;
                    this._.textUpdated(this, true, 0, text.length, 0, 1);
                    return true;
                }

                return false;
            };

            /**
             * Set the given maximal length the text can have
             * @method setMaxLength
             * @param  {Integer} max a maximal length of text
             */
            this.setMaxLength = function (max){
                if (max !== this.maxLen){
                    this.maxLen = max;
                    this.setValue(&quot;&quot;);
                }
            };

            /**
             *  Validate the given text. This method can be implemented to prevent
             *  inserting text in text model that doesn&#x27;t satisfy the given condition.
             *  For instance text can allow only numeric.
             *  @method validate
             *  @param {String} text a text
             *  @return {Boolean} return true if the text is valid otherwise return false
             */
        }
    ]);

    /**
     * List model class
     * @param  {Array} [a] an array the list model has to be initialized with
     * @example

          // create list model that contains three integer elements
          var l = new zebkit.data.ListModel([1,2,3]);
          l.on(&quot;elementInserted&quot;, function(list, element, index) {
              // handle list item inserted event
              ...
          })
          ...
          l.add(10)

     * @constructor
     * @class zebkit.data.ListModel
     * @uses zebkit.data.DataModel
     * @uses zebkit.EventProducer
     */

     /**
      * Fired when a new element has been added to the list model

         list.on(&quot;elementInserted&quot;, function(src, o, i) {
             ...
         });

      * @event elementInserted
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been added
      * @param {Integer} i an index at that the new element has been added
      */

     /**
      * Fired when an element has been removed from the list model

         list.on(&quot;elementRemoved&quot;, function(src, o, i) {
             ...
         });

      * @event elementRemoved
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been removed
      * @param {Integer} i an index at that the element has been removed
      */

     /**
      * Fired when an element has been re-set

         list.on(&quot;elementSet&quot;, function(src, o, p, i) {
             ...
         });

      * @event elementSet
      * @param {zebkit.data.ListModel} src a list model that triggers the event
      * @param {Object}  o an element that has been set
      * @param {Object}  p a previous element
      * @param {Integer} i an index at that the element has been re-set
      */

    pkg.ListModel = Class(pkg.DataModel, zebkit.EventProducer,[
        function() {
            this._ = new this.clazz.Listeners();
            this.$data = (arguments.length === 0) ? [] : arguments[0];
        },

        function $clazz () {
            this.Listeners = zebkit.util.ListenersClass(&quot;elementInserted&quot;, &quot;elementRemoved&quot;, &quot;elementSet&quot;);
        },

        function $prototype() {
            /**
             * Get an item stored at the given location in the list
             * @method get
             * @param  {Integer} i an item location
             * @return {object}  a list item
             */
            this.get = function(i) {
                if (i &lt; 0 || i &gt;= this.$data.length) {
                    throw new RangeError(i);
                }
                return this.$data[i];
            };

            /**
             * Add the given item to the end of the list
             * @method add
             * @param  {Object} o an item to be added
             */
            this.add = function(o) {
                this.$data.push(o);
                this._.elementInserted(this, o, this.$data.length - 1);
            };

            /**
             * Remove all elements from the list model
             * @method removeAll
             */
            this.removeAll = function() {
                var size = this.$data.length;
                for(var i = size - 1; i &gt;= 0; i--) {
                    this.removeAt(i);
                }
            };

            /**
             * Remove an element at the given location of the list model
             * @method removeAt
             * @param {Integer} i a location of an element to be removed from the list
             */
            this.removeAt = function(i) {
                var re = this.$data[i];
                this.$data.splice(i, 1);
                this._.elementRemoved(this, re, i);
            };

            /**
             * Remove the given element from the list
             * @method remove
             * @param {Object} o an element to be removed from the list
             */
            this.remove = function(o) {
                for(var i = 0;i &lt; this.$data.length; i++) {
                    if (this.$data[i] === o) {
                        this.removeAt(i);
                    }
                }
            };

            /**
             * Insert the given element into the given position of the list
             * @method insert
             * @param {Integer} i a position at which the element has to be inserted into the list
             * @param {Object} o an element to be inserted into the list
             */
            this.insert = function(i, o){
                if (i &lt; 0 || i &gt; this.$data.length) {
                    throw new RangeError(i);
                }
                this.$data.splice(i, 0, o);
                this._.elementInserted(this, o, i);
            };

            /**
             * Get number of elements stored in the list
             * @method count
             * @return {Integer} a number of element in the list
             */
            this.count = function () {
                return this.$data.length;
            };

            /**
             * Set the new element at the given position
             * @method setAt
             * @param  {Integer} i a position
             * @param  {Object} o a new element to be set as the list element at the given position
             * @return {Object}  previous element that was stored at the given position
             */
            this.setAt = function(i, o) {
                if (i &lt; 0 || i &gt;= this.$data.length) {
                    throw new RangeError(i);
                }
                var pe = this.$data[i];
                this.$data[i] = o;
                this._.elementSet(this, o, pe, i);
                return pe;
            };

            /**
             * Check if the element is in the list
             * @method contains
             * @param  {Object} o an element to be checked
             * @return {Boolean} true if the element is in the list
             */
            this.contains = function (o){
                return this.indexOf(o) &gt;= 0;
            };

            /**
             * Get position the given element is stored in the list
             * @method indexOf
             * @param  {Object} o an element
             * @return {Integer} the element position. -1 if the element cannot be found in the list
             */
            this.indexOf = function(o){
                return this.$data.indexOf(o);
            };
        }
    ]);

    /**
     * Tree model item class. The structure is used by tree model to store
     * tree items values, parent and children item references.
     * @class zebkit.data.Item
     * @param  {Object} [v] the item value
     * @constructor
     */
    pkg.Item = Class([
        function(v) {
            /**
             * Array of children items of the item element
             * @attribute kids
             * @type {Array}
             * @default []
             * @readOnly
             */
            this.kids = [];

            if (arguments.length &gt; 0) {
                this.value = v;
            }
        },

        function $prototype() {
            /**
             * Reference to a parent item
             * @attribute parent
             * @type {zebkit.data.Item}
             * @default null
             * @readOnly
             */
             this.parent = null;

             /**
              * The tree model item value. It is supposed the value should be updated
              * via execution of &quot;setValue(...)&quot; method of a tree model the item
              * belongs to.
              * @attribute value
              * @default null
              * @type {Object}
              * @readOnly
              */
             this.value = null;
        }
    ]).hashable();


    /**
     * Tree model class. The class is simple and handy way to keep hierarchical structure.
     *
     * @param  {zebkit.data.Item|Object} [r] a root item. As the argument you can pass &quot;zebkit.data.Item&quot; or
     * a JavaScript object. In the second case you can describe the tree as it is shown in example below:
     * @example

         // create tree model initialized with tree structure passed as
         // special formated JavaScript object. The tree will look as follow:
         //  &quot;Root&quot;
         //    |
         //    +--- &quot;Root kid 1&quot;
         //    +--- &quot;Root kid 2&quot;
         //            |
         //            +--- &quot;Kid of kid 2&quot;
         var tree = new zebkit.data.TreeModel({
            value:&quot;Root&quot;,
            kids: [
                &quot;Root kid 1&quot;,
                {
                    value: &quot;Root kid 2&quot;,
                    kids:  [ &quot;Kid of kid 2&quot;]
                }
            ]
         });
         ...
         // reg item modified events handler
         tree.on(&quot;itemModified&quot;, function(tree, item, prevValue) {
             // catch item value modification
             ...
         });

         // item value has to be updated via tree model API
         tree.setValue(tree.root.kids[0], &quot;new value&quot;);

     * @class zebkit.data.TreeModel
     * @uses zebkit.data.DataModel
     * @uses zebkit.EventProducer
     * @constructor
     */

    /**
     * Fired when the tree model item value has been updated.

     tree.on(&quot;itemModified&quot;, function(src, item, prevValue) {
         ...
     });

     * @event itemModified
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item whose value has been updated
     * @param {Object} prevValue a previous value the item has had
     */

    /**
     * Fired when the tree model item has been removed

     tree.on(&quot;itemRemoved&quot;, function(src, item) {
        ...
     });

     * @event itemRemoved
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item that has been removed from the tree model
     */

    /**
     * Fired when the tree model item has been inserted into the model

     tree.on(&quot;itemInserted&quot;, function(src, item) {{
        ...
     });

     * @event itemInserted
     * @param {zebkit.data.TreeModel} src a tree model that triggers the event
     * @param {zebkit.data.Item}  item an item that has been inserted into the tree model
     */
    pkg.TreeModel = Class(pkg.DataModel, zebkit.EventProducer, [
        function(r) {
            if (arguments.length === 0) {
                this.root = new pkg.Item();
            } else {
                this.root = zebkit.instanceOf(r, pkg.Item) ? r : this.clazz.create(r);
            }

            this._ = new this.clazz.Listeners();
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;itemModified&quot;, &quot;itemRemoved&quot;, &quot;itemInserted&quot;);

            /**
             * Create tree model item hierarchy by the given JavaScript object.
             * @param  {Object} r
             * @return {zebkit.data.Item} a built items hierarchy
             * @example
             *
             *      // create the following items hierarchy:
             *      //  &quot;Root&quot;
             *      //    +--- &quot;Kid 1&quot;
             *      //    |      +--- &quot;Kid 1.1&quot;
             *      //    |      |       +--- &quot;Kid 1.1.1&quot;
             *      //    |      +--- &quot;Kid 2.2&quot;
             *      //    +--- &quot;Kid 2&quot;
             *      //    |        +--- &quot;Kid 2.1&quot;
             *      //    |        +--- &quot;Kid 2.2&quot;
             *      //    |        +--- &quot;Kid 2.3&quot;
             *      //    +--- &quot;Kid 3&quot;
             *      //
             *      var rootItem = zebkit.data.TreeModel.create({
             *          value : &quot;Root&quot;,
             *          kids  : [
             *              {   value : &quot;Kid 1&quot;
             *                  kids  : [
             *                      {  value: &quot;Kid 1.1&quot;,
             *                         kids : &quot;Kid 1.1.1&quot;
             *                      },
             *                      &quot;Kid 2.2&quot;
             *                  ]
             *              },
             *              {   value: &quot;Kid 2&quot;,
             *                  kids : [&quot;Kid 2.1&quot;, &quot;Kid 2.2&quot;, &quot;Kid 2.3&quot;]
             *              },
             *              &quot;Kid 3&quot;
             *          ]
             *      });
             *
             * @static
             * @method create
             */
            this.create = function(r, p) {
                var item = new pkg.Item(r.hasOwnProperty(&quot;value&quot;)? r.value : r);
                item.parent = arguments.length &lt; 2 ? null : p;
                if (typeof r.kids !== &#x27;undefined&#x27; &amp;&amp; r.kids !== null) {
                    for(var i = 0; i &lt; r.kids.length; i++) {
                        item.kids[i] = this.create(r.kids[i], item);
                    }
                }
                return item;
            };

            /**
             * Find the first tree item (starting from the specified root item) whose value equals the given value.
             * @param  {zebkit.data.Item} root a root item of the tree
             * @param  {Object} value a value to evaluate
             * @return {zebkit.data.Item} a found tree item
             * @static
             * @method findOne
             */
            this.findOne = function(root, value) {
                var res = null;
                this.find(root, value, function(item) {
                    res = item;
                    return true;
                });
                return res;
            };

            /**
             * Find all items (starting from the specified root item) whose value equals the given value.
             * @param  {zebkit.data.Item} root a root item of the tree
             * @param  {Object} value a value to evaluate
             * @param  {Function} [cb] a callback method that is called for every tree item whose value matches
             * the specified one. The method gets the found item as its argument. The method can return true
             * if the tree traversing has to be interrupted.
             * @return {Array} a list of all found item whose value matches the specified one. The array is returned
             * only if no callback method has been passed to the method.
             * @example
             *
             *      // create tree items
             *      var rootItem = zebkit.data.TreeModel.create({
             *          value: &quot;Root&quot;,
             *          kids : [ &quot;Kid 1&quot;, &quot;Kid 2&quot;, &quot;Kid 1&quot;, &quot;Kid 3&quot;, &quot;Kid 1&quot; ]
             *      });
             *
             *      // find all items that have its value set to &quot;Kid 1&quot; and return
             *      // it as array
             *      var items = zebkit.data.TreeModel.find(rootItem, &quot;Kid 1&quot;);
             *
             *      // find the first two &quot;Kid 1&quot; item in the tree using callback
             *      var items = [];
             *      zebkit.data.TreeModel.find(rootItem, &quot;Kid 1&quot;, function(item) {
             *          items.push(item);
             *
             *          // stop the tree traversing as soon as we found two items
             *          return items.length &gt; 1;
             *      });
             *
             * @static
             * @method find
             */
            this.find = function(root, value, cb) {
                if (arguments.length &lt; 3) {
                    var res = [];
                    this.find(root, value, function(item) {
                        res.push(item);
                        return false;
                    });
                    return res;
                }

                if (root.value === value) {
                    if (cb.call(this, root) === true) {
                        return true;
                    }
                }

                if (typeof root.kids !== &#x27;undefined&#x27; &amp;&amp; root.kids !== null) {
                    for (var i = 0; i &lt; root.kids.length; i++) {
                        if (this.find(root.kids[i], value, cb)) {
                            return true;
                        }
                    }
                }
                return false;
            };

            this.print = function(root, render, shift) {
                if (zebkit.instanceOf(root, pkg.TreeModel)) {
                    root = root.root;
                }

                if (arguments.length &lt; 2) {
                    shift  = &quot;&quot;;
                    render = null;
                } else if (arguments.length === 2) {
                    if (zebkit.isString(render)) {
                        shift  = render;
                        render = null;
                    } else {
                        shift = &quot;&quot;;
                    }
                }

                var b = typeof root.kids !== &#x27;undefined&#x27; &amp;&amp; root.kids !== null;

                if (render !== null) {
                    render(root);
                }

                if (b) {
                    shift = shift + &quot;    &quot;;
                    for (var i = 0; i &lt; root.kids.length; i++) {
                        this.print(root.kids[i], render, shift);
                    }
                }
            };
        },

        function $prototype() {
            /**
             * Reference to the tree model root item
             * @attribute root
             * @type {zebkit.data.Item}
             * @readOnly
             */
            this.root = null;

            /**
             * Iterate over tree hierarchy starting from its root element
             * @param  {zebkit.data.Item} r a root element to start traversing the tree model
             * @param  {Function} f a callback function that is called for every tree item traversed item.
             * The callback gets tree model and the item as its arguments
             * @method iterate
             */
            this.iterate = function(r, f) {
                var res = f.call(this, r);
                if (res === 1 || res === 2) { //TODO: make it clear what is a mening of the res ?
                    return r;
                }

                for (var i = 0; i &lt; r.kids.length; i++) {
                    res = this.iterate(r.kids[i], f);
                    if (res === 2) {
                        return res;
                    }
                }
            };

            /**
             * Update a value of the given tree model item with the new one
             * @method setValue
             * @param  {zebkit.data.Item} item an item whose value has to be updated
             * @param  {Object} v   a new item value
             */
            this.setValue = function(item, v){
                var prev = item.value;
                item.value = v;
                this._.itemModified(this, item, prev);
            };

            /**
             * Add the new item to the tree model as a children element of the given parent item
             * @method add
             * @param  {zebkit.data.Item} [to] a parent item to which the new item has to be added.
             * If it has not been passed the node will be added to root.
             * @param  {Object|zebkit.data.Item} an item or value of the item to be
             * added to the parent item of the tree model
             */
            this.add = function(to,item) {
                if (arguments.length &lt; 2) {
                    to = this.root;
                }

                this.insert(to, item, to.kids.length);
            };

            /**
             * Insert the new item to the tree model as a children element at the
             * given position of the parent element
             * @method insert
             * @param  {zebkit.data.Item} to a parent item to which the new item
             * has to be inserted
             * @param  {Object|zebkit.data.Item} an item or value of the item to be
             * inserted to the parent item
             * @param  {Integer} i a position the new item has to be inserted into
             * the parent item
             */
            this.insert = function(to, item, i) {
                if (i &lt; 0 || to.kids.length &lt; i) {
                    throw new RangeError(i);
                }

                if (zebkit.isString(item)) {
                    item = new pkg.Item(item);
                }
                to.kids.splice(i, 0, item);
                item.parent = to;
                this._.itemInserted(this, item);

                // !!!
                // it is necessary to analyze if the inserted item has kids and
                // generate inserted event for all kids recursively
            };

            /**
             * Remove the given item from the tree model
             * @method remove
             * @param  {zebkit.data.Item} item an item to be removed from the tree model
             */
            this.remove = function(item){
                if (item === this.root) {
                    this.root = null;
                } else {
                    if (typeof item.kids !== &#x27;undefined&#x27;) {
                        for(var i = item.kids.length - 1; i &gt;= 0; i--) {
                            this.remove(item.kids[i]);
                        }
                    }
                    item.parent.kids.splice(item.parent.kids.indexOf(item), 1);
                }

                // preserve reference to parent when we call a listener
                try {
                    this._.itemRemoved(this, item);
                } catch(e) {
                    item.parent = null;
                    throw e;
                }
                item.parent = null;
            };

            /**
             * Remove all children items from the given item of the tree model
             * @method removeKids
             * @param  {zebkit.data.Item} item an item from that all children items have to be removed
             */
            this.removeKids = function(item) {
                for(var i = item.kids.length - 1; i &gt;= 0; i--) {
                    this.remove(item.kids[i]);
                }
            };
        }
    ]);

    /**
     *  Matrix model class.
     *  @constructor
     *  @param  {Array} [data] the given data as two dimensional array
     *  @param  {Integer} [rows] a number of rows
     *  @param  {Integer} [cols] a number of columns
     *  @class zebkit.data.Matrix
     *  @uses zebkit.EventProducer
     *  @uses zebkit.data.DataModel
     *  @example
     *
     *      // create matrix with 10 rows and 5 columns
     *      var matrix = zebkit.data.Matrix(10, 5);
     *
     *      matrix.get(0,0);
     *      matrix.put(0,0, &quot;Cell [0,0]&quot;);
     *
     *  @example
     *
     *      // create matrix with 3 rows and 5 columns
     *      var matrix = zebkit.data.Matrix([
     *          [ 0, 1, 2, 3, 4 ],  // row 0
     *          [ 0, 1, 2, 3, 4 ],  // row 1
     *          [ 0, 1, 2, 3, 4 ],  // row 2
     *          [ 0, 1, 2, 3, 4 ],  // row 3
     *          [ 0, 1, 2, 3, 4 ]   // row 4
     *      ]);
     *
     *  @example
     *
     *      // create matrix with 0 rows and 0 columns
     *      var matrix = zebkit.data.Matrix();
     *
     *      // setting value for cell (2, 4) will change
     *      // matrix size to 2 rows and 3 columns
     *      matrix.put(2, 4, &quot;Cell [row = 2, col = 4]&quot;);
     */

    /**
     * Fired when the matrix model size (number of rows or columns) is changed.

      matrix.on(&quot;matrixResized&quot;, function(src, pr, pc) {
          ...
      });

     * @event matrixResized
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  pr a previous number of rows
     * @param {Integer}  pc a previous number of columns
     */

    /**
     * Fired when the matrix model cell has been updated.

      matrix.on(&quot;cellModified&quot;, function(src, row, col, old) {
         ...
      });

     * @event cellModified
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  row an updated row
     * @param {Integer}  col an updated column
     * @param {Object}  old a previous cell value
     */

    /**
     * Fired when the matrix data has been re-ordered.

      matrix.on(&quot;matrixSorted&quot;, function(src, sortInfo) {
         ...
      });

     * @event matrixSorted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Object}  sortInfo a new data order info. The information
     * contains:
     *
     *      {
     *         func: sortFunction,
     *         name: sortFunctionName,
     *         col : sortColumn
     *      }
     *
     */

    /**
     * Fired when a row has been inserted into the matrix.

      matrix.on(&quot;matrixRowInserted&quot;, function(src, rowIndex) {
         ...
      });

     * @event matrixColInserted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  rowIndex a row that has been inserted
     * contains:
     */

    /**
     * Fired when a column has been inserted into the matrix.

      matrix.on(&quot;matrixColInserted&quot;, function(src, colIndex) {
         ...
      });

     * @event matrixColInserted
     * @param {zebkit.data.Matrix} src a matrix that triggers the event
     * @param {Integer}  colIndex a column that has been inserted
     * contains:
     */
    pkg.Matrix = Class(pkg.DataModel, zebkit.EventProducer, [
        function() {
            /**
             * Number of rows in the matrix model
             * @attribute rows
             * @type {Integer}
             * @readOnly
             */

            /**
             * Number of columns in the matrix model
             * @attribute cols
             * @type {Integer}
             * @readOnly
             */

            /**
             * The multi-dimensional embedded arrays to host matrix data
             * @attribute $objs
             * @type {Array}
             * @readOnly
             * @private
             */

            this._ = new this.clazz.Listeners();
            if (arguments.length === 1) {
                this.$objs = arguments[0];
                this.cols = (this.$objs.length &gt; 0) ? this.$objs[0].length : 0;
                this.rows = this.$objs.length;
            } else {
                this.$objs = [];
                this.rows = this.cols = 0;
                if (arguments.length &gt; 1) {
                    this.setRowsCols(arguments[0], arguments[1]);
                }
            }
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;matrixResized&quot;, &quot;cellModified&quot;,
                                                        &quot;matrixSorted&quot;,  &quot;matrixRowInserted&quot;,
                                                        &quot;matrixColInserted&quot;);
        },

        function $prototype() {
            /**
             * Get a matrix model cell value at the specified row and column
             * @method get
             * @param  {Integer} row a cell row
             * @param  {Integer} col a cell column
             * @return {Object}  matrix model cell value
             */
            this.get = function (row,col){
                if (row &lt; 0 || row &gt;= this.rows) {
                    throw new RangeError(row);
                }

                if (col &lt; 0 || col &gt;= this.cols) {
                    throw new RangeError(col);
                }

                return this.$objs[row] == null ? undefined : this.$objs[row][col];
            };

            /**
             * Get a matrix model cell value by the specified index
             * @method geti
             * @param  {Integer} index a cell index
             * @return {Object}  matrix model cell value
             */
            this.geti = function(i) {
                return this.get(Math.floor(i / this.cols), i % this.cols);
            };

            /**
             * Set the specified by row and column cell value. If the specified row or column
             * is greater than the matrix model has the model size will be adjusted to new one.
             * @method put
             * @param  {Integer} row a cell row
             * @param  {Integer} col a cell column
             * @param  {Object} obj a new cell value
             */
            this.put = function(row,col,obj){
                var nr = this.rows,
                    nc = this.cols;

                if (row &gt;= nr) {
                    nr += (row - nr + 1);
                }

                if (col &gt;= nc) {
                    nc += (col - nc + 1);
                }

                this.setRowsCols(nr, nc);
                var old = this.$objs[row] != null ? this.$objs[row][col] : undefined;
                if (obj !== old) {
                    // allocate array if no data for the given row exists
                    if (typeof this.$objs[row] === &#x27;undefined&#x27;) {
                        this.$objs[row] = [];
                    }
                    this.$objs[row][col] = obj;
                    this._.cellModified(this, row, col, old);
                }
            };

            /**
             * Set the specified by index cell value. The index identifies cell starting from [0,0]
             * cell till [rows,columns]. If the index is greater than size of model the model size
             * will be adjusted to new one.
             * @method puti
             * @param  {Integer} i a cell row
             * @param  {Object} obj a new cell value
             */
            this.puti = function(i, obj){
                this.put( Math.floor(i / this.cols),
                          i % this.cols, obj);
            };

            /**
             * Set the given number of rows and columns the model has to have.
             * @method setRowsCols
             * @param  {Integer} rows a new number of rows
             * @param  {Integer} cols a new number of columns
             */
            this.setRowsCols = function(rows, cols){
                if (rows !== this.rows || cols !== this.cols){
                    var pc = this.cols,
                        pr = this.rows;

                    this.cols = cols;
                    this.rows = rows;

                    // re-locate matrix space
                    if (this.$objs.length &gt; rows) {
                        this.$objs.length = rows;   // shrink number of rows
                    }

                    // shrink columns
                    if (pc &gt; cols) {
                        for(var i = 0; i &lt; this.$objs.length; i++) {
                            // check if data for columns has been allocated and the size
                            // is greater than set number of columns
                            if (typeof this.$objs[i] !== &#x27;undefined&#x27; &amp;&amp; this.$objs[i].length &gt; cols) {
                                this.$objs[i].length = cols;
                            }
                        }
                    }

                    this._.matrixResized(this, pr, pc);
                }
            };

             /**
             * Set the given number of rows the model has to have.
             * @method setRows
             * @param  {Integer} rows a new number of rows
             */
            this.setRows = function(rows) {
                this.setRowsCols(rows, this.cols);
            };

            /**
             * Set the given number of columns the model has to have.
             * @method setCols
             * @param  {Integer} cols a new number of columns
             */
            this.setCols = function(cols) {
                this.setRowsCols(this.rows, cols);
            };

            /**
             * Remove specified number of rows from the model starting
             * from the given row.
             * @method removeRows
             * @param  {Integer} begrow a start row
             * @param  {Integer} count  a number of rows to be removed
             */
            this.removeRows = function(begrow,count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                if (begrow &lt; 0 || begrow + count &gt; this.rows) {
                    throw new RangeError(begrow);
                }

                this.$objs.splice(begrow, count);
                this.rows -= count;
                this._.matrixResized(this, this.rows + count, this.cols);
            };

            /**
             * Remove specified number of columns from the model starting
             * from the given column.
             * @method removeCols
             * @param  {Integer}  begcol a start column
             * @param  {Integer} count  a number of columns to be removed
             */
            this.removeCols = function (begcol,count){
                if (arguments.length === 1) {
                    count = 1;
                }

                if (begcol &lt; 0 || begcol + count &gt; this.cols) {
                    throw new RangeError(begcol);
                }

                for(var i = 0; i &lt; this.$objs.length; i++) {
                    if (this.$objs[i] != null &amp;&amp; this.$objs[i].length &gt; 0) {
                        this.$objs[i].splice(begcol, count);
                    }
                }

                this.cols -= count;
                this._.matrixResized(this, this.rows, this.cols + count);
            };

            /**
             * Insert the given number of rows at the specified row
             * @param  {Integer} row   a starting row to insert
             * @param  {Integer} count a number of rows to be added
             * @method insertRows
             */
            this.insertRows = function(row, count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                var i = 0;
                if (row &lt;= this.$objs.length - 1) {
                    for(i = 0; i &lt; count; i++) {
                        this.$objs.splice(row, 0, undefined);
                        this._.matrixRowInserted(this, row + i);
                    }
                } else {
                    for(i = 0; i &lt; count; i++) {
                        this._.matrixRowInserted(this, row + i);
                    }
                }

                this.rows += count;
                this._.matrixResized(this, this.rows - count, this.cols);
            };

            /**
             * Insert the given number of columns at the specified column
             * @param  {Integer} col   a starting column to insert
             * @param  {Integer} count a number of columns to be added
             * @method insertCols
             */
            this.insertCols = function(col, count) {
                if (arguments.length === 1) {
                    count = 1;
                }

                if (this.$objs.length  &gt; 0) {
                    for(var j = 0; j &lt; count; j++) {
                        for(var i = 0; i &lt; this.rows; i++) {
                            if (this.$objs[i] != null &amp;&amp; j &lt;= this.$objs[i].length) {
                                this.$objs[i].splice(col, 0, undefined);
                            }
                        }
                        this._.matrixColInserted(this, col + j);
                    }
                }

                this.cols += count;
                this._.matrixResized(this, this.rows, this.cols - count);
            };

            /**
             * Sort the given column of the matrix model.
             * @param  {Integer} col a column to be re-ordered
             * @param  {Function} [f] an optional sort function. The name of the function
             * is grabbed to indicate type of the sorting the method does. For instance:
             * &quot;descent&quot;, &quot;ascent&quot;.
             * @method sortCol
             */
            this.sortCol = function(col, f) {
                if (arguments.length &lt; 2) {
                    f = pkg.descent;
                }

                this.$objs.sort(function(a, b) {
                    return f(a[col], b[col]);
                });

                this._.matrixSorted(this, { col : col,
                                            func: f,
                                            name: zebkit.$FN(f).toLowerCase() });
            };
        }
    ]);
});
zebkit.package(&quot;layout&quot;, function(pkg, Class) {
    /**
     * Layout package provides number of classes, interfaces, methods and variables that allows
     * developers easily implement rules based layouting of hierarchy of rectangular elements.
     * The package has no relation to any concrete UI, but it can be applied to a required UI
     * framework very easily. In general layout manager requires an UI component to provide:
     *    - **setLocation(x,y)** method
     *    - **setSize(w,h)** method
     *    - **setBounds()** method
     *    - **getPreferredSize(x,y)** method
     *    - **getTop(), getBottom(), getRight(), getLeft()** methods
     *    - **constraints** read only property
     *    - **width, height, x, y** read only metrics properties
     *    - **kids** read only property that keep all children components
     *
     * @access package
     * @class zebkit.layout
     */

     /**
      * Find a direct children element for the given children component
      * and the specified parent component
      * @param  {zebkit.layout.Layoutable} parent  a parent component
      * @param  {zebkit.layout.Layoutable} child  a children component
      * @return {zebkit.layout.Layoutable}  a direct children component
      * @method getDirectChild
      * @for  zebkit.layout
      */
    pkg.getDirectChild = function(parent, child) {
        for(; child !== null &amp;&amp; child.parent !== parent; child = child.parent) {}
        return child;
    };

    /**
     * Layout manager interface is simple interface that all layout managers have to
     * implement. One method has to calculate preferred size of the given component and
     * another one method has to perform layouting of children components of the given
     * target component.
     * @class zebkit.layout.Layout
     * @interface zebkit.layout.Layout
     */

    /**
     * Calculate preferred size of the given component
     * @param {zebkit.layout.Layoutable} t a target layoutable component
     * @method calcPreferredSize
     */

    /**
     * Layout children components of the specified layoutable target component
     * @param {zebkit.layout.Layoutable} t a target layoutable component
     * @method doLayout
     */
    pkg.Layout = new zebkit.Interface([
        &quot;abstract&quot;,
            function doLayout(target) {},
            function calcPreferredSize(target) {}
    ]);

    /**
     * Find a direct component located at the given location of the specified parent component
     * and the specified parent component
     * @param  {Integer} x a x coordinate relatively to the parent component
     * @param  {Integer} y a y coordinate relatively to the parent component
     * @param  {zebkit.layout.Layoutable} parent  a parent component
     * @return {zebkit.layout.Layoutable} an index of direct children component
     * or -1 if no a children component can be found
     * @method getDirectAt
     * @for  zebkit.layout
     */
    pkg.getDirectAt = function(x, y, p){
        for(var i = 0;i &lt; p.kids.length; i++){
            var c = p.kids[i];
            if (c.isVisible === true &amp;&amp; c.x &lt;= x &amp;&amp; c.y &lt;= y &amp;&amp; c.x + c.width &gt; x &amp;&amp; c.y + c.height &gt; y) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Get a top (the highest in component hierarchy) parent component
     * of the given component
     * @param  {zebkit.layout.Layoutable} c a component
     * @return {zebkit.layout.Layoutable}  a top parent component
     * @method getTopParent
     * @for  zebkit.layout
     */
    pkg.getTopParent = function(c){
        for(; c !== null &amp;&amp; c.parent !== null; c = c.parent) {}
        return c;
    };

    /**
     * Translate the given relative location into the parent relative location.
     * @param  {Integer} [x] a x coordinate relatively  to the given component
     * @param  {Integer} [y] a y coordinate relatively  to the given component
     * @param  {zebkit.layout.Layoutable} c a component
     * @param  {zebkit.layout.Layoutable} [p] a parent component
     * @return {Object} a relative to the given parent UI component location:

            { x:{Integer}, y:{Integer} }

     * @method toParentOrigin
     * @for  zebkit.layout
     */
    pkg.toParentOrigin = function(x,y,c,p){
        if (arguments.length === 1) {
            c = x;
            x = y = 0;
            p = null;
        } else if (arguments.length &lt; 4) {
            p = null;
        }

        while (c !== null &amp;&amp; c !== p) {
            x += c.x;
            y += c.y;
            c = c.parent;
        }

        if (c === null) {
            //throw new Error(&quot;Invalid params&quot;);
        }

        return { x:x, y:y };
    };

    /**
     * Convert the given component location into relative
     * location of the specified children component successor.
     * @param  {Integer} x a x coordinate relatively to the given
     * component
     * @param  {Integer} y a y coordinate relatively to the given
     * component
     * @param  {zebkit.layout.Layoutable} p a component
     * @param  {zebkit.layout.Layoutable} c a children successor component
     * @return {Object} a relative location
     *
     *      { x:{Integer}, y:{Integer} }
     *
     * @method toChildOrigin
     * @for  zebkit.layout
     */
    pkg.toChildOrigin = function(x, y, p, c){
        while(c !== p){
            x -= c.x;
            y -= c.y;
            c = c.parent;
        }
        return { x:x, y:y };
    };

    /**
     * Calculate maximal preferred width and height of
     * children component of the given target component.
     * @param  {zebkit.layout.Layoutable} target a target component
     * @return {Object} a maximal preferred width and height

            { width:{Integer}, height:{Integer} }

     * @method getMaxPreferredSize
     * @for zebkit.layout
     */
    pkg.getMaxPreferredSize = function(target) {
        var maxWidth  = 0,
            maxHeight = 0;

        for(var i = 0;i &lt; target.kids.length; i++) {
            var l = target.kids[i];
            if (l.isVisible === true){
                var ps = l.getPreferredSize();
                if (ps.width &gt; maxWidth) {
                    maxWidth = ps.width;
                }

                if (ps.height &gt; maxHeight) {
                    maxHeight = ps.height;
                }
            }
        }
        return { width: maxWidth, height: maxHeight };
    };


    /**
     * Test if the given parent component is ancestor of the specified component.
     * @param  {zebkit.layout.Layoutable}  p a parent component
     * @param  {zebkit.layout.Layoutable}  c a component
     * @return {Boolean} true if the given parent is ancestor of the specified component
     * @for  zebkit.layout
     * @method  isAncestorOf
     */
    pkg.isAncestorOf = function(p, c){
        for(; c !== null &amp;&amp; c !== p; c = c.parent) {}
        return c !== null;
    };

    /**
     * Layoutable class defines rectangular component that has elementary metrical properties like width,
     * height and location and can be a participant of layout management process. Layoutable component is
     * container that can contains other layoutable component as its children. The children components are
     * ordered by applying a layout manager of its parent component.
     * @class zebkit.layout.Layoutable
     * @constructor
     * @uses zebkit.layout.Layout
     * @uses zebkit.EventProducer
     * @uses zebkit.util.PathSearch
     */
    pkg.Layoutable = Class(pkg.Layout, zebkit.EventProducer, zebkit.util.PathSearch, [
        function() {
            /**
             *  Reference to children components
             *  @attribute kids
             *  @type {Array}
             *  @default empty array
             *  @readOnly
             */
            this.kids = [];

            /**
            * Layout manager that is used to order children layoutable components
            * @attribute layout
            * @default itself
            * @readOnly
            * @type {zebkit.layout.Layout}
            */
            this.layout = this;
        },

        function $prototype() {
            /**
             * x coordinate
             * @attribute x
             * @default 0
             * @readOnly
             * @type {Integer}
             */

            /**
            * y coordinate
            * @attribute y
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Width of rectangular area
            * @attribute width
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Height of rectangular area
            * @attribute height
            * @default 0
            * @readOnly
            * @type {Integer}
            */

            /**
            * Indicate a layoutable component visibility
            * @attribute isVisible
            * @default true
            * @readOnly
            * @type {Boolean}
            */

            /**
            * Indicate a layoutable component validity
            * @attribute isValid
            * @default false
            * @readOnly
            * @type {Boolean}
            */

            /**
            * Reference to a parent layoutable component
            * @attribute parent
            * @default null
            * @readOnly
            * @type {zebkit.layout.Layoutable}
            */

            this.x = this.y = this.height = this.width = this.cachedHeight = 0;

            this.psWidth = this.psHeight = this.cachedWidth = -1;
            this.isLayoutValid = this.isValid = false;

            this.layout = null;

            /**
             * The component layout constraints. The constraints is specific to
             * the parent component layout manager value that customizes the
             * children component layouting on the parent component.
             * @attribute constraints
             * @default null
             * @type {Object}
             */
            this.constraints = this.parent = null;
            this.isVisible = true;

            this.$matchPath = function(node, name) {
                if (name[0] === &#x27;~&#x27;) {
                    return typeof node.clazz !== &#x27;undefined&#x27; &amp;&amp;
                           node.clazz !== null &amp;&amp;
                           zebkit.instanceOf(node, zebkit.Class.forName(name.substring(1)));
                } else {
                    return typeof node.clazz.$name !== &quot;undefined&quot; &amp;&amp;
                           node.clazz.$name === name;
                }
            };

            /**
             * Set the given id for the component
             * @param {String} id an ID to be set
             * @method setId
             * @chainable
             */
            this.setId = function(id) {
                this.id = id;
                return this;
            };

            /**
             * Apply the given set of properties to the given component or a number of children
             * its components.
             * @example
             *
             *     var c = new zebkit.layout.Layoutable();
             *     c.properties({
             *         width: [100, 100],
             *         location: [10,10],
             *         layout: new zebkit.layout.BorderLayout()
             *     })
             *
             *     c.add(new zebkit.layout.Layoutable()).add(zebkit.layout.Layoutable())
             *                                          .add(zebkit.layout.Layoutable());
             *     c.properties(&quot;//*&quot;, {
             *         size: [100, 200]
             *     });
             *
             * @param  {String} [path]  a path to find children components
             * @param  {Object} props a dictionary of properties to be applied
             * @return {zebkit.ui.Layoutable} a component itself
             * @chainable
             * @method properties
             */
            this.properties = function(path, props) {
                if (arguments.length === 1) {
                    return zebkit.properties(this, path);
                }

                this.byPath(path, function(kid) {
                    zebkit.properties(kid, props);
                });
                return this;
            };

            /**
             * Set the given property to the component or children component
             * specified by the given path (optionally).
             * @param  {String} [path]  a path to find children components
             * @param  {String} name a property name
             * @param  {object} value a property value
             * @chainable
             * @method property
             */
            this.property = function() {
                var p = {};
                if (arguments.length &gt; 2) {
                    p[arguments[1]] = arguments[2];
                    return this.properties(arguments[0], p);
                } else {
                    p[arguments[0]] = arguments[1];
                    return this.properties(p);
                }
            };

            /**
             * Validate the component metrics. The method is called as a one step of the component validation
             * procedure. The method causes &quot;recalc&quot; method execution if the method has been implemented and
             * the component is in invalid state. It is supposed the &quot;recalc&quot; method has to be implemented by
             * a component as safe place where the component metrics can be calculated. Component metrics is
             * individual for the given component properties that has influence to the component preferred
             * size value. In many cases the properties calculation has to be minimized what can be done by
             * moving the calculation in &quot;recalc&quot; method
             * @method validateMetric
             * @protected
             */
            this.validateMetric = function(){
                if (this.isValid === false) {
                    if (typeof this.recalc === &#x27;function&#x27;) {
                        this.recalc();
                    }
                    this.isValid = true;
                }
            };

            /**
             * By default there is no any implementation of &quot;recalc&quot; method in the layoutable component. In other
             * words the method doesn&#x27;t exist. Developer should implement the method if the need a proper and
             * efficient place  to calculate component properties that have influence to the component preferred
             * size. The &quot;recalc&quot; method is called only when it is really necessary to compute the component metrics.
             * @method recalc
             * @protected
             */

            /**
             * Invalidate the component layout. Layout invalidation means the component children components have to
             * be placed with the component layout manager. Layout invalidation causes a parent component layout is
             * also invalidated.
             * @method invalidateLayout
             * @protected
             */
            this.invalidateLayout = function(){
                this.isLayoutValid = false;
                if (this.parent !== null) {
                    this.parent.invalidateLayout();
                }
            };

            /**
             * Invalidate component layout and metrics.
             * @method invalidate
             */
            this.invalidate = function(){
                this.isLayoutValid = this.isValid  = false;
                this.cachedWidth = -1;
                if (this.parent !== null) {
                    this.parent.invalidate();
                }
            };

            /**
             * Force validation of the component metrics and layout if it is not valid
             * @method validate
             */
            this.validate = function() {
                if (this.isValid === false) {
                    this.validateMetric();
                }

                if (this.width &gt; 0 &amp;&amp; this.height &gt; 0 &amp;&amp;
                    this.isLayoutValid === false &amp;&amp;
                    this.isVisible === true)
                {
                    this.layout.doLayout(this);
                    for (var i = 0; i &lt; this.kids.length; i++) {
                        this.kids[i].validate();
                    }
                    this.isLayoutValid = true;
                    if (typeof this.laidout !== &#x27;undefined&#x27;) {
                        this.laidout();
                    }
                }
            };

            /**
             * The method can be implemented to be informed every time the component has completed to layout
             * its children components
             * @method laidout
             */

            /**
             * Get preferred size. The preferred size includes  top, left, bottom and right paddings and
             * the size the component wants to have
             * @method getPreferredSize
             * @return {Object} return size object the component wants to
             * have as the following structure:

             {width:{Integer}, height:{Integer}} object

             */
            this.getPreferredSize = function(){
                this.validateMetric();

                if (this.cachedWidth &lt; 0) {
                    var ps = (this.psWidth &lt; 0 || this.psHeight &lt; 0) ? this.layout.calcPreferredSize(this)
                                                                     : { width:0, height:0 };

                    ps.width  = this.psWidth  &gt;= 0 ? this.psWidth
                                                   : ps.width  + this.getLeft() + this.getRight();
                    ps.height = this.psHeight &gt;= 0 ? this.psHeight
                                                   : ps.height + this.getTop()  + this.getBottom();
                    this.cachedWidth  = ps.width;
                    this.cachedHeight = ps.height;
                    return ps;
                }
                return { width:this.cachedWidth,
                         height:this.cachedHeight };
            };

            /**
             * Get top padding.
             * @method getTop
             * @return {Integer} top padding in pixel
             */
            this.getTop = function ()  { return 0; };

            /**
             * Get left padding.
             * @method getLeft
             * @return {Integer} left padding in pixel
             */
            this.getLeft = function ()  { return 0; };

            /**
             * Get bottom padding.
             * @method getBottom
             * @return {Integer} bottom padding in pixel
             */
            this.getBottom = function ()  { return 0; };

            /**
             * Get right padding.
             * @method getRight
             * @return {Integer} right padding in pixel
             */
            this.getRight = function ()  { return 0; };

            /**
             * Set the parent component.
             * @protected
             * @param {zebkit.layout.Layoutable} o a parent component
             * @method setParent
             * @protected
             */
            this.setParent = function(o) {
                if (o !== this.parent){
                    this.parent = o;
                    this.invalidate();
                }
            };

            /**
             * Set the given layout manager that is used to place
             * children component. Layout manager is simple class
             * that defines number of rules concerning the way
             * children components have to be ordered on its parent
             * surface.
             * @method setLayout
             * @param {zebkit.ui.Layout} m a layout manager
             * @chainable
             */
            this.setLayout = function (m){
                if (m === null || typeof m === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Null layout&quot;);
                }

                if (this.layout !== m){
                    this.layout = m;
                    this.invalidate();
                }

                return this;
            };

            /**
             * Internal implementation of the component preferred size calculation.
             * @param  {zebkit.layout.Layoutable} target a component for that the metric has to be calculated
             * @return {Object} a preferred size. The method always
             * returns { width:10, height:10 } as the component preferred
             * size
             * @private
             * @method calcPreferredSize
             */
            this.calcPreferredSize = function (target){
                return { width:10, height:10 };
            };

            /**
             * By default layoutbable component itself implements layout manager to order its children
             * components. This method implementation does nothing, so children component will placed
             * according locations and sizes they have set.
             * @method doLayout
             * @private
             */
            this.doLayout = function (target) {};

            /**
             * Detect index of a children component.
             * @param  {zebkit.ui.Layoutbale} c a children component
             * @method indexOf
             * @return {Integer}
             */
            this.indexOf = function (c){
                return this.kids.indexOf(c);
            };

            /**
             * Insert the new children component at the given index with the specified layout constraints.
             * The passed constraints can be set via a layoutable component that is inserted. Just
             * set &quot;constraints&quot; property of in inserted component.
             * @param  {Integer} i an index at that the new children component has to be inserted
             * @param  {Object} constr layout constraints of the new children component
             * @param  {zebkit.layout.Layoutbale} d a new children layoutable component to be added
             * @return {zebkit.layout.Layoutable} an inserted children layoutable component
             * @method insert
             */
            this.insert = function(i, constr, d){
                if (d.constraints !== null) {
                    constr = d.constraints;
                } else {
                    d.constraints = constr;
                }

                if (i === this.kids.length) {
                    this.kids.push(d);
                } else {
                    this.kids.splice(i, 0, d);
                }
                d.setParent(this);

                if (typeof this.kidAdded !== &#x27;undefined&#x27;) {
                    this.kidAdded(i, constr, d);
                }
                this.invalidate();
                return d;
            };

            /**
             * The method can be implemented to be informed every time a new component
             * has been inserted into the component
             * @param  {Integer} i an index at that the new children component has been inserted
             * @param  {Object} constr layout constraints of the new children component
             * @param  {zebkit.layout.Layoutbale} d a new children layoutable component that has
             * been added
             * @method kidAdded
             */

            /**
             * Set the layoutable component location. Location is x, y coordinates relatively to
             * a parent component
             * @param  {Integer} xx x coordinate relatively to the layoutable component parent
             * @param  {Integer} yy y coordinate relatively to the layoutable component parent
             * @method setLocation
             * @chainable
             */
            this.setLocation = function (xx,yy){
                if (xx !== this.x || this.y !== yy) {
                    var px = this.x, py = this.y;
                    this.x = xx;
                    this.y = yy;
                    if (typeof this.relocated !== &#x27;undefined&#x27;) {
                        this.relocated(px, py);
                    }
                }
                return this;
            };

            /**
             * The method can be implemented to be informed every time the component
             * has been moved
             * @param  {Integer} px x previous coordinate of moved children component
             * @param  {Integer} py y previous coordinate of moved children component
             * @method relocated
             */


            /**
             * Set the layoutable component bounds. Bounds defines the component location and size.
             * @param  {Integer} x x coordinate relatively to the layoutable component parent
             * @param  {Integer} y y coordinate relatively to the layoutable component parent
             * @param  {Integer} w a width of the component
             * @param  {Integer} h a height of the component
             * @method setBounds
             * @chainable
             */
            this.setBounds = function (x, y, w, h){
                this.setLocation(x, y);
                this.setSize(w, h);
                return this;
            };

            /**
             * Set the layoutable component size.
             * @param  {Integer} w a width of the component
             * @param  {Integer} h a height of the component
             * @method setSize
             * @chainable
             */
            this.setSize = function (w,h){
                if (w !== this.width || h !== this.height){
                    var pw = this.width, ph = this.height;
                    this.width = w;
                    this.height = h;
                    this.isLayoutValid = false;
                    if (typeof this.resized !== &#x27;undefined&#x27;) {
                        this.resized(pw, ph);
                    }
                }
                return this;
            };

            /**
             * The method can be implemented to be informed every time the component
             * has been resized
             * @param  {Integer} w a previous width of the component
             * @param  {Integer} h a previous height of the component
             * @method resized
             */

            /**
             * Get a children layoutable component by the given path (optionally)
             * and the specified constraints.
             * @param  {String} [p] a path.
             * @param  {zebkit.layout.Layoutable} c a constraints
             * @return {zebkit.layout.Layoutable} a children component
             * @method byConstraints
             */
            this.byConstraints = function(constr) {
                if (arguments.length === 2) {
                    var res = null;
                    constr = arguments[1];
                    this.byPath(arguments[0], function(kid) {
                        if (kid.constraints === constr) {
                            res = kid;
                            return true;
                        } else {
                            return false;
                        }
                    });
                    return res;
                } else {
                    if (this.kids.length &gt; 0){
                        for(var i = 0; i &lt; this.kids.length; i++ ){
                            var l = this.kids[i];
                            if (constr === l.constraints) {
                                return l;
                            }
                        }
                    }
                    return null;
                }
            };

            /**
             * Set the component constraints without invalidating the component and its parents components
             * layouts and metrics. It is supposed to be used for internal use
             * @protected
             * @param {Object} c a constraints
             * @chainable
             * @method $setConstraints
             */
            this.$setConstraints = function(c) {
                this.constraints = c;
                return this;
            };

            /**
             * Remove the given children component.
             * @param {zebkit.layout.Layoutable} c a children component to be removed
             * @method remove
             * @return {zebkit.layout.Layoutable} a removed children component
             */
            this.remove = function(c) {
                return this.removeAt(this.kids.indexOf(c));
            };

            /**
             * Remove a children component at the specified position.
             * @param {Integer} i a children component index at which it has to be removed
             * @method removeAt
             * @return {zebkit.layout.Layoutable} a removed children component
             */
            this.removeAt = function (i){
                var obj = this.kids[i];
                obj.setParent(null);
                if (obj.constraints !== null) {
                    obj.constraints = null;
                }

                this.kids.splice(i, 1);

                if (typeof this.kidRemoved !== &#x27;undefined&#x27;) {
                    this.kidRemoved(i, obj);
                }

                this.invalidate();
                return obj;
            };

            /**
             * Remove the component from its parent if it has a parent
             * @method removeMe
             */
            this.removeMe = function() {
                var i = -1;
                if (this.parent !== null &amp;&amp; (i = this.parent.indexOf(this)) &gt;= 0) {
                    this.parent.removeAt(i);
                }
            };

            /**
             * The method can be implemented to be informed every time a children component
             * has been removed
             * @param {Integer} i a children component index at which it has been removed
             * @param  {zebkit.layout.Layoutable} c a children component that has been removed
             * @method kidRemoved
             */

            /**
             * Set the specified preferred size the component has to have. Component preferred size is
             * important thing that is widely used to layout the component. Usually the preferred
             * size is calculated by a concrete component basing on its metrics. For instance, label
             * component calculates its preferred size basing on text size. But if it is required
             * the component preferred size can be fixed with the desired value.
             * @param  {Integer} w a preferred width. Pass &quot;-1&quot; as the
             * argument value to not set preferred width
             * @param  {Integer} h a preferred height. Pass &quot;-1&quot; as the
             * argument value to not set preferred height
             * @chainable
             * @method setPreferredSize
             */
            this.setPreferredSize = function(w, h) {
                // if (arguments.length === 1) {
                //     h = w;
                // }

                if (w !== this.psWidth || h !== this.psHeight){
                    this.psWidth  = w;
                    this.psHeight = h;
                    this.invalidate();
                }
                return this;
            };

            /**
             * Replace a children component at the specified index
             * with the given new children component
             * @param  {Integer} i an index of a children component to be replaced
             * @param  {zebkit.layout.Layoutable} d a new children
             * @return {zebkit.layout.Layoutable} a previous component that has
             * been re-set with the new one
             * @method setAt
             */
            this.setAt = function(i, d) {
                var constr = this.kids[i].constraints,
                    pd     = this.removeAt(i);

                if (d !== null) {
                    this.insert(i, constr, d);
                }
                return pd;
            };

            /**
             * Set the component by the given constraints or add new one with the given constraints
             * @param {Object} constr a layout constraints
             * @param {zebkit.layout.Layoutable} c a component to be added
             * @return {zebkit.layout.Layoutable} a previous component that has
             * been re-set with the new one
             * @method setByConstraints
             */
            this.setByConstraints = function(constr, c) {
                var prev = this.byConstraints(constr);
                if (prev === null) {
                    return this.add(constr, c);
                } else {
                    return this.setAt(this.indexOf(prev), c);
                }
            };

            /**
             * Add the new children component with the given constraints
             * @param  {Object} constr a constraints of a new children component
             * @param  {zebkit.layout.Layoutable} d a new children component to
             * be added
             * @method add
             * @return {zebkit.layout.Layoutable} added layoutable component
             */
            this.add = function(constr,d) {
                return (arguments.length === 1) ? this.insert(this.kids.length, null, constr)
                                                : this.insert(this.kids.length, constr, d);
            };
        }
    ]);

    /**
     *  Layout manager implementation that places layoutbale components on top of
     *  each other stretching its to fill all available parent component space.
     *  Components that want to have be sized according to its preferred sizes
     *  have to have its constraints set to &quot;usePsSize&quot;.
     *  @example
     *
     *      var pan = new zebkit.ui.Panel();
     *      pan.setLayout(new zebkit.ui.StackLayout());
     *
     *      // label component will be stretched over all available pan area
     *      pan.add(new zebkit.ui.Label(&quot;A&quot;));
     *
     *      // button component will be sized according to its preferred size
     *      // and aligned to have centered vertical and horizontal alignments
     *      pan.add(new zebkit.ui.Button(&quot;Ok&quot;).setConstraints(&quot;usePsSize&quot;));
     *
     *
     *  @class zebkit.layout.StackLayout
     *  @uses zebkit.layout.Layout
     *  @constructor
     */
    pkg.StackLayout = Class(pkg.Layout, [
        function $prototype() {
            this.calcPreferredSize = function (target){
                return pkg.getMaxPreferredSize(target);
            };

            this.doLayout = function(t){
                var top  = t.getTop(),
                    hh   = t.height - t.getBottom() - top,
                    left = t.getLeft(),
                    ww   = t.width - t.getRight() - left;

                for(var i = 0;i &lt; t.kids.length; i++){
                    var l = t.kids[i];
                    if (l.isVisible === true) {
                        var ctr = l.constraints === null ? null : l.constraints;

                        if (ctr === &quot;usePsSize&quot;) {
                            var ps = l.getPreferredSize();
                            l.setBounds(left + Math.floor((ww - ps.width )/2),
                                        top  + Math.floor((hh - ps.height)/2),
                                        ps.width, ps.height);
                        } else {
                            l.setBounds(left, top, ww, hh);
                        }
                    }
                }
            };
        }
    ]);

    /**
     *  Layout manager implementation that logically splits component area into five areas: top, bottom,
     *  left, right and center. Top and bottom components are stretched to fill all available space
     *  horizontally and are sized to have preferred height horizontally. Left and right components are
     *  stretched to fill all available space vertically and are sized to have preferred width vertically.
     *  Center component is stretched to occupy all available space taking in account top, left, right
     *  and bottom components.
     *
     *      // create panel with border layout
     *      var p = new zebkit.ui.Panel(new zebkit.layout.BorderLayout());
     *
     *      // add children UI components with top, center and left constraints
     *      p.add(&quot;top&quot;,    new zebkit.ui.Label(&quot;Top&quot;));
     *      p.add(&quot;center&quot;, new zebkit.ui.Label(&quot;Center&quot;));
     *      p.add(&quot;left&quot;,   new zebkit.ui.Label(&quot;Left&quot;));
     *
     *
     * Construct the layout with the given vertical and horizontal gaps.
     * @param  {Integer} [hgap] horizontal gap. The gap is a horizontal distance between laid out components
     * @param  {Integer} [vgap] vertical gap. The gap is a vertical distance between laid out components
     * @constructor
     * @class zebkit.layout.BorderLayout
     * @uses zebkit.layout.Layout
     */
    pkg.BorderLayout = Class(pkg.Layout, [
        function(hgap,vgap){
            if (arguments.length &gt; 0) {
                this.hgap = this.vgap = hgap;
                if (arguments.length &gt; 1) {
                    this.vgap = vgap;
                }
            }
        },

        function $prototype() {
            /**
             * Horizontal gap (space between components)
             * @attribute hgap
             * @default 0
             * @readOnly
             * @type {Integer}
             */

            /**
             * Vertical gap (space between components)
             * @attribute vgap
             * @default 0
             * @readOnly
             * @type {Integer}
             */
            this.hgap = this.vgap = 0;

            this.calcPreferredSize = function (target){
                var center = null, left = null,  right = null, top = null, bottom = null, d = null;
                for(var i = 0; i &lt; target.kids.length; i++){
                    var l = target.kids[i];
                    if (l.isVisible === true){
                        switch(l.constraints) {
                           case null:
                           case undefined:
                           case &quot;center&quot;    : center = l; break;
                           case &quot;top&quot;       : top    = l; break;
                           case &quot;bottom&quot;    : bottom = l; break;
                           case &quot;left&quot;      : left   = l; break;
                           case &quot;right&quot;     : right  = l; break;
                           default: throw new Error(&quot;Invalid constraints: &quot; + l.constraints);
                        }
                    }
                }

                var dim = { width:0, height:0 };
                if (right !== null) {
                    d = right.getPreferredSize();
                    dim.width  = d.width + this.hgap;
                    dim.height = (d.height &gt; dim.height ? d.height: dim.height );
                }

                if (left !== null) {
                    d = left.getPreferredSize();
                    dim.width += d.width + this.hgap;
                    dim.height = d.height &gt; dim.height ? d.height : dim.height;
                }

                if (center !== null) {
                    d = center.getPreferredSize();
                    dim.width += d.width;
                    dim.height = d.height &gt; dim.height ? d.height : dim.height;
                }

                if (top !== null) {
                    d = top.getPreferredSize();
                    dim.width = d.width &gt; dim.width ? d.width : dim.width;
                    dim.height += d.height + this.vgap;
                }

                if (bottom !== null) {
                    d = bottom.getPreferredSize();
                    dim.width = d.width &gt; dim.width ? d.width : dim.width;
                    dim.height += d.height + this.vgap;
                }
                return dim;
            };

            this.doLayout = function(target){
                var t      = target.getTop(),
                    b      = target.height - target.getBottom(),
                    l      = target.getLeft(),
                    r      = target.width - target.getRight(),
                    center = null,
                    left   = null,
                    top    = null,
                    bottom = null,
                    right  = null;

                for(var i = 0;i &lt; target.kids.length; i++){
                    var kid = target.kids[i];
                    if (kid.isVisible === true) {
                        switch(kid.constraints) {
                            case null:
                            case undefined:
                            case &quot;center&quot;:
                                if (center !== null) {
                                    throw new Error(&quot;Component with center constraints is already defined&quot;);
                                }
                                center = kid;
                                break;
                            case &quot;top&quot; :
                                if (top !== null) {
                                    throw new Error(&quot;Component with top constraints is already defined&quot;);
                                }
                                kid.setBounds(l, t, r - l, kid.getPreferredSize().height);
                                t += kid.height + this.vgap;
                                top = kid;
                                break;
                            case &quot;bottom&quot;:
                                if (bottom !== null) {
                                    throw new Error(&quot;Component with bottom constraints is already defined&quot;);
                                }
                                var bh = kid.getPreferredSize().height;
                                kid.setBounds(l, b - bh, r - l, bh);
                                b -= bh + this.vgap;
                                bottom = kid;
                                break;
                            case &quot;left&quot;:
                                if (left !== null) {
                                    throw new Error(&quot;Component with left constraints is already defined&quot;);
                                }
                                left = kid;
                                break;
                            case &quot;right&quot;:
                                if (right !== null) {
                                    throw new Error(&quot;Component with right constraints is already defined&quot;);
                                }
                                right = kid;
                                break;
                            default: throw new Error(&quot;Invalid constraints: &#x27;&quot; + kid.constraints + &quot;&#x27;&quot;);
                        }
                    }
                }

                if (right !== null) {
                    var rw = right.getPreferredSize().width;
                    right.setBounds(r - rw, t, rw, b - t);
                    r -= rw + this.hgap;
                }

                if (left !== null) {
                    left.setBounds(l, t, left.getPreferredSize().width, b - t);
                    l += left.width + this.hgap;
                }

                if (center !== null) {
                    center.setBounds(l, t, r - l, b - t);
                }
            };
        }
    ]);

    /**
     * Rester layout manager can be used to use absolute position of layoutable components. That means
     * all components will be laid out according coordinates and size they have. Raster layout manager
     * provides extra possibilities to control children components placing. It is possible to align
     * components by specifying layout constraints, size component to its preferred size and so on.
     * Constraints that can be set for components are the following
     *    - &quot;top&quot;
     *    - &quot;topRight&quot;
     *    - &quot;topLeft&quot;
     *    - &quot;bottom&quot;
     *    - &quot;bottomLeft&quot;
     *    - &quot;bottomRight&quot;
     *    - &quot;right&quot;
     *    - &quot;center&quot;
     *    - &quot;left&quot;
     * @example
     *     // instantiate component to be ordered
     *     var topLeftLab = zebkit.ui.Label(&quot;topLeft&quot;);
     *     var leftLab    = zebkit.ui.Label(&quot;left&quot;);
     *     var centerLab  = zebkit.ui.Label(&quot;center&quot;);
     *
     *     // instantiate a container with raster layoyt manager set
     *     // the manager is adjusted to size added child component to
     *     // its preferred sizes
     *     var container = new zebkit.ui.Panel(new zebkit.layout.RasterLayout(true));
     *
     *     // add child components with appropriate constraints
     *     container.add(&quot;topLeft&quot;, topLeftLab);
     *     container.add(&quot;left&quot;, leftLab);
     *     container.add(&quot;center&quot;, centerLab);
     *
     * @param {Boolean} [usePsSize] flag to add extra rule to set components size to its preferred
     * sizes.
     * @class  zebkit.layout.RasterLayout
     * @constructor
     * @uses zebkit.layout.Layout
     */
    pkg.RasterLayout = Class(pkg.Layout, [
        function(usePsSize) {
            if (arguments.length &gt; 0) {
                this.usePsSize = usePsSize;
            }
        },

        function $prototype() {
            /**
             * Define if managed with layout manager components have to be sized according to its
             * preferred size
             * @attribute usePsSize
             * @type {Boolean}
             * @default false
             */
            this.usePsSize = false;

            this.calcPreferredSize = function(c){
                var m = { width:0, height:0 };

                for(var i = 0;i &lt; c.kids.length; i++ ){
                    var kid = c.kids[i];
                    if (kid.isVisible === true) {
                        var ps = this.usePsSize ? kid.getPreferredSize()
                                                : { width:kid.width, height:kid.height },
                            px = kid.x + ps.width,
                            py = kid.y + ps.height;

                        if (px &gt; m.width)  {
                            m.width  = px;
                        }

                        if (py &gt; m.height) {
                            m.height = py;
                        }
                    }
                }
                return m;
            };

            this.doLayout = function(c) {
                var r = c.getRight(),
                    b = c.getBottom(),
                    t = c.getTop(),
                    l = c.getLeft();

                for(var i = 0;i &lt; c.kids.length; i++){
                    var kid = c.kids[i], ww = 0, hh = 0;

                    if (kid.isVisible === true){
                        if (this.usePsSize) {
                            var ps = kid.toPreferredSize();
                            ww = ps.width;
                            hh = ps.height;
                        } else {
                            ww = kid.width;
                            hh = kid.height;
                        }

                        var ctr = kid.constraints === null ? null : kid.constraints;
                        if (ctr !== null) {
                            var x = kid.x,
                                y = kid.y;

                            if (ctr === &quot;top&quot; || ctr === &quot;topRight&quot; || ctr === &quot;topLeft&quot;) {
                                y = t;
                            } else if (ctr === &quot;bottom&quot; || ctr === &quot;bottomLeft&quot; || ctr === &quot;bottomRight&quot;) {
                                y = c.height - hh - b;
                            } else if (ctr === &quot;center&quot; || ctr === &quot;left&quot; || ctr === &quot;right&quot;) {
                                y = Math.floor((c.height - hh) / 2);
                            }

                            if (ctr === &quot;left&quot; || ctr === &quot;topLeft&quot; || ctr === &quot;bottomLeft&quot;) {
                                x = l;
                            } else if (ctr === &quot;right&quot; || ctr === &quot;topRight&quot; || ctr === &quot;bottomRight&quot;) {
                                x = c.width - ww - r;
                            } else if (ctr === &quot;center&quot; || ctr === &quot;top&quot; || ctr === &quot;bottom&quot;) {
                                x = Math.floor((c.width  - ww) / 2);
                            }

                            kid.setLocation(x, y);
                        }
                    }
                }
            };
        }
    ]);

    /**
     * Flow layout manager group and places components ordered with different vertical and horizontal
     * alignments
     *
     *     // create panel and set flow layout for it
     *     // components added to the panel will be placed
     *     // horizontally aligned at the center of the panel
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.FlowLayout(&quot;center&quot;, &quot;center&quot;));
     *
     *     // add three buttons into the panel with flow layout
     *     p.add(new zebkit.ui.Button(&quot;Button 1&quot;));
     *     p.add(new zebkit.ui.Button(&quot;Button 2&quot;));
     *     p.add(new zebkit.ui.Button(&quot;Button 3&quot;));
     *
     * @param {String} [ax] (&quot;left&quot; by default) horizontal alignment:

         &quot;left&quot;
         &quot;center&quot;
         &quot;right&quot;

     * @param {String} [ay] (&quot;top&quot; by default) vertical alignment:

         &quot;top&quot;
         &quot;center&quot;
         &quot;bottom&quot;

     * @param {String} [dir] (&quot;horizontal&quot; by default) a direction the component has to be placed
     * in the layout

         &quot;vertical&quot;
         &quot;horizontal&quot;

     * @param {Integer} [gap] a space in pixels between laid out components
     * @class  zebkit.layout.FlowLayout
     * @constructor
     * @uses zebkit.layout.Layout
     */
    pkg.FlowLayout = Class(pkg.Layout, [
        function (ax, ay, dir, g){
            if (arguments.length === 1) {
                this.gap = ax;
            } else {
                if (arguments.length &gt; 1) {
                    this.ax = ax;
                    this.ay = ay;
                }

                if (arguments.length &gt; 2)  {
                    this.direction = zebkit.util.$validateValue(dir, &quot;horizontal&quot;, &quot;vertical&quot;);
                }

                if (arguments.length &gt; 3) {
                    this.gap = g;
                }
            }
        },

        function $prototype() {
            /**
             * Gap between laid out components
             * @attribute gap
             * @readOnly
             * @type {Integer}
             * @default 0
             */
            this.gap = 0;

            /**
             * Horizontal laid out components alignment
             * @attribute ax
             * @readOnly
             * @type {String}
             * @default &quot;left&quot;
             */
            this.ax = &quot;left&quot;;

            /**
             * Vertical laid out components alignment
             * @attribute ay
             * @readOnly
             * @type {String}
             * @default &quot;center&quot;
             */
            this.ay = &quot;center&quot;;

            /**
             * Laid out components direction
             * @attribute direction
             * @readOnly
             * @type {String}
             * @default &quot;horizontal&quot;
             */
            this.direction = &quot;horizontal&quot;;

            /**
             * Define if the last added component has to be stretched to occupy
             * the rest of horizontal or vertical space of a parent component.
             * @attribute stretchLast
             * @type {Boolean}
             * @default false
             */
            this.stretchLast = false;

            this.calcPreferredSize = function (c){
                var m = { width:0, height:0 }, cc = 0;
                for(var i = 0;i &lt; c.kids.length; i++){
                    var a = c.kids[i];
                    if (a.isVisible === true){
                        var d = a.getPreferredSize();
                        if (this.direction === &quot;horizontal&quot;){
                            m.width += d.width;
                            m.height = d.height &gt; m.height ? d.height : m.height;
                        }
                        else {
                            m.width = d.width &gt; m.width ? d.width : m.width;
                            m.height += d.height;
                        }
                        cc++;
                    }
                }

                var add = this.gap * (cc &gt; 0 ? cc - 1 : 0);
                if (this.direction === &quot;horizontal&quot;) {
                    m.width += add;
                } else {
                    m.height += add;
                }
                return m;
            };

            this.doLayout = function(c){
                var psSize  = this.calcPreferredSize(c),
                    t       = c.getTop(),
                    l       = c.getLeft(),
                    lastOne = null,
                    ew      = c.width  - l - c.getRight(),
                    eh      = c.height - t - c.getBottom(),
                    px      = ((this.ax === &quot;right&quot;) ? ew - psSize.width
                                                     : ((this.ax === &quot;center&quot;) ? Math.floor((ew - psSize.width) / 2) : 0)) + l,
                    py      = ((this.ay === &quot;bottom&quot;) ? eh - psSize.height
                                                      : ((this.ay === &quot;center&quot;) ? Math.floor((eh - psSize.height) / 2): 0)) + t;

                for(var i = 0;i &lt; c.kids.length; i++){
                    var a = c.kids[i];
                    if (a.isVisible === true) {

                        var d = a.getPreferredSize(),
                            ctr = a.constraints === null ? null : a.constraints;

                        if (this.direction === &quot;horizontal&quot;) {
                            ctr = ctr || this.ay;

                            if (ctr === &quot;stretch&quot;) {
                                d.height = c.height - t - c.getBottom();
                            }

                            a.setLocation(px, ctr === &quot;stretch&quot; ? t :
                                              (ctr === &quot;top&quot;    ? py :
                                              (ctr === &quot;bottom&quot; ? Math.floor(psSize.height - d.height) + py :
                                                                  Math.floor((psSize.height - d.height) / 2) + py)));
                            px += (d.width + this.gap);
                        }
                        else {
                            ctr = ctr || this.ax;

                            if (ctr === &quot;stretch&quot;) {
                                d.width = c.width - l - c.getRight();
                            }

                            a.setLocation(ctr === &quot;stretch&quot;  ? l  :
                                          (ctr === &quot;left&quot;    ? px :
                                          (ctr === &quot;right&quot;   ? px + Math.floor(psSize.width - d.width) :
                                                               px + Math.floor((psSize.width - d.width) / 2))), py);

                            py += d.height + this.gap;
                        }

                        a.setSize(d.width, d.height);
                        lastOne = a;
                    }
                }

                if (lastOne !== null &amp;&amp; this.stretchLast === true){
                    if (this.direction === &quot;horizontal&quot;) {
                        lastOne.setSize(c.width - lastOne.x - c.getRight(), lastOne.height);
                    }
                    else {
                        lastOne.setSize(lastOne.width, c.height - lastOne.y - c.getBottom());
                    }
                }
            };
        }
    ]);

    /**
     * List layout places components vertically one by one
     *
     *     // create panel and set list layout for it
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.ListLayout());
     *
     *     // add three buttons into the panel with list layout
     *     p.add(new zebkit.ui.Button(&quot;Item 1&quot;));
     *     p.add(new zebkit.ui.Button(&quot;Item 2&quot;));
     *     p.add(new zebkit.ui.Button(&quot;Item 3&quot;));
     *
     * @param {String} [ax] horizontal list item alignment:

         &quot;left&quot;
         &quot;right&quot;
         &quot;center&quot;
         &quot;stretch&quot;

     * @param {Integer} [gap] a space in pixels between laid out components
     * @class  zebkit.layout.ListLayout
     * @constructor
     * @uses zebkit.layout.Layout
     */
    pkg.ListLayout = Class(pkg.Layout,[
        function (ax, gap) {
            if (arguments.length === 1) {
                this.gap = ax;
            } else if (arguments.length &gt; 1) {
                this.ax  = zebkit.util.$validateValue(ax, &quot;stretch&quot;, &quot;left&quot;, &quot;right&quot;, &quot;center&quot;);
                this.gap = gap;
            }
        },

        function $prototype() {
            /**
             * Horizontal list items alignment
             * @attribute ax
             * @type {String}
             * @readOnly
             */
            this.ax = &quot;stretch&quot;;

            /**
             * Pixel gap between list items
             * @attribute gap
             * @type {Integer}
             * @readOnly
             */
            this.gap = 0;

            this.calcPreferredSize = function (lw){
                var w = 0, h = 0, c = 0;
                for(var i = 0; i &lt; lw.kids.length; i++){
                    var kid = lw.kids[i];
                    if (kid.isVisible === true){
                        var d = kid.getPreferredSize();
                        h += (d.height + (c &gt; 0 ? this.gap : 0));
                        c++;
                        if (w &lt; d.width) {
                            w = d.width;
                        }
                    }
                }
                return { width:w, height:h };
            };

            this.doLayout = function (lw){
                var x   = lw.getLeft(),
                    y   = lw.getTop(),
                    psw = lw.width - x - lw.getRight();

                for(var i = 0;i &lt; lw.kids.length; i++){
                    var cc = lw.kids[i];

                    if (cc.isVisible === true){
                        var d      = cc.getPreferredSize(),
                            constr = cc.constraints === null ? this.ax
                                                            : cc.constraints;

                        cc.setSize    ((constr === &quot;stretch&quot;) ? psw
                                                                : d.width, d.height);
                        cc.setLocation((constr === &quot;stretch&quot;) ? x
                                                                : x + ((constr === &quot;right&quot;) ? psw - cc.width
                                                                                            : ((constr === &quot;center&quot;) ? Math.floor((psw - cc.width) / 2)
                                                                                                                     : 0)), y);
                        y += (d.height + this.gap);
                    }
                }
            };
        }
    ]);

    /**
     * Percent layout places components vertically or horizontally and sizes its according to its
     * percentage constraints.
     *
     *     // create panel and set percent layout for it
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.PercentLayout());
     *
     *     // add three buttons to the panel that are laid out horizontally with
     *     // percent layout according to its constraints: 20, 30 and 50 percents
     *     p.add(20, new zebkit.ui.Button(&quot;20%&quot;));
     *     p.add(30, new zebkit.ui.Button(&quot;30%&quot;));
     *     p.add(50, new zebkit.ui.Button(&quot;50%&quot;));
     *
     * @param {String} [dir] a direction of placing components. The
     * value can be &quot;horizontal&quot; or &quot;vertical&quot;
     * @param {Integer} [gap] a space in pixels between laid out components
     * @param {Boolean} [stretch] true if the component should be stretched
     * vertically or horizontally
     * @class  zebkit.layout.PercentLayout
     * @constructor
     * @uses zebkit.layout.Layout
     */
    pkg.PercentLayout = Class(pkg.Layout, [
        function(dir, gap, stretch) {
            if (arguments.length &gt; 0) {
                this.direction = zebkit.util.$validateValue(dir, &quot;horizontal&quot;, &quot;vertical&quot;);
                if (arguments.length &gt; 1) {
                    this.gap = gap;
                }

                if (arguments.length &gt; 2) {
                    this.stretch = stretch;
                }
            }
        },

        function $prototype() {
             /**
              * Direction the components have to be placed (vertically or horizontally)
              * @attribute direction
              * @readOnly
              * @type {String}
              * @default &quot;horizontal&quot;
              */
            this.direction = &quot;horizontal&quot;;

            /**
             * Pixel gap between components
             * @attribute gap
             * @readOnly
             * @type {Integer}
             * @default 2
             */
            this.gap = 2;

            /**
             * Boolean flag that say if the laid out components have
             * to be stretched vertically (if direction is set to &quot;vertical&quot;)
             * or horizontally (if direction is set to &quot;horizontal&quot;)
             * @attribute stretch
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.stretch = true;

            this.doLayout = function(target){
                var right  = target.getRight(),
                    top    = target.getTop(),
                    bottom = target.getBottom(),
                    left   = target.getLeft(),
                    size   = target.kids.length,
                    rs     = -this.gap * (size === 0 ? 0 : size - 1),
                    loc    = 0,
                    ns     = 0;

                if (this.direction === &quot;horizontal&quot;){
                    rs += target.width - left - right;
                    loc = left;
                } else {
                    rs += target.height - top - bottom;
                    loc = top;
                }

                for(var i = 0; i &lt; size; i ++ ){
                    var l = target.kids[i], c = l.constraints, useps = (c === &quot;usePsSize&quot;);
                    if (this.direction === &quot;horizontal&quot;){
                        ns = ((size - 1) === i) ? target.width - right - loc
                                                : (useps ? l.getPreferredSize().width
                                                         : Math.floor((rs * c) / 100));
                        var yy = top, hh = target.height - top - bottom;
                        if (this.stretch === false) {
                            var ph = hh;
                            hh = l.getPreferredSize().height;
                            yy = top + Math.floor((ph - hh) / 2);
                        }

                        l.setBounds(loc, yy, ns, hh);
                    } else {
                        ns = ((size - 1) === i) ? target.height - bottom - loc
                                                : (useps ? l.getPreferredSize().height
                                                         : Math.floor((rs * c) / 100));
                        var xx = left, ww = target.width - left - right;
                        if (this.stretch === false) {
                            var pw = ww;
                            ww = l.getPreferredSize().width;
                            xx = left + Math.floor((pw - ww) / 2);
                        }

                        l.setBounds(xx, loc, ww, ns);
                    }
                    loc += (ns + this.gap);
                }
            };

            this.calcPreferredSize = function (target){
                var max  = 0,
                    size = target.kids.length,
                    as   = this.gap * (size === 0 ? 0 : size - 1);

                for(var i = 0; i &lt; size; i++) {
                    var d = target.kids[i].getPreferredSize();
                    if (this.direction === &quot;horizontal&quot;) {
                        if (d.height &gt; max) {
                            max = d.height;
                        }
                        as += d.width;
                    } else {
                        if (d.width &gt; max) {
                            max = d.width;
                        }
                        as += d.height;
                    }
                }
                return (this.direction === &quot;horizontal&quot;) ? { width:as, height:max }
                                                         : { width:max, height:as };
            };
        }
    ]);

    /**
     * Grid layout manager constraints. Constraints says how a  component has to be placed in
     * grid layout virtual cell. The constraints specifies vertical and horizontal alignments,
     * a virtual cell paddings, etc.
     * @param {Integer} [ax] a horizontal alignment
     * @param {Integer} [ay] a vertical alignment
     * @param {Integer} [p]  a cell padding
     * @constructor
     * @class zebkit.layout.Constraints
     */
    pkg.Constraints = Class([
        function(ax, ay, p) {
            if (arguments.length &gt; 0) {
                this.ax = ax;
                if (arguments.length &gt; 1) {
                    this.ay = ay;
                }

                if (arguments.length &gt; 2) {
                    this.setPadding(p);
                }

                zebkit.util.$validateValue(this.ax, &quot;stretch&quot;, &quot;left&quot;, &quot;center&quot;, &quot;right&quot;);
                zebkit.util.$validateValue(this.ay, &quot;stretch&quot;, &quot;top&quot;, &quot;center&quot;, &quot;bottom&quot;);
            }
        },

        function $prototype() {
            /**
             * Top cell padding
             * @attribute top
             * @type {Integer}
             * @default 0
             */

            /**
             * Left cell padding
             * @attribute left
             * @type {Integer}
             * @default 0
             */

            /**
             * Right cell padding
             * @attribute right
             * @type {Integer}
             * @default 0
             */

            /**
             * Bottom cell padding
             * @attribute bottom
             * @type {Integer}
             * @default 0
             */

            /**
             * Horizontal alignment
             * @attribute ax
             * @type {String}
             * @default &quot;stretch&quot;
             */

            /**
             * Vertical alignment
             * @attribute ay
             * @type {String}
             * @default &quot;stretch&quot;
             */

            this.top = this.bottom = this.left = this.right = 0;
            this.ay = this.ax = &quot;stretch&quot;;
            this.rowSpan = this.colSpan = 1;

            /**
             * Set all four paddings (top, left, bottom, right) to the given value
             * @param  {Integer} p a padding
             * @chainable
             * @method setPadding
             */

            /**
             * Set top, left, bottom, right paddings
             * @param  {Integer} t a top padding
             * @param  {Integer} l a left padding
             * @param  {Integer} b a bottom padding
             * @param  {Integer} r a right padding
             * @chainable
             * @method setPadding
             */
            this.setPadding = function(t,l,b,r) {
                if (arguments.length === 1) {
                    this.top = this.bottom = this.left = this.right = t;
                } else {
                    this.top    = t;
                    this.bottom = b;
                    this.left   = l;
                    this.right  = r;
                }
                return this;
            };
        }
    ]);

    /**
     * Grid layout manager. can be used to split a component area to number of virtual cells where
     * children components can be placed. The way how the children components have to be laid out
     * in the cells can be customized by using &quot;zebkit.layout.Constraints&quot; class:
     *
     *     // create constraints
     *     var ctr = new zebkit.layout.Constraints();
     *
     *     // specify cell top, left, right, bottom paddings
     *     ctr.setPadding(8);
     *     // say the component has to be left aligned in a
     *     // virtual cell of grid layout
     *     ctr.ax = &quot;left&quot;;
     *
     *     // create panel and set grid layout manager with two
     *     // virtual rows and columns
     *     var p = new zebkit.ui.Panel();
     *     p.setLayout(new zebkit.layout.GridLayout(2, 2));
     *
     *     // add children component
     *     p.add(ctr, new zebkit.ui.Label(&quot;Cell 1, 1&quot;));
     *     p.add(ctr, new zebkit.ui.Label(&quot;Cell 1, 2&quot;));
     *     p.add(ctr, new zebkit.ui.Label(&quot;Cell 2, 1&quot;));
     *     p.add(ctr, new zebkit.ui.Label(&quot;Cell 2, 2&quot;));
     *
     * @param {Integer} rows a number of virtual rows to layout children components
     * @param {Integer} cols a number of virtual columns to layout children components
     * @param {Boolean} [stretchRows] true if virtual cell height has to be stretched to occupy the
     * whole vertical container component space
     * @param {Boolean} [stretchCols] true if virtual cell width has to be stretched to occupy the
     * whole horizontal container component space
     * @constructor
     * @class  zebkit.layout.GridLayout
     * @uses zebkit.layout.Layout
     */
    pkg.GridLayout = Class(pkg.Layout, [
        function(r, c, stretchRows, stretchCols) {
            /**
             * Number of virtual rows to place children components
             * @attribute rows
             * @readOnly
             * @type {Integer}
             */
            this.rows = r;

            /**
             * Number of virtual columns to place children components
             * @attribute cols
             * @readOnly
             * @type {Integer}
             */
            this.cols = c;

            /**
             * Computed columns sizes.
             * @attribute colSizes
             * @type {Array}
             * @private
             */
            this.colSizes = Array(c + 1);

            /**
             * Computed rows sizes.
             * @attribute rowSizes
             * @type {Array}
             * @private
             */
            this.rowSizes = Array(r + 1);

            /**
             * Default constraints that is applied for children components
             * that doesn&#x27;t define own constraints
             * @type {zebkit.layout.Constraints}
             * @attribute constraints
             */
            this.constraints = new pkg.Constraints();

            if (arguments.length &gt; 2) {
                this.stretchRows = (stretchRows === true);
            }

            if (arguments.length &gt; 3) {
                this.stretchCols = (stretchCols === true);
            }
        },

        function $prototype() {
            /**
             * Attributes that indicates if component has to be stretched
             * horizontally to occupy the whole space of a virtual cell.
             * @attribute stretchCols
             * @readOnly
             * @type {Boolean}
             * @default false
             */
            this.stretchCols = false;

            /**
             * Attributes that indicates if component has to be stretched
             * vertically to occupy the whole space of a virtual cell.
             * @attribute stretchRows
             * @readOnly
             * @type {Boolean}
             * @default false
             */
            this.stretchRows = false;

            /**
             * Set default grid layout cell paddings (top, left, bottom, right) to the given value
             * @param  {Integer} p a padding
             * @chainable
             * @method setPadding
             */

            /**
             * Set default grid layout cell paddings: top, left, bottom, right
             * @param  {Integer} t a top padding
             * @param  {Integer} l a left padding
             * @param  {Integer} b a bottom padding
             * @param  {Integer} r a right padding
             * @chainable
             * @method setPadding
             */
            this.setPadding = function() {
                this.constraints.setPadding.apply(this.constraints, arguments);
                return this;
            };

            /**
             * Set default constraints.
             * @method setDefaultConstraints
             * @chainable
             * @param {zebkit.layout.Constraints} c a constraints
             */
            this.setDefaultConstraints = function(c) {
                this.constraints = c;
                return this;
            };

            /**
             * Calculate columns metrics
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Array} a columns widths
             * @method calcCols
             * @protected
             */
            this.calcCols = function(c){
                this.colSizes[this.cols] = 0;
                for(var i = 0;i &lt; this.cols; i++) {
                    this.colSizes[i] = this.calcCol(i, c);
                    this.colSizes[this.cols] += this.colSizes[i];
                }
                return this.colSizes;
            };

            /**
             * Calculate rows metrics
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Array} a rows heights
             * @method calcRows
             * @protected
             */
            this.calcRows = function(c){
                this.rowSizes[this.rows] = 0;
                for(var i = 0;i &lt; this.rows; i++) {
                    this.rowSizes[i] = this.calcRow(i, c);
                    this.rowSizes[this.rows] += this.rowSizes[i];
                }
                return this.rowSizes;
            };

            /**
             * Calculate the given row height
             * @param  {Integer} row a row
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Integer} a size of the row
             * @method calcRow
             * @protected
             */
            this.calcRow = function(row, c){
                var max = 0, s = row * this.cols;
                for (var i = s; i &lt; c.kids.length &amp;&amp; i &lt; s + this.cols; i++) {
                    var a = c.kids[i];
                    if (a.isVisible === true) {
                        var arg = a.constraints || this.constraints,
                            d   = a.getPreferredSize().height;

                        d += (arg.top + arg.bottom);
                        if (d &gt; max) {
                            max = d;
                        }
                    }
                }
                return max;
            };

            /**
             * Calculate the given column width
             * @param  {Integer} col a column
             * @param  {zebkit.layout.Layoutable} c the target container
             * @return {Integer} a size of the column
             * @method calcCol
             * @protected
             */
            this.calcCol = function(col, c){
                var max = 0;

                for(var i = col; i &lt; c.kids.length; i += this.cols) {
                    var a = c.kids[i];
                    if (a.isVisible === true) {
                        var arg = a.constraints || this.constraints,
                            d   = a.getPreferredSize().width + arg.left + arg.right;

                        if (d &gt; max) {
                            max = d;
                        }
                    }
                }
                return max;
            };

            this.calcPreferredSize = function(c){
                return { width : this.calcCols(c)[this.cols],
                         height: this.calcRows(c)[this.rows] };
            };

            this.doLayout = function(c){
                var rows     = this.rows,
                    cols     = this.cols,
                    colSizes = this.calcCols(c),
                    rowSizes = this.calcRows(c),
                    top      = c.getTop(),
                    left     = c.getLeft(),
                    cc       = 0,
                    i        = 0;

                if (this.stretchCols) {
                    var dw = c.width - left - c.getRight() - colSizes[cols];
                    for(i = 0; i &lt; cols; i ++ ) {
                        colSizes[i] = colSizes[i] + (colSizes[i] !== 0 ? Math.floor((dw * colSizes[i]) / colSizes[cols]) : 0);
                    }
                }

                if (this.stretchRows) {
                    var dh = c.height - top - c.getBottom() - rowSizes[rows];
                    for(i = 0; i &lt; rows; i++) {
                        rowSizes[i] = rowSizes[i] + (rowSizes[i] !== 0 ? Math.floor((dh * rowSizes[i]) / rowSizes[rows]) : 0);
                    }
                }

                for (i = 0; i &lt; rows &amp;&amp; cc &lt; c.kids.length; i++) {
                    var xx = left;
                    for(var j = 0;j &lt; cols &amp;&amp; cc &lt; c.kids.length; j++, cc++) {
                        var l = c.kids[cc];
                        if (l.isVisible === true){
                            var arg   = l.constraints || this.constraints,
                                d     = l.getPreferredSize(),
                                cellW = colSizes[j],
                                cellH = rowSizes[i];

                            cellW -= (arg.left + arg.right);
                            cellH -= (arg.top  + arg.bottom);

                            if (&quot;stretch&quot; === arg.ax) {
                                d.width  = cellW;
                            }

                            if (&quot;stretch&quot; === arg.ay) {
                                d.height = cellH;
                            }

                            l.setSize(d.width, d.height);
                            l.setLocation(
                                xx  + arg.left + (&quot;stretch&quot; === arg.ax ? 0
                                                                       : ((arg.ax === &quot;right&quot;) ? cellW - d.width
                                                                                               : ((arg.ax === &quot;center&quot;) ? Math.floor((cellW - d.width) / 2)
                                                                                                                        : 0))),
                                top + arg.top  + (&quot;stretch&quot; === arg.ay ? 0
                                                                       : ((arg.ay === &quot;bottom&quot; ) ? cellH - d.height
                                                                                                 : ((arg.ay === &quot;center&quot;) ? Math.floor((cellH - d.height) / 2)
                                                                                                                          : 0)))
                            );

                            xx += colSizes[j];
                        }
                    }
                    top += rowSizes[i];
                }
            };
        }
    ]);
});
zebkit.package(&quot;draw&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    /**
     * View package
     *
     * @class  zebkit.draw
     * @access package
     */


     /**
      * Dictionary of useful methods an HTML Canvas 2D context can be extended. The following methods are
      * included:
      *
      *   - **setFont(f)**   set font
      *   - **setColor(c)**  set background and foreground colors
      *   - **drawLine(x1, y1, x2, y2, [w])**  draw line of the given width
      *   - **ovalPath(x,y,w,h)**  build oval path
      *   - **polylinePath(xPoints, yPoints, nPoints)**  build path by the given points
      *   - **drawDottedRect(x,y,w,h)**  draw dotted rectangle
      *   - **drawDashLine(x,y,x2,y2)** draw dashed line
      *
      * @attribute Context2D
      * @type {Object}
      * @protected
      * @readOnly
      */
     pkg.Context2D = {
        setFont : function(f) {
            f = (typeof f.s !== &#x27;undefined&#x27; ? f.s : f.toString());
            if (f !== this.font) {
                this.font = f;
            }
        },

        setColor : function (c) {
            c = (typeof c.s !== &#x27;undefined&#x27; ? c.s : c.toString());
            if (c !== this.fillStyle) {
                this.fillStyle = c;
            }

            if (c !== this.strokeStyle) {
                this.strokeStyle = c;
            }
        },

        drawLine : function (x1, y1, x2, y2, w){
            if (arguments.length &lt; 5) {
                w = 1;
            }

            var pw = this.lineWidth;
            this.beginPath();
            if (this.lineWidth !== w) {
                this.lineWidth = w;
            }

            if (x1 === x2) {
                x1 += w / 2;
                x2 = x1;
            } else if (y1 === y2) {
                y1 += w / 2;
                y2 = y1;
            }

            this.moveTo(x1, y1);
            this.lineTo(x2, y2);
            this.stroke();
            if (pw !== this.lineWidth) {
                this.lineWidth = pw;
            }
        },

        ovalPath: function (x,y,w,h){
            this.beginPath();
            x += this.lineWidth;
            y += this.lineWidth;
            w -= 2 * this.lineWidth;
            h -= 2 * this.lineWidth;

            var kappa = 0.5522848,
                ox = Math.floor((w / 2) * kappa),
                oy = Math.floor((h / 2) * kappa),
                xe = x + w,
                ye = y + h,
                xm = x + w / 2,
                ym = y + h / 2;
            this.moveTo(x, ym);
            this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            this.closePath();
         },

        polylinePath : function(xPoints, yPoints, nPoints){
            this.beginPath();
            this.moveTo(xPoints[0], yPoints[0]);
            for(var i = 1; i &lt; nPoints; i++) {
                this.lineTo(xPoints[i], yPoints[i]);
            }
        },

        drawRect : function(x,y,w,h) {
            this.beginPath();
            this.rect(x,y,w,h);
            this.stroke();
        },

        drawDottedRect : function(x,y,w,h) {
            var ctx = this, m = [&quot;moveTo&quot;, &quot;lineTo&quot;, &quot;moveTo&quot;];
            function dv(x, y, s) { for(var i=0; i &lt; s; i++) { ctx[m[i%3]](x + 0.5, y + i); }  }
            function dh(x, y, s) { for(var i=0; i &lt; s; i++) { ctx[m[i%3]](x + i, y + 0.5); } }
            ctx.beginPath();
            dh(x, y, w);
            dh(x, y + h - 1, w);
            ctx.stroke();
            ctx.beginPath();
            dv(x, y, h);
            dv(w + x - 1, y, h);
            ctx.stroke();
        },

        drawDashLine : function(x,y,x2,y2) {
            var pattern = [1,2],
                compute = null,
                dx      = (x2 - x), dy = (y2 - y),
                b       = (Math.abs(dx) &gt; Math.abs(dy)),
                slope   = b ? dy / dx : dx / dy,
                sign    = b ? (dx &lt; 0 ?-1:1) : (dy &lt; 0?-1:1),
                dist    = Math.sqrt(dx * dx + dy * dy);

            if (b) {
                compute = function(step) {
                    x += step;
                    y += slope * step;
                };
            } else {
                compute = function(step) {
                    x += slope * step;
                    y += step;
                };
            }

            this.beginPath();
            this.moveTo(x, y);
            for (var i = 0; dist &gt;= 0.1; i++) {
                var idx  = i % pattern.length,
                    dl   = dist &lt; pattern[idx] ? dist : pattern[idx],
                    step = Math.sqrt(dl * dl / (1 + slope * slope)) * sign;

                compute(step);
                this[(i % 2 === 0) ? &#x27;lineTo&#x27; : &#x27;moveTo&#x27;](x + 0.5, y + 0.5);
                dist -= dl;
            }
            this.stroke();
        }
    };

    pkg.$views = {};

    /**
     * Build a view instance by the given object.
     * @param  {Object} v an object that can be used to build a view. The following variants
     * of object types are possible
     *
     *   - **null** null is returned
     *   - **String** if the string is color or border view id than &quot;zebkit.util.rgb&quot; or border view
     *     is returned. Otherwise an instance of zebkit.draw.StringRender is returned.
     *   -  **String** if the string starts from &quot;#&quot; or &quot;rgb&quot; it is considered as encoded color.  &quot;zebkit.util.rgb&quot;
     *     instance will be returned as the view
     *   - **Array** an instance of &quot;zebkit.draw.CompositeView&quot; is returned
     *   - **Function** in this case the passed method is considered as ans implementation of &quot;paint(g, x, y, w, h, d)&quot;
     *     method of &quot;zebkit.draw.View&quot; class. Ans instance of &quot;zebkit.draw.View&quot; with the method implemented is returned.
     *   - **Object** an instance of &quot;zebkit.draw.ViewSet&quot; is returned
     *
     * @return zebkit.draw.View a view
     * @method $view
     * @example
     *
     *      // string render
     *      var view = zebkit.draw.$view(&quot;String render&quot;);
     *
     *      // color render
     *      var view = zebkit.draw.$view(&quot;red&quot;);
     *
     *      // composite view
     *      var view = zebkit.draw.$view([
     *          zebkit.utii.rgb.yellow,
     *          &quot;String Render&quot;
     *      ]);
     *
     *      // custom view
     *      var view = zebkit.draw.$view(function(g,x,y,w,h,d) {
     *          g.drawLine(x, y, x + w, y + w);
     *          ...
     *       });
     *
     * @protected
     * @for zebkit.draw
     */
    pkg.$view = function(v) {
        if (v === null || typeof v.paint !== &#x27;undefined&#x27;) {
            return v;
        } else if (typeof v === &quot;string&quot; || v.constructor === String) {
            if (typeof zebkit.util.rgb[v] !== &#x27;undefined&#x27;) { // detect color
                return zebkit.util.rgb[v];
            } else if (typeof pkg.$views[v] !== &#x27;undefined&#x27;) { // detect predefined view
                return pkg.$views[v];
            } else {
                if (v.length &gt; 0 &amp;&amp;
                    (v[0] === &#x27;#&#x27;        ||
                      ( v.length &gt; 2 &amp;&amp;
                        v[0] === &#x27;r&#x27; &amp;&amp;
                        v[1] === &#x27;g&#x27; &amp;&amp;
                        v[2] === &#x27;b&#x27;    )  ))
                {
                    return new zebkit.util.rgb(v);
                } else {
                    return new pkg.StringRender(v);
                }
            }
        } else if (Array.isArray(v)) {
            return new pkg.CompositeView(v);
        } else if (typeof v !== &#x27;function&#x27;) {
            return new pkg.ViewSet(v);
        } else {
            var vv = new pkg.View();
            vv.paint = v;
            return vv;
        }
    };

    zebkit.util.rgb.prototype.paint = function(g,x,y,w,h,d) {
        if (this.s !== g.fillStyle) {
            g.fillStyle = this.s;
        }

        // fix for IE10/11, calculate intersection of clipped area
        // and the area that has to be filled. IE11/10 have a bug
        // that triggers filling more space than it is restricted
        // with clip
        if (typeof g.$states !== &#x27;undefined&#x27;) {
            var t  = g.$states[g.$curState],
                rx = x &gt; t.x ? x : t.x,
                rw = Math.min(x + w, t.x + t.width) - rx;

            if (rw &gt; 0)  {
                var ry = y &gt; t.y ? y : t.y,
                rh = Math.min(y + h, t.y + t.height) - ry;

                if (rh &gt; 0) {
                    g.fillRect(rx, ry, rw, rh);
                }
            }
        } else {
            g.fillRect(x, y, w, h);
        }
    };

    zebkit.util.rgb.prototype.getPreferredSize = function() {
        return { width:0, height:0 };
    };

    zebkit.util.rgb.gap = 0;
    zebkit.util.rgb.prototype.getTop    =
    zebkit.util.rgb.prototype.getLeft   =
    zebkit.util.rgb.prototype.getRight  =
    zebkit.util.rgb.prototype.getBottom = function() {
        return this.gap;
    };

    /**
     * View class that is designed as a basis for various reusable decorative UI elements implementations
     * @class zebkit.draw.View
     * @constructor
     */
    pkg.View = Class([
        function $prototype() {
            this.gap = 2;

            /**
             * Get left gap. The method informs UI component that uses the view as
             * a border view how much space left side of the border occupies
             * @return {Integer} a left gap
             * @method getLeft
             */

             /**
              * Get right gap. The method informs UI component that uses the view as
              * a border view how much space right side of the border occupies
              * @return {Integer} a right gap
              * @method getRight
              */

             /**
              * Get top gap. The method informs UI component that uses the view as
              * a border view how much space top side of the border occupies
              * @return {Integer} a top gap
              * @method getTop
              */

             /**
              * Get bottom gap. The method informs UI component that uses the view as
              * a border view how much space bottom side of the border occupies
              * @return {Integer} a bottom gap
              * @method getBottom
              */
            this.getRight = this.getLeft = this.getBottom = this.getTop = function() {
                return this.gap;
            };

            /**
            * Return preferred size the view desires to have
            * @method getPreferredSize
            * @return {Object}
            */
            this.getPreferredSize = function() {
                return { width  : 0,
                         height : 0 };
            };

            /**
            * The method is called to render the decorative element on the given surface of the specified
            * UI component
            * @param {CanvasRenderingContext2D} g  graphical context
            * @param {Integer} x  x coordinate
            * @param {Integer} y  y coordinate
            * @param {Integer} w  required width
            * @param {Integer} h  required height
            * @param {zebkit.layout.Layoutable} c an UI component on which the view
            * element has to be drawn
            * @method paint
            */
            this.paint = function(g,x,y,w,h,c) {};
        }
    ]);

    /**
     * Render class extends &quot;zebkit.draw.View&quot; class with a notion
     * of target object. Render stores reference  to a target that
     * the render knows how to visualize. Basically Render is an
     * object visualizer. For instance, developer can implement
     * text, image and so other objects visualizers.
     * @param {Object} target a target object to be visualized
     * with the render
     * @constructor
     * @extends zebkit.draw.View
     * @class zebkit.draw.Render
     */
    pkg.Render = Class(pkg.View, [
        function(target) {
            if (arguments.length &gt; 0) {
                this.setValue(target);
            }
        },

        function $prototype() {
            /**
             * Target object to be visualized
             * @attribute target
             * @default null
             * @readOnly
             * @type {Object}
             */
            this.target = null;

            /**
             * Set the given target object. The method triggers &quot;valueWasChanged(oldTarget, newTarget)&quot;
             * execution if the method is declared. Implement the method if you need to track a target
             * object updating.
             * @method setValue
             * @param  {Object} o a target object to be visualized
             */
            this.setValue = function(o) {
                if (this.target !== o) {
                    var old = this.target;
                    this.target = o;
                    if (typeof this.valueWasChanged !== &#x27;undefined&#x27;) {
                        this.valueWasChanged(old, o);
                    }
                }
            };

            /**
             * Get as rendered object.
             * @return {Object} a rendered object
             * @method getValue
             */
            this.getValue = function() {
                return this.target;
            };
        }
    ]);


    /**
    * Composite view. The view allows developers to combine number of
    * views and renders its together.
    * @class zebkit.draw.CompositeView
    * @param {Object} ...views number of views to be composed.
    * @constructor
    * @extends zebkit.draw.View
    */
    pkg.CompositeView = Class(pkg.View, [
        function() {
            /**
             * Composed views array.
             * @attribute views
             * @type {Array}
             * @protected
             * @readOnly
             */
            this.views = [];

            var args = arguments.length === 1 ? arguments[0] : arguments;
            for(var i = 0; i &lt; args.length; i++) {
                this.views[i] = pkg.$view(args[i]);
                this.$recalc(this.views[i]);
            }
        },

        function $prototype() {
            /**
             * Left padding
             * @readOnly
             * @private
             * @attribute left
             * @type {Integer}
             */

            /**
             * Right padding
             * @private
             * @readOnly
             * @attribute right
             * @type {Integer}
             */

            /**
             * Top padding
             * @private
             * @readOnly
             * @attribute top
             * @type {Integer}
             */

            /**
             * Bottom padding
             * @readOnly
             * @private
             * @attribute bottom
             * @type {Integer}
             */
            this.left = this.right = this.bottom = this.top = this.height = this.width = 0;

            this.getTop = function() {
                return this.top;
            };

            this.getLeft = function() {
                return this.left;
            };

            this.getBottom = function () {
                return this.bottom;
            };

            this.getRight = function () {
                return this.right;
            };

            this.getPreferredSize = function (){
                return { width:this.width, height:this.height};
            };

            this.$recalc = function(v) {
                var b = 0, ps = v.getPreferredSize();
                if (typeof v.getLeft !== &#x27;undefined&#x27;) {
                    b = v.getLeft();
                    if (b &gt; this.left) {
                        this.left = b;
                    }
                }

                if (typeof v.getRight !== &#x27;undefined&#x27;) {
                    b = v.getRight();
                    if (b &gt; this.right) {
                        this.right = b;
                    }
                }

                if (typeof v.getTop !== &#x27;undefined&#x27;) {
                    b = v.getTop();
                    if (b &gt; this.top) {
                        this.top = b;
                    }
                }

                if (typeof v.getBottom !== &#x27;undefined&#x27;) {
                    b = v.getBottom();
                    if (b &gt; this.bottom) {
                        this.bottom = b;
                    }
                }


                if (ps.width &gt; this.width) {
                    this.width = ps.width;
                }

                if (ps.height &gt; this.height) {
                    this.height = ps.height;
                }

                if (typeof this.voutline === &#x27;undefined&#x27; &amp;&amp; typeof v.outline !== &#x27;undefined&#x27;) {
                    this.voutline = v;
                }
            };

            /**
             * Iterate over composed views.
             * @param  {Function} f callback that is called for every iterated view. The callback
             * gets a view index and view itself as its argument.
             * @method iterate
             */
            this.iterate = function(f) {
                for(var i = 0; i &lt; this.views.length; i++) {
                    f.call(this, i, this.views[i]);
                }
            };

            this.recalc = function() {
                this.left = this.right = this.bottom = this.top = this.height = this.width = 0;
                this.iterate(function(k, v) {
                    this.$recalc(v);
                });
            };

            this.ownerChanged = function(o) {
                this.iterate(function(k, v) {
                    if (v !== null &amp;&amp; typeof v.ownerChanged !== &#x27;undefined&#x27;) {
                        v.ownerChanged(o);
                    }
                });
            };

            this.paint = function(g,x,y,w,h,d) {
                var ctx = false;
                for(var i = 0; i &lt; this.views.length; i++) {
                    var v = this.views[i];
                    v.paint(g, x, y, w, h, d);

                    if (i &lt; this.views.length - 1 &amp;&amp; typeof v.outline === &#x27;function&#x27; &amp;&amp; v.outline(g, x, y, w, h, d)) {
                        if (ctx === false) {
                            g.save();
                            ctx = true;
                        }
                        g.clip();
                    }
                }

                if (ctx === true) {
                    g.restore();
                }
            };

            /**
             * Return number of composed views.
             * @return {Integer} number of composed view.
             * @method  count
             */
            this.count = function() {
                return this.views.length;
            };

            this.outline = function(g,x,y,w,h,d) {
                return typeof this.voutline !== &#x27;undefined&#x27; &amp;&amp; this.voutline.outline(g,x,y,w,h,d);
            };
        }
    ]);

    /**
    * ViewSet view. The view set is a special view container that includes
    * number of views accessible by a key and allows only one view be active
    * in a particular time. Active is view that has to be rendered. The view
    * set can be used to store number of decorative elements where only one
    * can be rendered depending from an UI component state.
    * @param {Object} args object that represents views instances that have
    * to be included in the ViewSet
    * @constructor
    * @class zebkit.draw.ViewSet
    * @extends zebkit.draw.CompositeView
    */
    pkg.ViewSet = Class(pkg.CompositeView, [
        function(args) {
            if (arguments.length === 0 || args === null) {
                throw new Error(&quot;&quot; + args);
            }

            /**
             * Views set
             * @attribute views
             * @type Object
             * @default {}
             * @readOnly
            */
            this.views = {};
            this.$size = 0;

            for(var k in args) {
                this.views[k] = pkg.$view(args[k]);
                this.$size++;
                if (this.views[k] !== null) {
                    this.$recalc(this.views[k]);
                }
            }
            this.activate(&quot;*&quot;);
        },

        function $prototype() {
            /**
             * Active in the set view
             * @attribute activeView
             * @type View
             * @default null
             * @readOnly
            */
            this.activeView = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.activeView !== null) {
                    this.activeView.paint(g, x, y, w, h, d);
                }
            };

            this.count = function() {
                return this.$size;
            };

            /**
             * Activate the given view from the given set.
             * @param  {String} id a key of a view from the set to be activated. Pass
             * null to make current view to undefined state
             * @return {Boolean} true if new view has been activated, false otherwise
             * @method activate
             */
            this.activate = function(id) {
                var old = this.activeView;

                if (id === null) {
                    return (this.activeView = null) !== old;
                }

                if (this.views.hasOwnProperty(id)) {
                    return (this.activeView = this.views[id]) !== old;
                }

                if (id.length &gt; 1 &amp;&amp; id[0] !== &#x27;*&#x27; &amp;&amp; id[id.length - 1] !== &#x27;*&#x27;) {
                    var i = id.indexOf(&#x27;.&#x27;);
                    if (i &gt; 0) {
                        var k = id.substring(0, i + 1) + &#x27;*&#x27;;
                        if (this.views.hasOwnProperty(k)) {
                            return (this.activeView = this.views[k]) !== old;
                        } else {
                            k = &quot;*&quot; + id.substring(i);
                            if (this.views.hasOwnProperty(k)) {
                                return (this.activeView = this.views[k]) !== old;
                            }
                        }
                    }
                }

                return this.views.hasOwnProperty(&quot;*&quot;) ? (this.activeView = this.views[&quot;*&quot;]) !== old
                                                      : false;
            };

            this.iterate = function(f) {
                for(var k in this.views) {
                    f.call(this, k, this.views[k]);
                }
            };
        }
    ]);

    /**
     * Abstract shape view.
     * @param  {String}  [c]  a color of the shape
     * @param  {Integer} [w]  a line size
     * @class zebkit.draw.Shape
     * @constructor
     * @extends zebkit.draw.View
     */
    pkg.Shape = Class(pkg.View, [
        function (c, w) {
            if (arguments.length &gt; 0) {
                this.color = c;
                if (arguments.length &gt; 1) {
                    this.width = this.gap = w;
                }
            }
        },

        function $prototype() {
            this.color = &quot;gray&quot;;
            this.gap   = this.width = 1;

            this.paint = function(g,x,y,w,h,d) {
                if (g.lineWidth !== this.width) {
                    g.lineWidth = this.width;
                }

                this.outline(g,x,y,w,h,d);
                g.setColor(this.color);
                g.stroke();
            };
        }
    ]);


    /**
    * Sunken border view
    * @class zebkit.draw.Sunken
    * @constructor
    * @param {String} [brightest] a brightest border line color
    * @param {String} [moddle] a middle border line color
    * @param {String} [darkest] a darkest border line color
    * @extends zebkit.draw.View
    */
    pkg.Sunken = Class(pkg.View, [
        function (brightest,middle,darkest) {
            if (arguments.length &gt; 0) {
                this.brightest = brightest;
                if (arguments.length &gt; 1) {
                    this.middle = middle;
                    if (arguments.length &gt; 2) {
                        this.darkest   = darkest;
                    }
                }
            }
        },

        function $prototype() {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default &quot;white&quot;
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default &quot;gray&quot;
             */

            /**
             * Darkest border line color
             * @attribute darkest
             * @readOnly
             * @type {String}
             * @default &quot;black&quot;
             */
            this.brightest = &quot;white&quot;;
            this.middle    = &quot;gray&quot; ;
            this.darkest   = &quot;black&quot;;

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.middle);
                g.drawLine(x1, y1, x2 - 1, y1);
                g.drawLine(x1, y1, x1, y2 - 1);
                g.setColor(this.brightest);
                g.drawLine(x2, y1, x2, y2 + 1);
                g.drawLine(x1, y2, x2, y2);
                g.setColor(this.darkest);
                g.drawLine(x1 + 1, y1 + 1, x1 + 1, y2);
                g.drawLine(x1 + 1, y1 + 1, x2, y1 + 1);
            };
        }
    ]);

    /**
    * Etched border view
    * @class zebkit.draw.Etched
    * @constructor
    * @param {String} [brightest] a brightest border line color
    * @param {String} [moddle] a middle border line color
    * @extends zebkit.draw.View
    */
    pkg.Etched = Class(pkg.View, [
        function (brightest, middle) {
            if (arguments.length &gt; 0) {
                this.brightest = brightest;
                if (arguments.length &gt; 1) {
                    this.middle = middle;
                }
            }
        },

        function $prototype() {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default &quot;white&quot;
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default &quot;gray&quot;
             */
            this.brightest = &quot;white&quot;;
            this.middle    = &quot;gray&quot; ;

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.middle);
                g.drawLine(x1, y1, x1, y2 - 1);
                g.drawLine(x2 - 1, y1, x2 - 1, y2);
                g.drawLine(x1, y1, x2, y1);
                g.drawLine(x1, y2 - 1, x2 - 1, y2 - 1);

                g.setColor(this.brightest);
                g.drawLine(x2, y1, x2, y2);
                g.drawLine(x1 + 1, y1 + 1, x1 + 1, y2 - 1);
                g.drawLine(x1 + 1, y1 + 1, x2 - 1, y1 + 1);
                g.drawLine(x1, y2, x2 + 1, y2);
            };
        }
    ]);

    /**
    * Raised border view
    * @class zebkit.draw.Raised
    * @param {String} [brightest] a brightest border line color
    * @param {String} [middle] a middle border line color
    * @constructor
    * @extends zebkit.draw.View
    */
    pkg.Raised = Class(pkg.View, [
        function(brightest, middle) {
            /**
             * Brightest border line color
             * @attribute brightest
             * @readOnly
             * @type {String}
             * @default &quot;white&quot;
             */

            /**
             * Middle border line color
             * @attribute middle
             * @readOnly
             * @type {String}
             * @default &quot;gray&quot;
             */

            if (arguments.length &gt; 0) {
                this.brightest = brightest;
                if (arguments.length &gt; 1) {
                    this.middle = middle;
                }
            }
        },

        function $prototype() {
            this.brightest = &quot;white&quot;;
            this.middle    = &quot;gray&quot;;

            this.paint = function(g,x1,y1,w,h,d){
                var x2 = x1 + w - 1, y2 = y1 + h - 1;
                g.setColor(this.brightest);
                g.drawLine(x1, y1, x2, y1);
                g.drawLine(x1, y1, x1, y2);
                g.setColor(this.middle);
                g.drawLine(x2, y1, x2, y2 + 1);
                g.drawLine(x1, y2, x2, y2);
            };
        }
    ]);

    /**
    * Dotted border view
    * @class zebkit.draw.Dotted
    * @param {String} [c] the dotted border color
    * @constructor
    * @extends zebkit.draw.View
    */
    pkg.Dotted = Class(pkg.View, [
        function (c){
            if (arguments.length &gt; 0) {
                this.color = c;
            }
        },

        function $prototype() {
            /**
             * @attribute color
             * @readOnly
             * @type {String}
             * @default &quot;black&quot;
             */
            this.color = &quot;black&quot;;

            this.paint = function(g,x,y,w,h,d){
                g.setColor(this.color);
                g.drawDottedRect(x, y, w, h);
            };
        }
    ]);

    /**
     * Border view. Can be used to render CSS-like border. Border can be applied to any
     * zebkit UI component by calling setBorder method:

            // create label component
            var lab = new zebkit.ui.Label(&quot;Test label&quot;);

            // set red border to the label component
            lab.setBorder(new zebkit.draw.Border(&quot;red&quot;));

     * @param  {String}  [c] border color
     * @param  {Integer} [w] border width
     * @param  {Integer} [r] border corners radius
     * @constructor
     * @class zebkit.draw.Border
     * @extends zebkit.draw.View
     */
    pkg.Border = Class(pkg.View, [
        function(c, w, r) {
            if (arguments.length &gt; 0) {
                this.color = c;
                if (arguments.length &gt; 1) {
                    this.width = this.gap = w;
                    if (arguments.length &gt; 2) {
                        this.radius = r;
                    }
                }
            }
        },

        function $prototype() {
            /**
             * Border color
             * @attribute color
             * @readOnly
             * @type {String}
             * @default &quot;gray&quot;
             */

            /**
             * Border line width
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 1
             */

            /**
             * Border radius
             * @attribute radius
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            this.color  = &quot;gray&quot;;
            this.gap    = this.width = 1;
            this.radius = 0;
            this.sides  = 15;

            /**
             * Control border sides visibility.
             * @param {String} side*  list of visible sides. You can pass number of arguments
             * to say which sides of the border are visible. The arguments can equal one of the
             * following value: &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;
             * @method  setSides
             * @chainable
             */
            this.setSides = function(top, left, bottom, right) {
                this.sides = 0;
                for(var i = 0; i &lt; arguments.length; i++) {
                    if (arguments[i] === &quot;top&quot;) {
                        this.sides  |= 1;
                    } else if (arguments[i] === &quot;left&quot;) {
                        this.sides  |= 2;
                    } else if (arguments[i] === &quot;bottom&quot;) {
                        this.sides  |= 4;
                    } else if (arguments[i] === &quot;right&quot; ) {
                        this.sides  |= 8;
                    }
                }

                return this;
            };

            this.paint = function(g,x,y,w,h,d){
                if (this.color !== null &amp;&amp; this.width &gt; 0) {
                    var ps = g.lineWidth;

                    if (g.lineWidth !== this.width) {
                        g.lineWidth = this.width;
                    }

                    if (this.radius &gt; 0) {
                        this.outline(g,x,y,w,h, d);
                        g.setColor(this.color);
                        g.stroke();
                    } else if (this.sides !== 15) {
                        g.setColor(this.color);
                        // top
                        if ((this.sides &amp; 1) &gt; 0) {
                            g.drawLine(x, y, x + w, y, this.width);
                        }

                        // right
                        if ((this.sides &amp; 8) &gt; 0) {
                            g.drawLine(x + w - this.width, y, x + w - this.width, y + h, this.width);
                        }

                        // bottom
                        if ((this.sides &amp; 4) &gt; 0) {
                            g.drawLine(x, y + h - this.width, x + w, y + h - this.width, this.width);
                        }

                        // left
                        if ((this.sides &amp; 2) &gt; 0) {
                            g.drawLine(x, y, x, y + h, this.width);
                        }
                    } else {
                        var dt = this.width / 2;
                        g.beginPath();
                        g.rect(x + dt, y + dt, w - this.width, h - this.width);
                        g.closePath();
                        g.setColor(this.color);
                        g.stroke();
                    }

                    if (g.lineWidth !== ps) {
                        g.lineWidth = ps;
                    }
                }
            };

            /**
             * Defines border outline for the given 2D Canvas context
             * @param  {CanvasRenderingContext2D} g
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @param  {Integer} w required width
             * @param  {Integer} h required height
             * @param  {Integer} d target UI component
             * @method outline
             * @return {Boolean} true if the outline has to be applied as an
             * UI component shape
             */
            this.outline = function(g,x,y,w,h,d) {
                if (this.radius &lt;= 0) {
                    return false;
                }

                var r  = this.radius,
                    dt = this.width / 2,
                    xx = x + w - dt,
                    yy = y + h - dt;

                x += dt;
                y += dt;

                // !!! this code can work improperly in IE 10 in Vista !
                // g.beginPath();
                // g.moveTo(x+r, y);
                // g.arcTo(xx, y, xx, yy, r);
                // g.arcTo(xx, yy, x, yy, r);
                // g.arcTo(x, yy, x, y, r);
                // g.arcTo(x, y, xx, y, r);
                // g.closePath();
                // return true;

                g.beginPath();
                g.moveTo(x + r, y);
                g.lineTo(xx - r, y);
                g.quadraticCurveTo(xx, y, xx, y + r);
                g.lineTo(xx, yy  - r);
                g.quadraticCurveTo(xx, yy, xx - r, yy);
                g.lineTo(x + r, yy);
                g.quadraticCurveTo(x, yy, x, yy - r);
                g.lineTo(x, y + r);
                g.quadraticCurveTo(x, y, x + r, y);
                g.closePath();
                return true;
            };
        }
    ]);

    /**
     * Round border view.
     * @param  {String}  [col] border color. Use null as the
     * border color value to prevent painting of the border
     * @param  {Integer} [width] border width
     * @constructor
     * @class zebkit.draw.RoundBorder
     * @extends zebkit.draw.View
     */
    pkg.RoundBorder = Class(pkg.View, [
        function(col, width) {
            if (arguments.length &gt; 0) {
                if (zebkit.isNumber(col)) {
                    this.width = col;
                } else {
                    this.color = col;
                    if (zebkit.isNumber(width)) {
                        this.width = width;
                    }
                }
            }
            this.gap = this.width;
        },

        function $prototype() {
            /**
             * Border width
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 1
             */
            this.width = 1;

            /**
             * Border color
             * @attribute color
             * @readOnly
             * @type {String}
             * @default null
             */
            this.color = null;

            /**
             * Color to fill the inner area surrounded with the round border.
             * @attribute fillColor
             * @type {String}
             * @default null
             */
            this.fillColor = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.color !== null &amp;&amp; this.width &gt; 0) {
                    this.outline(g,x,y,w,h,d);
                    g.setColor(this.color);
                    g.stroke();
                    if (this.fillColor !== null) {
                       g.setColor(this.fillColor);
                       g.fill();
                    }
                }
            };

            this.outline = function(g,x,y,w,h,d) {
                g.lineWidth = this.width;
                if (w === h) {
                    g.beginPath();
                    g.arc(Math.floor(x + w / 2) + (w % 2 === 0 ? 0 : 0.5),
                          Math.floor(y + h / 2) + (h % 2 === 0 ? 0 : 0.5),
                          Math.floor((w - g.lineWidth) / 2), 0, 2 * Math.PI, false);
                    g.closePath();
                } else {
                    g.ovalPath(x,y,w,h);
                }
                return true;
            };

            this.getPreferredSize = function() {
                var s = this.width * 8;
                return  {
                    width : s, height : s
                };
            };
        }
    ]);

    /**
     * Render class that allows developers to render a border with a title area.
     * The title area has to be specified by an UI component that uses the border
     * by defining &quot;getTitleInfo()&quot;&quot; method. The method has to return object that
     * describes title size, location and alignment:
     *
     *
     *      {
     *        x: {Integer}, y: {Integer},
     *        width: {Integer}, height: {Integer},
     *        orient: {Integer}
     *      }
     *
     *
     * @class zebkit.draw.TitledBorder
     * @extends zebkit.draw.Render
     * @constructor
     * @param zebkit.draw.View border  a border to be rendered with a title area
     * @param {String} [lineAlignment] a line alignment. Specifies how
     * a title area has to be aligned relatively border line:
     *
     *       &quot;bottom&quot;  - title area will be placed on top of border line:
     *                    ___| Title area |___
     *
     *
     *      &quot;center&quot;   - title area will be centered relatively to border line:
     *                    ---| Title area |-----
     *
     *
     *      &quot;top&quot;      - title area will be placed underneath of border line:
     *                     ____              ________
     *                         |  Title area |
     *
     */
    pkg.TitledBorder = Class(pkg.Render, [
        function (b, a){
            if (arguments.length &gt; 1) {
                this.lineAlignment = zebkit.util.$validateValue(a, &quot;bottom&quot;, &quot;top&quot;, &quot;center&quot;);
            }

            this.setValue(pkg.$view(b));
        },

        function $prototype() {
            this.lineAlignment = &quot;bottom&quot;;

            this.getTop  = function (){
                return this.target.getTop();
            };

            this.getLeft = function (){
                return this.target.getLeft();
            };

            this.getRight = function (){
                return this.target.getRight();
            };

            this.getBottom = function (){
                return this.target.getBottom();
            };

            this.outline = function (g,x,y,w,h,d) {
                var xx = x + w, yy = y + h;
                if (typeof d.getTitleInfo !== &#x27;undefined&#x27;) {
                    var r = d.getTitleInfo();
                    if (r !== null) {
                        switch(r.orient) {
                            case &quot;bottom&quot;:
                                var bottom = this.target.getBottom();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : yy = r.y + Math.floor((r.height - bottom)/ 2) + bottom; break;
                                    case &quot;top&quot;    : yy = r.y + r.height + bottom; break;
                                    case &quot;bottom&quot; : yy = r.y; break;
                                }
                                break;
                            case &quot;top&quot;:
                                var top = this.target.getTop();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : y = r.y + Math.floor((r.height - top)/2);   break; // y = r.y + Math.floor(r.height/ 2) ; break;
                                    case &quot;top&quot;    : y = r.y - top; break;
                                    case &quot;bottom&quot; : y = r.y + r.height; break;
                                }
                                break;
                            case &quot;left&quot;:
                                var left = this.target.getLeft();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : x = r.x + Math.floor((r.width - left) / 2); break;
                                    case &quot;top&quot;    : x = r.x - left; break;
                                    case &quot;bottom&quot; : x = r.x + r.width; break;
                                }
                                break;
                            case &quot;right&quot;:
                                var right = this.target.getRight();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : xx = r.x + Math.floor((r.width - right) / 2) + right; break;
                                    case &quot;top&quot;    : xx = r.x + r.width + right; break;
                                    case &quot;bottom&quot; : xx = r.x; break;
                                }
                                break;
                        }
                    }
                }

                if (this.target !== null &amp;&amp;
                    typeof this.target.outline !== &#x27;undefined&#x27; &amp;&amp;
                    this.target.outline(g, x, y, xx - x, yy - y, d) === true)
                {
                    return true;
                }

                g.beginPath();
                g.rect(x, y, xx - x, yy - y);
                g.closePath();
                return true;
            };

            this.$isIn = function(clip, x, y, w, h) {
                var rx = clip.x &gt; x ? clip.x : x,
                    ry = clip.y &gt; y ? clip.y : y,
                    rw = Math.min(clip.x + clip.width, x + w) - rx,
                    rh = Math.min(clip.y + clip.height, y + h) - ry;
                return (clip.x === rx &amp;&amp; clip.y === ry &amp;&amp; clip.width === rw &amp;&amp; clip.height === rh);
            };

            this.paint = function(g,x,y,w,h,d){
                if (typeof d.getTitleInfo !== &#x27;undefined&#x27;){
                    var r = d.getTitleInfo();
                    if (r !== null) {
                        var xx = x + w, yy = y + h, t = g.$states[g.$curState];
                        switch (r.orient) {
                            case &quot;top&quot;:
                                var top = this.target.getTop();
                                // compute border y
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : y = r.y + Math.floor((r.height - top) / 2) ; break;
                                    case &quot;top&quot;    : y = r.y - top; break;
                                    case &quot;bottom&quot; : y = r.y + r.height; break;
                                }

                                // skip rendering border if the border is not in clip rectangle
                                // This is workaround because of IE10/IE11 have bug what causes
                                // handling rectangular clip + none-rectangular clip side effect
                                // to &quot;fill()&quot; subsequent in proper working (fill without respect of
                                // clipping  area)
                                if (this.$isIn(t, x + this.target.getLeft(), y,
                                               w - this.target.getRight() - this.target.getLeft(),
                                               yy - y - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(r.x, y);
                                g.lineTo(r.x, y + top);
                                g.lineTo(r.x + r.width, y + top);
                                g.lineTo(r.x + r.width, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);

                                break;
                            case &quot;bottom&quot;:
                                var bottom = this.target.getBottom();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : yy = r.y + Math.floor((r.height - bottom) / 2) + bottom; break;
                                    case &quot;top&quot;    : yy = r.y + r.height + bottom; break;
                                    case &quot;bottom&quot; : yy = r.y ; break;
                                }

                                if (this.$isIn(t, x + this.target.getLeft(), y + this.target.getTop(),
                                                  w - this.target.getRight() - this.target.getLeft(),
                                                  yy - y - this.target.getTop()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(r.x + r.width, yy);
                                g.lineTo(r.x + r.width, yy - bottom);
                                g.lineTo(r.x, yy - bottom);
                                g.lineTo(r.x, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);

                                break;
                            case &quot;left&quot;:
                                var left = this.target.getLeft();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : x = r.x + Math.floor((r.width - left) / 2); break;
                                    case &quot;top&quot;    : x = r.x  - left; break;
                                    case &quot;bottom&quot; : x = r.x + r.width; break;
                                }

                                if (this.$isIn(t, x, y + this.target.getTop(),
                                               xx - x - this.target.getRight(),
                                               h - this.target.getTop() - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, r.y + r.height);
                                g.lineTo(x + left, r.y + r.height);
                                g.lineTo(x + left, r.y);
                                g.lineTo(x, r.y);
                                g.lineTo(x, y);

                                break;
                            case &quot;right&quot;:
                                var right = this.target.getRight();
                                switch (this.lineAlignment) {
                                    case &quot;center&quot; : xx = r.x + Math.floor((r.width - right) / 2) + right; break;
                                    case &quot;top&quot;    : xx = r.x  + r.width + right; break;
                                    case &quot;bottom&quot; : xx = r.x; break;
                                }

                                if (this.$isIn(t, x + this.target.getLeft(),
                                                  y + this.target.getTop(),
                                                  xx - x - this.target.getLeft(),
                                                  h - this.target.getTop() - this.target.getBottom()))
                                {
                                    return;
                                }

                                g.save();
                                g.beginPath();

                                g.moveTo(x, y);
                                g.lineTo(xx, y);
                                g.lineTo(xx, r.y);
                                g.lineTo(xx - right, r.y);
                                g.lineTo(xx - right, r.y + r.height);
                                g.lineTo(xx, r.y + r.height);
                                g.lineTo(xx, yy);
                                g.lineTo(x, yy);
                                g.lineTo(x, y);
                                break;
                            // throw error to avoid wrongly called restore method below
                            default: throw new Error(&quot;Invalid title orientation &quot; + r.orient);
                        }

                        g.closePath();
                        g.clip();
                        this.target.paint(g, x, y, xx - x, yy - y, d);
                        g.restore();
                    }
                } else {
                    this.target.paint(g, x, y, w, h, d);
                }
            };
        }
    ]);


    /**
     * Default normal font
     * @attribute font
     * @type {zebkit.Font}
     * @for  zebkit.draw
     */
    pkg.font = new zebkit.Font(&quot;Arial&quot;, 14);

    /**
     * Default small font
     * @attribute smallFont
     * @type {zebkit.Font}
     * @for  zebkit.draw
     */
    pkg.smallFont = new zebkit.Font(&quot;Arial&quot;, 10);

    /**
     * Default bold font
     * @attribute boldFont
     * @type {zebkit.Font}
     * @for  zebkit.draw
     */
    pkg.boldFont = new zebkit.Font(&quot;Arial&quot;, &quot;bold&quot;, 12);

    /**
     * Base class to build text render implementations.
     * @class  zebkit.draw.BaseTextRender
     * @constructor
     * @param  {Object} [target]  target component to be rendered
     * @extends zebkit.draw.Render
     */
    pkg.BaseTextRender = Class(pkg.Render, [
        function $clazz() {
            this.font          =  pkg.font;
            this.color         = &quot;gray&quot;;
            this.disabledColor = &quot;white&quot;;
        },

        function $prototype(clazz) {
            /**
             * UI component that holds the text render
             * @attribute owner
             * @default null
             * @readOnly
             * @protected
             * @type {zebkit.layout.Layoutable}
             */
            this.owner = null;

            /**
             * Line indention
             * @attribute lineIndent
             * @type {Integer}
             * @default 1
             */
            this.lineIndent = 1;

            // implement position metric methods
            this.getMaxOffset = this.getLineSize = this.getLines = function() {
                return 0;
            };

            /**
             * Set the rendered text font.
             * @param  {String|zebkit.Font} f a font as CSS string or
             * zebkit.Font class instance
            *  @chainable
             * @method setFont
             */
            this.setFont = function(f) {
                if (zebkit.instanceOf(f, zebkit.Font) === false &amp;&amp; f !== null) {
                    f = zebkit.newInstance(zebkit.Font, arguments);
                }

                if (f != this.font) {
                    this.font = f;

                    if (this.owner !== null &amp;&amp; this.owner.isValid === true) {
                        this.owner.invalidate();
                    }

                    if (typeof this.invalidate !== &#x27;undefined&#x27;) {
                        this.invalidate();
                    }
                }
                return this;
            };

            /**
             * Resize font
             * @param  {String|Integer} size a new size of the font
             * @chainable
             * @method resizeFont
             */
            this.resizeFont = function(size) {
                return this.setFont(this.font.resize(size));
            };

            this.restyleFont = function(style) {
                return this.setFont(this.font.restyle(style));
            };

            /**
             * Get line height
             * @return {[type]} [description]
             */
            this.getLineHeight = function() {
                return this.font.height;
            };

            /**
             * Set rendered text color
             * @param  {String} c a text color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                if (c != this.color) {
                    this.color = c.toString();
                }
                return this;
            };

            /**
             * Called whenever an owner UI component has been changed
             * @param  {zebkit.layout.Layoutable} v a new owner UI component
             * @method ownerChanged
             */
            this.ownerChanged = function(v) {
                this.owner = v;
            };

            this.valueWasChanged = function(o, n) {
                if (this.owner !== null &amp;&amp; this.owner.isValid) {
                    this.owner.invalidate();
                }

                if (typeof this.invalidate !== &#x27;undefined&#x27;) {
                    this.invalidate();
                }
            };

            this.toString = function() {
                return this.target === null ? null
                                            : this.target;
            };
        }
    ]);

    /**
     * Lightweight implementation of single line string render. The render requires
     * a simple string as a target object.
     * @param {String} str a string to be rendered
     * @param {zebkit.Font} [font] a text font
     * @param {String} [color] a text color
     * @constructor
     * @extends zebkit.draw.BaseTextRender
     * @class zebkit.draw.StringRender
     */
    pkg.StringRender = Class(pkg.BaseTextRender, [
        function $prototype() {
            this.stringWidth = -1;

            // for the sake of speed up construction of the widely used render
            // declare it none standard way.
            this[&#x27;&#x27;] = function(txt, font, color) {
                this.setValue(txt);

                /**
                 * Font to be used to render the target string
                 * @attribute font
                 * @readOnly
                 * @type {zebkit.Font}
                 */
                this.font = arguments.length &gt; 1 ? font : this.clazz.font;

                /**
                 * Color to be used to render the target string
                 * @readOnly
                 * @attribute color
                 * @type {String}
                 */
                this.color = arguments.length &gt; 2 ? color : this.clazz.color;
            };

            // implement position metric methods
            this.getMaxOffset = function() {
                return this.target.length;
            };

            this.getLineSize = function(l) {
                return this.target.length + 1;
            };

            this.getLines = function() {
                return 1;
            };

            this.calcLineWidth = function() {
                if (this.stringWidth &lt; 0) {
                    this.stringWidth = this.font.stringWidth(this.target);
                }
                return this.stringWidth;
            };

            this.invalidate = function() {
                this.stringWidth = -1;
            };

            this.paint = function(g,x,y,w,h,d) {
                // save a few milliseconds
                if (this.font.s !== g.font) {
                    g.setFont(this.font);
                }

                if (d !== null &amp;&amp; typeof d.getStartSelection !== &#x27;undefined&#x27;) {
                    var startSel = d.getStartSelection(),
                        endSel   = d.getEndSelection();

                    if (startSel     !== null       &amp;&amp;
                        endSel       !== null       &amp;&amp;
                        startSel.col !== endSel.col &amp;&amp;
                        d.selectView !== null          )
                    {
                        d.selectView.paint(g, x + this.font.charsWidth(this.target, 0, startSel.col),
                                              y,
                                              this.font.charsWidth(this.target,
                                                                   startSel.col,
                                                                   endSel.col - startSel.col),
                                              this.getLineHeight(), d);
                    }
                }

                // save a few milliseconds
                if (this.color !== g.fillStyle) {
                    g.fillStyle = this.color;
                }

                if (d !== null &amp;&amp; d.isEnabled === false) {
                    g.fillStyle = d !== null &amp;&amp;
                                  d.disabledColor !== null &amp;&amp;
                                  typeof d.disabledColor !== &#x27;undefined&#x27;  ? d.disabledColor
                                                                          : this.clazz.disabledColor;
                }

                g.fillText(this.target, x, y);
            };

            this.getLine = function(l) {
                if (l &lt; 0 || l &gt; 1) {
                    throw new RangeError();
                }
                return this.target;
            };

            this.getPreferredSize = function() {
                if (this.stringWidth &lt; 0) {
                    this.stringWidth = this.font.stringWidth(this.target);
                }

                return {
                    width: this.stringWidth,
                    height: this.font.height
                };
            };
        }
    ]);

    /**
     * Text render that expects and draws a text model or a string as its target
     * @class zebkit.draw.TextRender
     * @constructor
     * @extends zebkit.draw.BaseTextRender
     * @uses zebkit.util.Position.Metric
     * @param  {String|zebkit.data.TextModel} text a text as string or text model object
     */
    pkg.TextRender = Class(pkg.BaseTextRender, zebkit.util.Position.Metric, [
        function $prototype() {
            this.textWidth = this.textHeight = this.startInvLine = this.invLines = 0;

            // speed up constructor by avoiding super execution since
            // text render is one of the most used class
            this[&#x27;&#x27;] = function(text) {
                /**
                 * Text color
                 * @attribute color
                 * @type {String}
                 * @default zebkit.draw.TextRender.color
                 * @readOnly
                 */
                this.color = this.clazz.color;

                /**
                 * Text font
                 * @attribute font
                 * @type {String|zebkit.Font}
                 * @default zebkit.draw.TextRender.font
                 * @readOnly
                 */
                this.font = this.clazz.font;

                this.setValue(text);
            };

            /**
             * Get number of lines of target text
             * @return   {Integer} a number of line in the target text
             * @method getLines
             */
            this.getLines = function() {
                return this.target.getLines();
            };

            this.getLineSize = function(l) {
                return this.target.getLine(l).length + 1;
            };

            this.getMaxOffset = function() {
                return this.target.getTextLength();
            };

            /**
             * Paint the specified text line
             * @param  {CanvasRenderingContext2D} g graphical 2D context
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @param  {Integer} line a line number
             * @param  {zebkit.layout.Layoutable} d an UI component on that the line has to be rendered
             * @method paintLine
             */
            this.paintLine = function(g,x,y,line,d) {
                g.fillText(this.getLine(line), x, y);
            };

            /**
             * Get text line by the given line number
             * @param  {Integer} r a line number
             * @return {String} a text line
             * @method getLine
             */
            this.getLine = function(r) {
                return this.target.getLine(r);
            };

            /**
             * Set the text model content
             * @param  {String|zebkit.data.TextModel} s a text as string object
             * @method setValue
             * @chainable
             */
            this.setValue = function(s) {
                if (typeof s === &quot;string&quot; || s.constructor === String) {
                    if (this.target !== null) {
                        this.target.setValue(s);
                        return this;
                    } else {
                        s = new zebkit.data.Text(s);
                    }
                }

                //TODO: copy paste from Render to speed up
                if (this.target !== s) {
                    var old = this.target;
                    this.target = s;
                    if (typeof this.valueWasChanged !== &#x27;undefined&#x27;) {
                        this.valueWasChanged(old, s);
                    }
                }

                return this;
            };

            /**
             * Get the given text line width in pixels
             * @param  {Integer} line a text line number
             * @return {Integer} a text line width in pixels
             * @method lineWidth
             */
            this.calcLineWidth = function(line){
                if (this.invLines &gt; 0) {
                    this.recalc();
                }

                return this.target.$lineTags(line).$lineWidth;
            };

            /**
             * Called every time the target text metrics has to be recalculated
             * @method recalc
             */
            this.recalc = function() {
                if (this.invLines &gt; 0 &amp;&amp; this.target !== null){
                    var model = this.target, i = 0;
                    if (this.invLines &gt; 0) {
                        for(i = this.startInvLine + this.invLines - 1; i &gt;= this.startInvLine; i--) {
                            model.$lineTags(i).$lineWidth = this.font.stringWidth(this.getLine(i));
                        }
                        this.startInvLine = this.invLines = 0;
                    }

                    this.textWidth = 0;
                    var size = model.getLines();
                    for(i = 0; i &lt; size; i++){
                        var len = model.$lineTags(i).$lineWidth;
                        if (len &gt; this.textWidth) {
                            this.textWidth = len;
                        }
                    }
                    this.textHeight = this.getLineHeight() * size + (size - 1) * this.lineIndent;
                }
            };

            /**
             * Text model update listener handler
             * @param  {zebkit.data.TextModel} src text model object
             * @param  {Boolean} b
             * @param  {Integer} off an offset starting from that
             * the text has been updated
             * @param  {Integer} size a size (in character) of text part that
             * has been updated
             * @param  {Integer} ful a first affected by the given update line
             * @param  {Integer} updatedLines a number of text lines that have
             * been affected by text updating
             * @method textUpdated
             */
            this.textUpdated = function(src,b,off,size,ful,updatedLines){
                if (b === false) {
                    if (this.invLines &gt; 0) {
                        var p1 = ful - this.startInvLine,
                            p2 = this.startInvLine + this.invLines - ful - updatedLines;
                        this.invLines = ((p1 &gt; 0) ? p1 : 0) + ((p2 &gt; 0) ? p2 : 0) + 1;
                        this.startInvLine = this.startInvLine &lt; ful ? this.startInvLine : ful;
                    } else {
                        this.startInvLine = ful;
                        this.invLines = 1;
                    }

                    if (this.owner !== null &amp;&amp; this.owner.isValid !== true) {
                        this.owner.invalidate();
                    }
                } else {
                    if (this.invLines &gt; 0) {
                        if (ful &lt;= this.startInvLine) {
                            this.startInvLine += (updatedLines - 1);
                        } else if (ful &lt; (this.startInvLine + size)) {
                            size += (updatedLines - 1);
                        }
                    }
                    this.invalidate(ful, updatedLines);
                }
            };

            /**
             * Invalidate metrics for the specified range of lines.
             * @param  {Integer} start first line to be invalidated
             * @param  {Integer} size  number of lines to be invalidated
             * @method invalidate
             * @private
             */
            this.invalidate = function(start,size) {
                if (arguments.length === 0) {
                    start = 0;
                    size  = this.getLines();
                    if (size === 0) {
                        this.invLines = 0;
                        return;
                    }
                }

                if (size &gt; 0 &amp;&amp; (this.startInvLine !== start || size !== this.invLines)) {
                    if (this.invLines === 0){
                        this.startInvLine = start;
                        this.invLines = size;
                    } else {
                        var e = this.startInvLine + this.invLines;
                        this.startInvLine = start &lt; this.startInvLine ? start : this.startInvLine;
                        this.invLines     = Math.max(start + size, e) - this.startInvLine;
                    }

                    if (this.owner !== null) {
                        this.owner.invalidate();
                    }
                }
            };

            this.getPreferredSize = function(){
                if (this.invLines &gt; 0 &amp;&amp; this.target !== null) {
                    this.recalc();
                }
                return { width:this.textWidth, height:this.textHeight };
            };

            this.paint = function(g,x,y,w,h,d) {
                var ts = g.$states[g.$curState];
                if (ts.width &gt; 0 &amp;&amp; ts.height &gt; 0) {
                    var lineIndent   = this.lineIndent,
                        lineHeight   = this.getLineHeight(),
                        lilh         = lineHeight + lineIndent,
                        startInvLine = 0;

                    w = ts.width  &lt; w ? ts.width  : w;
                    h = ts.height &lt; h ? ts.height : h;

                    if (y &lt; ts.y) {
                        startInvLine = Math.floor((lineIndent + ts.y - y) / lilh);
                        h += (ts.y - startInvLine * lineHeight - startInvLine * lineIndent);
                    } else if (y &gt; (ts.y + ts.height)) {
                        return;
                    }

                    var size = this.getLines();
                    if (startInvLine &lt; size){
                        var lines = Math.floor((h + lineIndent) / lilh) + (((h + lineIndent) % lilh &gt; lineIndent) ? 1 : 0), i = 0;
                        if (startInvLine + lines &gt; size) {
                            lines = size - startInvLine;
                        }
                        y += startInvLine * lilh;

                        // save few milliseconds
                        if (this.font.s !== g.font) {
                            g.setFont(this.font);
                        }

                        if (d === null || d.isEnabled === true){
                            // save few milliseconds
                            if (this.color != g.fillStyle) {
                                g.fillStyle = this.color;
                            }

                            var p1 = null, p2 = null, bsel = false;
                            if (lines &gt; 0 &amp;&amp; d !== null &amp;&amp; typeof d.getStartSelection !== &#x27;undefined&#x27;) {
                                p1   = d.getStartSelection();
                                p2   = d.getEndSelection();
                                bsel = p1 !== null &amp;&amp; (p1.row !== p2.row || p1.col !== p2.col);
                            }

                            for(i = 0; i &lt; lines; i++){
                                if (bsel === true) {
                                    var line = i + startInvLine;
                                    if (line &gt;= p1.row &amp;&amp; line &lt;= p2.row){
                                        var s  = this.getLine(line),
                                            lw = this.calcLineWidth(line),
                                            xx = x;

                                        if (line === p1.row) {
                                            var ww = this.font.charsWidth(s, 0, p1.col);
                                            xx += ww;
                                            lw -= ww;
                                            if (p1.row === p2.row) {
                                                lw -= this.font.charsWidth(s, p2.col, s.length - p2.col);
                                            }
                                        } else if (line === p2.row) {
                                            lw = this.font.charsWidth(s, 0, p2.col);
                                        }
                                        this.paintSelection(g, xx, y, lw === 0 ? 1 : lw, lilh, line, d);

                                        // restore color to paint text since it can be
                                        // res-set with paintSelection method
                                        if (this.color !== g.fillStyle) {
                                            g.fillStyle = this.color;
                                        }
                                    }
                                }

                                this.paintLine(g, x, y, i + startInvLine, d);
                                y += lilh;
                            }
                        } else {
                            var dcol = d !== null &amp;&amp;
                                       d.disabledColor !== null &amp;&amp;
                                       typeof d.disabledColor !== &#x27;undefined&#x27; ? d.disabledColor
                                                                              : pkg.TextRender.disabledColor;

                            for(i = 0; i &lt; lines; i++) {
                                g.setColor(dcol);
                                this.paintLine(g, x, y, i + startInvLine, d);
                                y += lilh;
                            }
                        }
                    }
                }
            };

            /**
             * Paint the specified text selection of the given line. The area
             * where selection has to be rendered is denoted with the given
             * rectangular area.
             * @param  {CanvasRenderingContext2D} g a canvas graphical context
             * @param  {Integer} x a x coordinate of selection rectangular area
             * @param  {Integer} y a y coordinate of selection rectangular area
             * @param  {Integer} w a width of of selection rectangular area
             * @param  {Integer} h a height of of selection rectangular area
             * @param  {Integer} line [description]
             * @param  {zebkit.layout.Layoutable} d a target UI component where the text
             * has to be rendered
             * @protected
             * @method paintSelection
             */
            this.paintSelection = function(g, x, y, w, h, line, d) {
                if (d.selectView !== null) {
                    d.selectView.paint(g, x, y, w, h, d);
                }
            };

            this.toString = function() {
                return this.target === null ? null
                                            : this.target.getValue();
            };
        },

        function valueWasChanged(o,n){
            if (o !== null) {
                o.off(this);
            }

            if (n !== null) {
                n.on(this);
            }
            this.$super(o, n);
        }
    ]);

    pkg.WrappedTextRender = new Class(pkg.TextRender, [
        function $prototype() {
            this.brokenLines = null;
            this.lastWidth = -1;

            this.breakLine = function (w, startIndex, line, lines) {
                if (line === &quot;&quot;) {
                    lines.push(line);
                } else {
                    var breakIndex = startIndex &lt; line.length ? startIndex
                                                              : line.length - 1,
                        direction  = 0;

                    for(; breakIndex &gt;= 0 &amp;&amp; breakIndex &lt; line.length ;) {
                        var substrLen = this.font.charsWidth(line, 0, breakIndex + 1);
                        if (substrLen &lt; w) {
                            if (direction &lt; 0) {
                                break;
                            } else {
                                direction = 1;
                            }
                            breakIndex ++;
                        } else if (substrLen &gt; w) {
                            breakIndex--;
                            if (direction &gt; 0) {
                                break;
                            } else {
                                direction = -1;
                            }
                        } else {
                            break;
                        }
                    }

                    if (breakIndex &gt;= 0) {
                        lines.push(line.substring(0, breakIndex + 1));
                        if (breakIndex &lt; line.length - 1) {
                            this.breakLine(w, startIndex, line.substring(breakIndex + 1), lines);
                        }
                    }
                }
            };

            this.breakToLines = function (w) {
                var m = this.target, startIndex = 0, res = [];
                for(var i = 0; i &lt; m.getLines(); i++) {
                    var line = m.getLine(i);
                    this.breakLine(w, startIndex, line, res);
                }
                return res;
            };

            this.getLines = function() {
                return this.brokenLines.length;
            };

            this.getLine = function(i) {
                return this.brokenLines[i];
            };
        },

        function invalidate(sl, len){
            this.$super(sl, len);
            if (this.brokenLines !== null) {
                this.brokenLines.length = 0;
            }
            this.lastWidth = -1;
        },

        function getPreferredSize(pw, ph) {
            if (arguments.length === 2) {
                if (this.lastWidth &lt; 0 || this.lastWidth !== pw) {
                    this.lastWidth = pw;
                    this.brokenLines = this.breakToLines(pw);
                }
                return {
                    width  : pw,
                    height : this.brokenLines.length * this.getLineHeight() + (this.brokenLines.length - 1) * this.lineIndent
                };
            } else {
                return this.$super();
            }
        },

        function paint(g,x,y,w,h,d) {
            if (this.lastWidth &lt; 0 || this.lastWidth !== w) {
                this.lastWidth = w;
                this.brokenLines = this.breakToLines(w);
            }
            this.$super(g,x,y,w,h,d);
        }
    ]);

    pkg.DecoratedTextRender = zebkit.Class(pkg.TextRender, [
        function(text) {
            this.decorations = {
                underline : null,
                strike    : null
            };
            this.$super(text);
        },

        function $prototype() {
            this.lineWidth = 1;

            this.setDecoration = function(id, color) {
                if (id === null || typeof id === &#x27;undefined&#x27;) {
                    throw new Error();
                }
                this.decorations[id] = color;
                return this;
            };

            this.setDecorations = function(d) {
                this.decorations = zebkit.clone(d);
                // TODO: the method has to be replaced with addDecoration/clearDecoration
                if (typeof this.decorations.underline === &#x27;undefined&#x27;) {
                    this.decorations.underline = null;
                }

                if (typeof this.decorations.strike === &#x27;undefined&#x27;) {
                    this.decorations.strike = null;
                }

                return this;
            };
        },

        function paintLine(g,x,y,line,d) {
            this.$super(g,x,y,line,d);
            var lw = this.calcLineWidth(line),
                lh = this.getLineHeight(line);

            if (this.decorations.underline !== null) {
                g.lineWidth = this.lineWidth;
                g.setColor(this.decorations.underline);
                g.drawLine(x, y + lh - 1, x + lw, y  + lh - 1);
            }

            if (this.decorations.strike !== null) {
                var yy = y + Math.round(lh / 2) - 1;
                g.setColor(this.decorations.strike);
                g.lineWidth = this.lineWidth;
                g.drawLine(x, yy, x + lw, yy);
            }
        }
    ]);

    pkg.BoldTextRender = Class(pkg.TextRender, [
        function $clazz() {
            this.font = pkg.boldFont;
        }
    ]);

    /**
     * Password text render class. This class renders a secret text with hiding it with the given character.
     * @param {String|zebkit.data.TextModel} [text] a text as string or text model instance
     * @class zebkit.draw.PasswordText
     * @constructor
     * @extends zebkit.draw.TextRender
     */
    pkg.PasswordText = Class(pkg.TextRender, [
        function(text){
            if (arguments.length === 0) {
                text = new zebkit.data.SingleLineTxt(&quot;&quot;);
            }

            this.$super(text);
        },

        function $prototype() {
            /**
             * Echo character that will replace characters of hidden text
             * @attribute echo
             * @type {String}
             * @readOnly
             * @default &quot;*&quot;
             */
            this.echo = &quot;*&quot;;

            /**
             * Indicates if the last entered character doesn&#x27;t have to be replaced with echo character
             * @type {Boolean}
             * @attribute showLast
             * @default true
             * @readOnly
             */
            this.showLast = true;

            /**
             * Set the specified echo character. The echo character is used to hide secret text.
             * @param {String} ch an echo character
             * @method setEchoChar
             * @chainable
             */
            this.setEchoChar = function(ch){
                if (this.echo !== ch){
                    this.echo = ch;
                    if (this.target !== null) {
                        this.invalidate(0, this.target.getLines());
                    }
                }
                return this;
            };
        },

        function getLine(r){
            var buf = [], ln = this.$super(r);

            for(var i = 0;i &lt; ln.length; i++) {
                buf[i] = this.echo;
            }

            if (this.showLast &amp;&amp; ln.length &gt; 0) {
                buf[ln.length - 1] = ln[ln.length - 1];
            }

            return buf.join(&#x27;&#x27;);
        }
    ]);

    pkg.TabBorder = Class(pkg.View, [
        function(t, w) {
            if (arguments.length &gt; 1) {
                this.width  = w;
            }

            if (arguments.length &gt; 0) {
                this.state = t;
            }

            this.left = this.top = this.bottom = this.right = 6 + this.width;
        },

        function $prototype() {
            this.state  = &quot;out&quot;;
            this.width  = 1;

            this.fillColor1 = &quot;#DCF0F7&quot;;
            this.fillColor2 = &quot;white&quot;;
            this.fillColor3 = &quot;#F3F3F3&quot;;

            this.onColor1 = &quot;black&quot;;
            this.onColor2 = &quot;#D9D9D9&quot;;
            this.offColor = &quot;#A1A1A1&quot;;


            this.paint = function(g,x,y,w,h,d){
                var xx = x + w - 1,
                    yy = y + h - 1,
                    o  = d.parent.orient,
                    t  = this.state,
                    s  = this.width,
                    ww = 0,
                    hh = 0,
                    dt = s / 2;

                g.beginPath();
                g.lineWidth = s;
                switch(o) {
                    case &quot;left&quot;:
                        g.moveTo(xx + 1, y + dt);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(x + dt , y + s * 2);
                        g.lineTo(x + dt, yy - s * 2 + dt);
                        g.lineTo(x + s * 2, yy + dt);
                        g.lineTo(xx + 1, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(xx - ww + 1, y + s, ww, h - s - 1);
                        }

                        if (t === &quot;out&quot;) {
                            g.setColor(this.onColor2);
                            g.drawLine(x + 2*s + 1, yy - s, xx + 1, yy - s, s);
                        }
                        break;
                    case &quot;right&quot;:
                        xx -= dt; // thick line grows left side and right side proportionally
                                  // correct it

                        g.moveTo(x, y + dt);
                        g.lineTo(xx - 2 * s, y + dt);

                        g.lineTo(xx, y + 2 * s);
                        g.lineTo(xx, yy - 2 * s);
                        g.lineTo(xx - 2 * s, yy + dt);
                        g.lineTo(x, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(x, y + s, ww, h - s - 1);
                        }

                        if (t === &quot;out&quot;) {
                            g.setColor(this.onColor2);
                            g.drawLine(x, yy - s, xx - s - 1, yy - s, s);
                        }
                        break;
                    case &quot;top&quot;:
                        g.moveTo(x + dt, yy + 1 );
                        g.lineTo(x + dt, y + s*2);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(xx - s * 2 + s, y + dt);
                        g.lineTo(xx + dt, y + s * 2);
                        g.lineTo(xx + dt, yy + 1);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, yy - hh + 1 , w - s - 1, hh);
                        }

                        if (t === &quot;selected&quot;) {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, yy + 1);
                            g.lineTo(xx + dt - s, y + s * 2);
                            g.stroke();
                        }

                        break;
                    case &quot;bottom&quot;:
                        yy -= dt;

                        g.moveTo(x + dt, y);
                        g.lineTo(x + dt, yy - 2 * s);
                        g.lineTo(x + 2 * s + dt, yy);
                        g.lineTo(xx - 2 * s, yy);
                        g.lineTo(xx + dt, yy - 2 * s);
                        g.lineTo(xx + dt, y);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, y, w - s - 1, hh);
                        }

                        if (t === &quot;selected&quot;) {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, y);
                            g.lineTo(xx + dt - s, yy - s - 1);
                            g.stroke();
                        }
                        break;
                    default: throw new Error(&quot;Invalid tab alignment&quot;);
                }
            };

            this.getTop    = function () { return this.top;   };
            this.getBottom = function () { return this.bottom;};
            this.getLeft   = function () { return this.left;  };
            this.getRight  = function () { return this.right; };
        }
    ]);


    /**
     * Triangle shape view.
     * @param  {String}  [c]  a color of the shape
     * @param  {Integer} [w]  a line size
     * @class zebkit.draw.TriangleShape
     * @constructor
     * @extends zebkit.draw.Shape
     */
    pkg.TriangleShape = Class(pkg.Shape, [
        function $prototype() {
            this.outline = function(g,x,y,w,h,d) {
                g.beginPath();
                w -= 2 * this.width;
                h -= 2 * this.width;
                g.moveTo(x + w - 1, y);
                g.lineTo(x + w - 1, y + h - 1);
                g.lineTo(x, y + h - 1);
                g.closePath();
                return true;
            };
        }
    ]);

    /**
    * Vertical or horizontal linear gradient view
    * @param {String} startColor start color
    * @param {String} endColor end color
    * @param {String} [type] type of gradient
    *  &quot;vertical&quot; or &quot;horizontal&quot;
    * @constructor
    * @class zebkit.draw.Gradient
    * @extends zebkit.draw.View
    */
    pkg.Gradient = Class(pkg.View, [
        function() {
            /**
             * Gradient start and stop colors
             * @attribute colors
             * @readOnly
             * @type {Array}
             */

            this.colors = Array.prototype.slice.call(arguments, 0);
            if (arguments.length &gt; 2) {
                this.orient = arguments[arguments.length - 1];
                this.colors.pop();
            }
        },

        function $prototype() {
            /**
             * Gradient orientation: vertical or horizontal
             * @attribute orient
             * @readOnly
             * @default &quot;vertical&quot;
             * @type {String}
             */
            this.orient = &quot;vertical&quot;;
            this.gradient = null;
            this.gy2 = this.gy1 = this.gx2 = this.gx1 = 0;

            this.paint = function(g,x,y,w,h,dd){
                var d = (this.orient === &quot;horizontal&quot; ? [0,1]: [1,0]),
                    x1 = x * d[1],
                    y1 = y * d[0],
                    x2 = (x + w - 1) * d[1],
                    y2 = (y + h - 1) * d[0];

                if (this.gradient === null  || this.gx1 !== x1 ||
                    this.gx2 !== x2         || this.gy1 !== y1 ||
                    this.gy2 !== y2                              )
                {
                    this.gx1 = x1;
                    this.gx2 = x2;
                    this.gy1 = y1;
                    this.gy2 = y2;

                    this.gradient = g.createLinearGradient(x1, y1, x2, y2);
                    for(var i = 0; i &lt; this.colors.length; i++) {
                        this.gradient.addColorStop(i, this.colors[i].toString());
                    }
                }

                g.fillStyle = this.gradient;
                g.fillRect(x, y, w, h);
            };
        }
    ]);

    /**
    * Radial gradient view
    * @param {String} startColor a start color
    * @param {String} stopColor a stop color
    * @constructor
    * @class zebkit.draw.Radial
    * @extends zebkit.draw.View
    */
    pkg.Radial = Class(pkg.View, [
        function() {
            this.colors = [];
            for(var i = 0; i &lt; arguments.length; i++) {
                this.colors[i] = arguments[i] !== null ? arguments[i].toString() : null;
            }

            this.colors = Array.prototype.slice.call(arguments, 0);
        },

        function $prototype() {
            this.gradient = null;

            this.$cx1 = this.$cy1 = this.$rad1 = this.$rad2 = 0;
            this.$colors = [];

            this.radius = 10;

            this.paint = function(g,x,y,w,h,d){
                var cx1  = Math.floor(w / 2),
                    cy1  = Math.floor(h / 2),
                    rad2 = w &gt; h ? w : h;

                if (this.gradient === null     ||
                    this.$cx1  !== cx1         ||
                    this.$cy1  !== cy1         ||
                    this.$rad1 !== this.radius ||
                    this.$rad2 !== this.rad2      )
                {
                    this.gradient = g.createRadialGradient(cx1, cy1, this.radius, cx1, cy1, rad2);
                }

                var b = false;
                if (this.$colors.length !== this.colors.length ) {
                    b = true;
                } else {
                    for(var i = 0; i &lt; this.$colors.length; i++) {
                        if (this.$colors[i] !== this.colors[i]) {
                            b = true;
                            break;
                        }
                    }
                }

                if (b) {
                    for(var i = 0; i &lt; this.colors.length;i++) {
                        this.gradient.addColorStop(i, this.colors[i]);
                    }
                }

                g.fillStyle = this.gradient;
                g.fillRect(x, y, w, h);
            };
        }
    ]);

    /**
    * Image render. Render an image target object or specified area of
    * the given target image object.
    * @param {Image} img the image to be rendered
    * @param {Integer} [x] a x coordinate of the rendered image part
    * @param {Integer} [y] a y coordinate of the rendered image part
    * @param {Integer} [w] a width of the rendered image part
    * @param {Integer} [h] a height of the rendered image part
    * @constructor
    * @class zebkit.draw.Picture
    * @extends zebkit.draw.Render
    */
    pkg.Picture = Class(pkg.Render, [
        function(img,x,y,w,h) {
            /**
             * A x coordinate of the image part that has to be rendered
             * @attribute x
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A y coordinate of the image part that has to be rendered
             * @attribute y
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A width  of the image part that has to be rendered
             * @attribute width
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            /**
             * A height  of the image part that has to be rendered
             * @attribute height
             * @readOnly
             * @type {Integer}
             * @default 0
             */

            this.setValue(img);
            if (arguments.length &gt; 1) {
                this.x = x;
                if (arguments.length &gt; 2) {
                    this.y = y;
                    if (arguments.length &gt; 3) {
                        this.height = this.width = w;
                    }

                    if (arguments.length &gt; 4) {
                        this.height = h;
                    }
                }
            }
        },

        function $prototype() {
            this.x = this.y = this.width = this.height = 0;

            this.paint = function(g,x,y,w,h,d) {
                if (this.target !== null &amp;&amp; this.target.complete === true &amp;&amp; this.target.naturalWidth &gt; 0 &amp;&amp; w &gt; 0 &amp;&amp; h &gt; 0){
                    if (this.width &gt; 0) {
                        g.drawImage(this.target, this.x, this.y,
                                    this.width, this.height, x, y, w, h);
                    } else {
                        g.drawImage(this.target, x, y, w, h);
                    }
                }
            };

            this.getPreferredSize = function() {
                var img = this.target;
                return (img === null ||
                        img.naturalWidth &lt;= 0 ||
                        img.complete !== true) ? { width:0, height:0 }
                                               : (this.width &gt; 0) ? { width:this.width, height:this.height }
                                                                  : { width:img.width, height:img.height };
            };
        }
    ]);

    /**
    * Pattern render.
    * @class zebkit.draw.Pattern
    * @param {Image} [img] an image to be used as the pattern
    * @constructor
    * @extends zebkit.draw.Render
    */
    pkg.Pattern = Class(pkg.Render, [
        function $prototype() {
            /**
             * Buffered pattern
             * @type {Pattern}
             * @protected
             * @attribute pattern
             * @readOnly
             */
            this.pattern = null;

            this.paint = function(g,x,y,w,h,d) {
                if (this.pattern === null &amp;&amp; this.target !== null) {
                    this.pattern = g.createPattern(this.target, &#x27;repeat&#x27;);
                }
                g.beginPath();
                g.rect(x, y, w, h);
                g.closePath();
                g.fillStyle = this.pattern;
                g.fill();
            };

            this.valueWasChanged = function(o, n) {
                this.pattern = null;
            };
        }
    ]);

    /**
     * Line view.
     * @class  zebkit.draw.Line
     * @extends zebkit.draw.View
     * @constructor
     * @param  {String} [side] a side of rectangular area where the line has to be rendered. Use
     * &quot;left&quot;, &quot;top&quot;, &quot;right&quot; or &quot;bottom&quot; as the parameter value
     * @param  {String} [color] a line color
     * @param  {Integer} [width] a line width
     */
    pkg.LineView = Class(pkg.View, [
        function(side, color, lineWidth) {
            if (arguments.length &gt; 0) {
                this.side = zebkit.util.$validateValue(side, &quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;);
                if (arguments.length &gt; 1) {
                    this.color = color;
                    if (arguments.length &gt; 2) {
                        this.lineWidth = lineWidth;
                    }
                }
            }
        },

        function $prototype() {
            /**
             * Side the line has to be rendered
             * @attribute side
             * @type {String}
             * @default &quot;top&quot;
             * @readOnly
             */
            this.side = &quot;top&quot;;

            /**
             * Line color
             * @attribute color
             * @type {String}
             * @default &quot;black&quot;
             * @readOnly
             */
            this.color = &quot;black&quot;;

            /**
             * Line width
             * @attribute lineWidth
             * @type {Integer}
             * @default 1
             * @readOnly
             */
            this.lineWidth = 1;

            this.paint = function(g,x,y,w,h,t) {
                g.setColor(this.color);
                g.beginPath();
                g.lineWidth = this.lineWidth;

                var d = this.lineWidth / 2;
                if (this.side === &quot;top&quot;) {
                    g.moveTo(x, y + d);
                    g.lineTo(x + w - 1, y + d);
                } else if (this.side === &quot;bottom&quot;) {
                    g.moveTo(x, y + h - d);
                    g.lineTo(x + w - 1, y + h - d);
                } else if (this.side === &quot;left&quot;) {
                    g.moveTo(x + d, y);
                    g.lineTo(x + d, y + h - 1);
                } else if (this.side === &quot;right&quot;) {
                    g.moveTo(x + w - d, y);
                    g.lineTo(x + w - d, y + h - 1);
                } else if (this.side === &quot;verCenter&quot;) {
                    // TODO: not implemented
                } else if (this.side === &quot;horCenter&quot;) {
                    // TODO: not implemented
                }

                g.stroke();
            };

            this.getPreferredSize = function() {
                return {
                    width  : this.lineWidth,
                    height : this.lineWidth
                };
            };
        }
    ]);

    /**
     * Arrow view. Tye view can be use to render triangle arrow element to one of the
     * following direction: &quot;top&quot;, &quot;left&quot;, &quot;bottom&quot;, &quot;right&quot;.
     * @param  {String} d an arrow view direction.
     * @param  {String} col an arrow view color.
     * @param  {Integer} w an arrow view width.
     * @param  {Integer} h an arrow view height.
     * @constructor
     * @class zebkit.draw.ArrowView
     * @extends zebkit.draw.View
     */
    pkg.ArrowView = Class(pkg.View, [
        function (d, col, w, h) {
            if (arguments.length &gt; 0) {
                this.direction = d;
                if (arguments.length &gt; 1) {
                    this.color = col;
                    if (arguments.length &gt; 2) {
                        this.width = this.height = w;
                        if (arguments.length &gt; 3) {
                            this.height = h;
                        }
                    }
                }
            }
        },

        function $prototype() {
            /**
             *  Line width.
             *  @attribute lineWidth
             *  @type {Integer}
             *  @default 1
             */
            this.lineWidth = 1;

            /**
             *  Indicates if the arrow has to be filled with the arrow line color.
             *  @attribute fill
             *  @type {Boolean}
             *  @default true
             */
            this.fill = true;

            this.gap = 0;

            /**
             * Arrow color
             * @attribute color
             * @type {String}
             * @default &quot;black&quot;
             */
            this.color = &quot;black&quot;;

            /**
             * Arrow width.
             * @attribute width
             * @type {Integer}
             * @default 8
             */

             /**
              * Arrow height.
              * @attribute height
              * @type {Integer}
              * @default 8
              */
            this.width = this.height = 8;

            /**
             * Arrow direction.
             * @attribute direction
             * @type {String}
             * @default &quot;bottom&quot;
             */
            this.direction = &quot;bottom&quot;;

            this.outline = function(g, x, y, w, h, d) {
                x += this.gap;
                y += this.gap;
                w -= this.gap * 2;
                h -= this.gap * 2;

                var dt = this.lineWidth / 2,
                    w2 = Math.round(w / 2) - (w % 2 === 0 ? 0 : dt),
                    h2 = Math.round(h / 2) - (h % 2 === 0 ? 0 : dt);

                g.beginPath();

                if (&quot;bottom&quot; === this.direction) {
                    g.moveTo(x, y + dt);
                    g.lineTo(x + w - 1, y + dt);
                    g.lineTo(x + w2, y + h - dt);
                    g.lineTo(x + dt, y + dt);
                } else if (&quot;top&quot; === this.direction) {
                    g.moveTo(x, y + h - dt);
                    g.lineTo(x + w - 1, y + h - dt);
                    g.lineTo(x + w2, y);
                    g.lineTo(x + dt, y + h - dt);
                } else if (&quot;left&quot; === this.direction) {
                    g.moveTo(x + w - dt, y);
                    g.lineTo(x + w - dt, y + h - 1);
                    g.lineTo(x, y + h2);
                    g.lineTo(x + w + dt, y);
                } else if (&quot;right&quot; === this.direction) {
                    g.moveTo(x + dt, y);
                    g.lineTo(x + dt, y + h - 1);
                    g.lineTo(x + w, y + h2);
                    g.lineTo(x - dt, y);
                } else {
                    throw new Error(&quot;&quot; + this.direction);
                }

                return true;
            };

            this.setGap = function(gap) {
                this.gap = gap;
                return this;
            };

            this.paint = function(g, x, y, w, h, d) {
                this.outline(g, x, y, w, h, d);
                g.setColor(this.color);
                g.lineWidth = this.lineWidth;

                if (this.fill === true) {
                    g.fill();
                } else {
                    g.stroke();
                }
            };

            this.getPreferredSize = function () {
                return { width  : this.width  + this.gap * 2,
                         height : this.height + this.gap * 2 };
            };
        }
    ]);

    pkg.TabBorder = Class(pkg.View, [
        function(t, w) {
            if (arguments.length &gt; 1) {
                this.width  = w;
            }

            if (arguments.length &gt; 0) {
                this.state = t;
            }

            this.left = this.top = this.bottom = this.right = 6 + this.width;
        },

        function $prototype() {
            this.state  = &quot;out&quot;;
            this.width  = 1;

            this.fillColor1 = &quot;#DCF0F7&quot;;
            this.fillColor2 = &quot;white&quot;;
            this.fillColor3 = &quot;#F3F3F3&quot;;

            this.onColor1 = &quot;black&quot;;
            this.onColor2 = &quot;#D9D9D9&quot;;
            this.offColor = &quot;#A1A1A1&quot;;


            this.paint = function(g,x,y,w,h,d){
                var xx = x + w - 1,
                    yy = y + h - 1,
                    o  = d.parent.orient,
                    t  = this.state,
                    s  = this.width,
                    ww = 0,
                    hh = 0,
                    dt = s / 2;

                g.beginPath();
                g.lineWidth = s;
                switch(o) {
                    case &quot;left&quot;:
                        g.moveTo(xx + 1, y + dt);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(x + dt , y + s * 2);
                        g.lineTo(x + dt, yy - s * 2 + dt);
                        g.lineTo(x + s * 2, yy + dt);
                        g.lineTo(xx + 1, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(xx - ww + 1, y + s, ww, h - s - 1);
                        }

                        if (t === &quot;out&quot;) {
                            g.setColor(this.onColor2);
                            g.drawLine(x + 2*s + 1, yy - s, xx + 1, yy - s, s);
                        }
                        break;
                    case &quot;right&quot;:
                        xx -= dt; // thick line grows left side and right side proportionally
                                  // correct it

                        g.moveTo(x, y + dt);
                        g.lineTo(xx - 2 * s, y + dt);

                        g.lineTo(xx, y + 2 * s);
                        g.lineTo(xx, yy - 2 * s);
                        g.lineTo(xx - 2 * s, yy + dt);
                        g.lineTo(x, yy + dt);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true) {
                            ww = Math.floor((w - 6) / 2);
                            g.setColor(this.fillColor3);
                            g.fillRect(x, y + s, ww, h - s - 1);
                        }

                        if (t === &quot;out&quot;) {
                            g.setColor(this.onColor2);
                            g.drawLine(x, yy - s, xx - s - 1, yy - s, s);
                        }
                        break;
                    case &quot;top&quot;:
                        g.moveTo(x + dt, yy + 1 );
                        g.lineTo(x + dt, y + s*2);
                        g.lineTo(x + s * 2, y + dt);
                        g.lineTo(xx - s * 2 + s, y + dt);
                        g.lineTo(xx + dt, y + s * 2);
                        g.lineTo(xx + dt, yy + 1);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, yy - hh + 1 , w - s - 1, hh);
                        }

                        if (t === &quot;selected&quot;) {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, yy + 1);
                            g.lineTo(xx + dt - s, y + s * 2);
                            g.stroke();
                        }

                        break;
                    case &quot;bottom&quot;:
                        yy -= dt;

                        g.moveTo(x + dt, y);
                        g.lineTo(x + dt, yy - 2 * s);
                        g.lineTo(x + 2 * s + dt, yy);
                        g.lineTo(xx - 2 * s, yy);
                        g.lineTo(xx + dt, yy - 2 * s);
                        g.lineTo(xx + dt, y);

                        if (d.isEnabled === true){
                            g.setColor(t === &quot;over&quot; ? this.fillColor1 : this.fillColor2);
                            g.fill();
                        }

                        g.setColor((t === &quot;selected&quot; || t === &quot;over&quot;) ? this.onColor1 : this.offColor);
                        g.stroke();

                        if (d.isEnabled === true){
                            g.setColor(this.fillColor3);
                            hh = Math.floor((h - 6) / 2);
                            g.fillRect(x + s, y, w - s - 1, hh);
                        }

                        if (t === &quot;selected&quot;) {
                            g.setColor(this.onColor2);
                            g.beginPath();
                            g.moveTo(xx + dt - s, y);
                            g.lineTo(xx + dt - s, yy - s - 1);
                            g.stroke();
                        }
                        break;
                    default: throw new Error(&quot;Invalid tab alignment&quot;);
                }
            };

            this.getTop    = function () { return this.top;   };
            this.getBottom = function () { return this.bottom;};
            this.getLeft   = function () { return this.left;  };
            this.getRight  = function () { return this.right; };
        }
    ]);


    pkg.CheckboxView = Class(pkg.View, [
        function(color) {
            if (arguments.length &gt; 0) {
                this.color = color;
            }
        },

        function $prototype() {
            this.color = &quot;rgb(65, 131, 255)&quot;;

            this.paint = function(g,x,y,w,h,d){
                g.beginPath();
                g.strokeStyle = this.color;
                g.lineWidth = 2;
                g.moveTo(x + 1, y + 2);
                g.lineTo(x + w - 3, y + h - 3);
                g.stroke();
                g.beginPath();
                g.moveTo(x + w - 2, y + 2);
                g.lineTo(x + 2, y + h - 2);
                g.stroke();
                g.lineWidth = 1;
            };
        }
    ]);

    pkg.BunldeView = Class(pkg.View, [
        function(dir, color) {
            if (arguments.length &gt; 0) {
                this.direction = zebkit.util.$validateValue(dir, &quot;vertical&quot;, &quot;horizontal&quot;);
                if (arguments.length &gt; 1) {
                    this.color = color;
                }
            }
        },

        function $prototype() {
            this.color = &quot;#AAAAAA&quot;;
            this.direction = &quot;vertical&quot;;


            this.paint =  function(g,x,y,w,h,d) {
                g.beginPath();

                var  r = 0;
                if (this.direction === &quot;vertical&quot;) {
                    r = w/2;
                    g.arc(x + r, y + r, r, Math.PI, 0, false);
                    g.lineTo(x + w, y + h - r);
                    g.arc(x + r, y + h - r, r, 0, Math.PI, false);
                    g.lineTo(x, y + r);
                } else {
                    r = h/2;
                    g.arc(x + r, y + r, r, 0.5 * Math.PI, 1.5 * Math.PI, false);
                    g.lineTo(x + w - r, y);
                    g.arc(x + w - r, y + h - r, r, 1.5 * Math.PI, 0.5 * Math.PI, false);
                    g.lineTo(x + r, y + h);
                }
                g.setColor(this.color);
                g.fill();
            };
        }
    ]);

    /**
     * The radio button ticker view.
     * @class  zebkit.draw.RadioView
     * @extends zebkit.draw.View
     * @constructor
     * @param {String} [col1] color one to render the outer cycle
     * @param {String} [col2] color tow to render the inner cycle
     */
    pkg.RadioView = Class(pkg.View, [
        function(col1, col2) {
            if (arguments.length &gt; 0) {
                this.color1 = col1;
                if (arguments.length &gt; 1) {
                    this.color2 = col2;
                }
            }
        },

        function $prototype() {
            this.color1 = &quot;rgb(15, 81, 205)&quot;;
            this.color2 = &quot;rgb(65, 131, 255)&quot;;

            this.paint = function(g,x,y,w,h,d){
                g.beginPath();
                if (g.fillStyle != this.color1) {
                    g.fillStyle = this.color1;
                }
                g.arc(Math.floor(x + w/2), Math.floor(y + h/2) , Math.floor(w/3 - 0.5), 0, 2* Math.PI, 1, false);
                g.fill();

                g.beginPath();
                if (g.fillStyle != this.color2) {
                    g.fillStyle = this.color2;
                }
                g.arc(Math.floor(x + w/2), Math.floor(y + h/2) , Math.floor(w/4 - 0.5), 0, 2* Math.PI, 1, false);
                g.fill();
            };
        }
    ]);

    /**
     * Toggle view element class
     * @class  zebkit.draw.ToggleView
     * @extends zebkit.draw.View
     * @constructor
     * @param  {Boolean} [plus] indicates the sign type plus (true) or minus (false)
     * @param  {String}  [color] a color
     * @param  {String}  [bg] a background
     * @param  {Integer} [w] a width
     * @param  {Integer} [h] a height
     * @param  {zebkit.draw.View | String}  [br] a border view
     */
    pkg.ToggleView = Class(pkg.View, [
        function(plus, color, bg, w, h, br) {
            if (arguments.length &gt; 0) {
                this.plus = plus;
                if (arguments.length &gt; 1) {
                    this.color = color;
                    if (arguments.length &gt; 2) {
                        this.bg = bg;
                        if (arguments.length &gt; 3) {
                            this.width = this.height = w;
                            if (arguments.length &gt; 4) {
                                this.height = h;
                                if (arguments.length &gt; 5) {
                                    this.br = pkg.$view(br);
                                }
                            }
                        }
                    }
                }
            }
        },

        function $prototype() {
            this.color = &quot;white&quot;;
            this.bg    = &quot;lightGray&quot;;
            this.plus  = false;
            this.br    = new pkg.Border(&quot;rgb(65, 131, 215)&quot;, 1, 3);
            this.width = this.height = 12;

            this.paint = function(g, x, y, w, h, d) {
                if (this.bg !== null &amp;&amp; (this.br === null || this.br.outline(g, x, y, w, h, d) === false)) {
                    g.beginPath();
                    g.rect(x, y, w, h);
                }

                if (this.bg !== null) {
                    g.setColor(this.bg);
                    g.fill();
                }

                if (this.br !== null) {
                    this.br.paint(g, x, y, w, h, d);
                }

                g.setColor(this.color);
                g.lineWidth = 2;
                x += 2;
                w -= 4;
                h -= 4;
                y += 2;

                g.beginPath();
                g.moveTo(x, y + h / 2);
                g.lineTo(x + w, y + h / 2);
                if (this.plus) {
                    g.moveTo(x + w / 2, y);
                    g.lineTo(x + w / 2, y + h);
                }

                g.stroke();
                g.lineWidth = 1;
            };

            this.getPreferredSize = function() {
                return { width:this.width, height:this.height };
            };
        }
    ]);

    pkg.CaptionBgView = Class(pkg.View, [
        function(bg, gap, radius) {
            if (arguments.length &gt; 0) {
                this.bg = bg;
                if (arguments.length &gt; 1) {
                    this.gap = gap;

                    if (arguments.length &gt; 2) {
                        this.radius = radius;
                    }
                }
            }
        },

        function $prototype() {
            this.gap = this.radius = 6;
            this.bg  = &quot;#66CCFF&quot;;

            this.paint = function(g,x,y,w,h,d) {
                this.outline(g,x,y,w,h,d);
                g.setColor(this.bg);
                g.fill();
            };

            this.outline = function (g,x,y,w,h,d) {
                g.beginPath();
                g.moveTo(x + this.radius, y);
                g.lineTo(x + w - this.radius*2, y);
                g.quadraticCurveTo(x + w, y, x + w, y + this.radius);
                g.lineTo(x + w, y + h);
                g.lineTo(x, y + h);
                g.lineTo(x, y + this.radius);
                g.quadraticCurveTo(x, y, x + this.radius, y);
                return true;
            };
        }
    ]);

    /**
     * Base class to implement model values renders.
     * @param  {zebkit.draw.Render} [render] a render to visualize values. By default string render is used.
     * @class zebkit.draw.BaseViewProvider
     * @constructor
     */
    pkg.BaseViewProvider = Class([
        function(render) {
            /**
             * Default render that is used to paint grid content.
             * @type {zebkit.draw.Render}
             * @attribute render
             * @readOnly
             * @protected
             */
            this.render = (arguments.length === 0 || typeof render === &#x27;undefined&#x27; ? new zebkit.draw.StringRender(&quot;&quot;)
                                                                                   : render);
            zebkit.properties(this, this.clazz);
        },

        function $prototype() {
            /**
             * Set the default view provider font if defined render supports it
             * @param {zebkit.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                if (typeof this.render.setFont !== &#x27;undefined&#x27;) {
                    this.render.setFont(f);
                }
                return this;
            };

            /**
             * Set the default view provider color if defined render supports it
             * @param {String} c a color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                if (typeof this.render.setColor !== &#x27;undefined&#x27;) {
                    this.render.setColor(c);
                }
                return this;
            };

            /**
             * Get a view to render the specified value of the target component.
             * @param  {Object} target a target  component
             * @param  {Object} [arg]* arguments list
             * @param  {Object} obj a value to be rendered
             * @return {zebkit.draw.View}  an instance of view to be used to
             * render the given value
             * @method  getView
             */
            this.getView = function(target) {
                var obj = arguments[arguments.length - 1];
                if (obj !== null &amp;&amp; typeof obj !== &#x27;undefined&#x27;) {
                    if (typeof obj.toView !== &#x27;undefined&#x27;) {
                        return obj.toView();
                    } else if (typeof obj.paint !== &#x27;undefined&#x27;) {
                        return obj;
                    } else {
                        this.render.setValue(obj.toString());
                        return this.render;
                    }
                } else {
                    return null;
                }
            };
        }
    ]);
});
zebkit.package(&quot;ui.event&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;

   /**
    *  UI  event and event manager package.
    *  @class zebkit.ui.event
    *  @access package
    */

    /**
     *  UI manager class. The class is widely used as a basement for building various UI managers
     *  like focus, event managers etc. Manager is automatically registered as global events
     *  listener for events it implements to handle.
     *  @class zebkit.ui.event.Manager
     *  @constructor
     */
    pkg.Manager = Class([
        function() {
            //TODO: correct to event package
            if (zebkit.ui.events !== null &amp;&amp; typeof zebkit.ui.events !== &#x27;undefined&#x27;) {
                zebkit.ui.events.on(this);
            }
        }
    ]);

    /**
     * Component event class. Component events are fired when:
     *
     *   - a component is re-located (&quot;compMoved&quot; event)
     *   - a component is re-sized (&quot;compResized&quot; event)
     *   - a component visibility is updated (&quot;compShown&quot; event)
     *   - a component is enabled (&quot;compEnabled&quot; event)
     *   - a component has been inserted into another component (&quot;compAdded&quot; event)
     *   - a component has been removed from another component (&quot;compRemoved&quot; event)
     *
     * Appropriate event type is set in the event id property.
     * @constructor
     * @class   zebkit.ui.event.CompEvent
     * @extends zebkit.util.Event
     */
    pkg.CompEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * A kid component that has been added or removed (depending on event type).
             * @attribute kid
             * @readOnly
             * @default null
             * @type {zebkit.ui.Panel}
             */
            this.kid = this.constraints = null;

            /**
             * A constraints with that a kid component has been added or removed (depending on event type).
             * @attribute constraints
             * @readOnly
             * @default null
             * @type {Object}
             */

            /**
             * A previous x location the component has had.
             * @readOnly
             * @attribute prevX
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous y location the component has had.
             * @readOnly
             * @attribute prevY
             * @type {Integer}
             * @default -1
             */

            /**
             * An index at which a component has been added or removed.
             * @readOnly
             * @attribute index
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous width the component has had.
             * @readOnly
             * @attribute prevWidth
             * @type {Integer}
             * @default -1
             */

            /**
             * A previous height the component has had.
             * @readOnly
             * @attribute height
             * @type {Integer}
             * @default -1
             */
            this.prevX = this.prevY = this.index = -1;
            this.prevWidth = this.prevHeight = -1;
        }
    ]);

    /**
     * Input key event class.
     * @class  zebkit.ui.event.KeyEvent
     * @extends zebkit.util.Event
     * @constructor
     */
    pkg.KeyEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * A code of a pressed key
             * @attribute code
             * @readOnly
             * @type {Strung}
             */
            this.code = null;

            /**
             * A pressed key
             * @attribute key
             * @readOnly
             * @type {String}
             */
            this.key = null;

            /**
             * Input device type. Can be for instance &quot;keyboard&quot;, vkeyboard&quot; (virtual keyboard)
             * @attribute device
             * @default &quot;keyboard&quot;
             * @type {String}
             */
            this.device = &quot;keyboard&quot;;

            /**
             * Boolean that shows state of ALT key.
             * @attribute altKey
             * @type {Boolean}
             * @readOnly
             */
            this.altKey = false;

            /**
             * Boolean that shows state of SHIFT key.
             * @attribute shiftKey
             * @type {Boolean}
             * @readOnly
             */
            this.shiftKey = false;

            /**
             * Boolean that shows state of CTRL key.
             * @attribute ctrlKey
             * @type {Boolean}
             * @readOnly
             */
            this.ctrlKey = false;

            /**
             * Boolean that shows state of META key.
             * @attribute metaKey
             * @type {Boolean}
             * @readOnly
             */
            this.metaKey = false;

            /**
             * Repeat counter
             * @attribute repeat
             * @type {Number}
             */
            this.repeat = 0;

            /**
             * Time stamp
             * @attribute  timeStamp
             * @type {Number}
             */
            this.timeStamp = 0;

            /**
             * Get the given modifier key state. The following modifier key codes are supported:
             * &quot;Meta&quot;, &quot;Control&quot;, &quot;Shift&quot;, &quot;Alt&quot;.
             * @param  {String} m a modifier key code
             * @return {Boolean} true if the modifier key state is pressed.
             * @method getModifierState
             */
            this.getModifierState = function(m) {
                if (m === &quot;Meta&quot;) {
                    return this.metaKey;
                }

                if (m === &quot;Control&quot;) {
                    return this.ctrlKey;
                }

                if (m === &quot;Shift&quot;) {
                    return this.shiftKey;
                }

                if (m === &quot;Alt&quot;) {
                    return this.altKey;
                }

                throw new Error(&quot;Unknown modifier key &#x27;&quot; + m + &quot;&#x27;&quot;);
            };
        }
    ]);

    /**
     * Mouse and touch screen input event class. The input event is triggered by a mouse or
     * touch screen.
     * @class  zebkit.ui.event.PointerEvent
     * @extends zebkit.util.Event
     * @constructor
     */
    pkg.PointerEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Pointer type. Can be &quot;mouse&quot;, &quot;touch&quot;, &quot;pen&quot;
             * @attribute  poiterType
             * @type {String}
             */
            this.pointerType = &quot;mouse&quot;;

            /**
             * Touch counter
             * @attribute touchCounter
             * @type {Integer}
             * @default 0
             */
            this.touchCounter = 0;

            /**
             * Page x
             * @attribute pageX
             * @type {Integer}
             * @default -1
             */
            this.pageX = -1;

            /**
             * Page y
             * @attribute pageY
             * @type {Integer}
             * @default -1
             */
            this.pageY = -1;

            /**
             * Target DOM element
             * @attribute target
             * @type {DOMElement}
             * @default null
             */
            this.target = null;

            /**
             * Pointer identifier.
             * @attribute identifier
             * @type {Object}
             * @default null
             */
            this.identifier = null;

            this.shiftKey = this.altKey = this.metaKey = this.ctrlKey = false;

            this.pressure = 0.5;

            /**
             * Absolute mouse pointer x coordinate
             * @attribute absX
             * @readOnly
             * @type {Integer}
             */
            this.absX = 0;

            /**
             * Absolute mouse pointer y coordinate
             * @attribute absY
             * @readOnly
             * @type {Integer}
             */
             this.absY = 0;

            /**
             * Mouse pointer x coordinate (relatively to source UI component)
             * @attribute x
             * @readOnly
             * @type {Integer}
             */
            this.x = 0;

            /**
             * Mouse pointer y coordinate (relatively to source UI component)
             * @attribute y
             * @readOnly
             * @type {Integer}
             */
            this.y = 0;

            /**
             * Recompute the event relative location for the new source component and it
             * absolute location
             * @private
             * @param  {zebkit.ui.Panel} source  a source component that triggers the event
             * @param  {Integer} ax an absolute (relatively to a canvas where the source
             * component is hosted) x mouse cursor coordinate
             * @param  {Integer} ay an absolute (relatively to a canvas where the source
             * component is hosted) y mouse cursor coordinate
             * @method  updateCoordinates
             */
            this.update = function(source, ax, ay){
                // this can speed up calculation significantly check if source zebkit component
                // has not been changed, his location and parent component also has not been
                // changed than we can skip calculation of absolute location by traversing
                // parent hierarchy
                if (this.source        === source        &amp;&amp;
                    this.source.parent === source.parent &amp;&amp;
                    source.x           === this.$px      &amp;&amp;
                    source.y           === this.$py         )
                {
                    this.x += (ax - this.absX);
                    this.y += (ay - this.absY);
                    this.absX = ax;
                    this.absY = ay;
                    this.source = source;
                } else {
                    this.source = source;
                    this.absX = ax;
                    this.absY = ay;

                    // convert absolute location to relative location
                    while (source.parent !== null) {
                        ax -= source.x;
                        ay -= source.y;
                        source = source.parent;
                    }
                    this.x = ax;
                    this.y = ay;
                }

                this.$px = source.x;
                this.$py = source.y;
                return this;
            };

            this.isAction = function() {
                // TODO: actually this is abstract method
                throw new Error(&quot;Not implemented&quot;);
            };

            this.getTouches = function() {
                // TODO: actually this is abstract method
                throw new Error(&quot;Not implemented&quot;);
            };
        }
    ]);

    /**
     * Event manager class. One of the key zebkit manager that is responsible for distributing various
     * events in zebkit UI. The manager provides possibility to catch and handle UI events globally. Below
     * is list event types that can be caught with the event manager:
     *
     *   - Key events:
     *     - &quot;keyTyped&quot;
     *     - &quot;keyReleased&quot;
     *     - &quot;keyPressed&quot;
     *
     *   - Pointer events:
     *     - &quot;pointerDragged&quot;
     *     - &quot;pointerDragStarted&quot;
     *     - &quot;pointerDragEnded&quot;
     *     - &quot;pointerMoved&quot;
     *     - &quot;pointerClicked&quot;
     *     - &quot;pointerDoubleClicked&quot;
     *     - &quot;pointerPressed&quot;
     *     - &quot;pointerReleased&quot;
     *     - &quot;pointerEntered&quot;
     *     - &quot;pointerExited&quot;
     *
     *   - Focus event:
     *     - &quot;focusLost&quot;
     *     - &quot;focusGained&quot;
     *
     *   - Component events:
     *     - &quot;compSized&quot;
     *     - &quot;compMoved&quot;
     *     - &quot;compEnabled&quot;
     *     - &quot;compShown&quot;
     *     - &quot;compAdded&quot;
     *     - &quot;compRemoved&quot;
     *
     *   - Window events:
     *     - &quot;winOpened&quot;
     *     - &quot;winActivated&quot;
     *
     *   - Menu events:
     *     - &quot;menuItemSelected&#x27;
     *
     *   - Shortcut events:
     *     - &quot;shortcutFired&quot;
     *
     * Current events manager is available with &quot;zebkit.ui.events&quot;
     *
     * @class zebkit.ui.event.EventManager
     * @constructor
     * @extends zebkit.ui.event.Manager
     * @example
     *
     *     // catch all pointer pressed events that are triggered by zebkit UI
     *     zebkit.ui.events.on(&quot;pointerPressed&quot;, function(e) {
     *         // handle event
     *         ...
     *     });
     */
    pkg.EventManager = Class(pkg.Manager, zebkit.EventProducer, [
        function() {
            this._ = new this.clazz.Listerners();
            this.$super();
        },

        function $clazz() {
            var eventNames = [
                &#x27;keyTyped&#x27;,
                &#x27;keyReleased&#x27;,
                &#x27;keyPressed&#x27;,
                &#x27;pointerDragged&#x27;,
                &#x27;pointerDragStarted&#x27;,
                &#x27;pointerDragEnded&#x27;,
                &#x27;pointerMoved&#x27;,
                &#x27;pointerClicked&#x27;,
                &#x27;pointerDoubleClicked&#x27;,
                &#x27;pointerPressed&#x27;,
                &#x27;pointerReleased&#x27;,
                &#x27;pointerEntered&#x27;,
                &#x27;pointerExited&#x27;,

                &#x27;focusLost&#x27;,
                &#x27;focusGained&#x27;,

                &#x27;compSized&#x27;,
                &#x27;compMoved&#x27;,
                &#x27;compEnabled&#x27;,
                &#x27;compShown&#x27;,
                &#x27;compAdded&#x27;,
                &#x27;compRemoved&#x27;
            ];

            this.$CHILD_EVENTS_MAP = {};

            // add child&lt;eventName&gt; events names mapping
            for(var i = 0; i &lt; eventNames.length; i++) {
                var eventName = eventNames[i];
                this.$CHILD_EVENTS_MAP[eventName] = &quot;child&quot; + eventName[0].toUpperCase() + eventName.substring(1);
            }

            this.Listerners = zebkit.util.ListenersClass.apply(this, eventNames);
        },

        function $prototype(clazz) {
            var $CEM = clazz.$CHILD_EVENTS_MAP;

            this.regEvents = function() {
                this._.addEvents.apply(this._, arguments);

                // add child&lt;eventName&gt; events names mapping
                for(var i = 0; i &lt; arguments.length; i++) {
                    var eventName = arguments[i];
                    $CEM[eventName] = &quot;child&quot; + eventName[0].toUpperCase() + eventName.substring(1);
                }
            };

            /**
             * Fire event with the given id
             * @param  {String} id an event id type
             * @param  {zebkit.util.Event} e different sort of event
             * @return {Boolean} boolean flag that indicates if a event handling has been interrupted on one of a stage:
             *
             *    - Suppressed by a target component
             *    - By a global listener
             *    - By a target component event listener
             *
             * @method  fire
             * @protected
             */
            this.fire = function(id, e) {
                var childEvent = $CEM[id];

                // assign id that matches method to be called
                e.id = id;

                // TODO: not stable concept. the idea to suppress event
                // distribution to global listeners (managers) and child
                // components
                if (typeof e.source.suppressEvent !== &#x27;undefined&#x27; &amp;&amp;
                    e.source.suppressEvent(e) === true)
                {
                    return true;
                }

                // call global listeners
                if (this._[id](e) === false) {
                    // call target component listener
                    if (typeof e.source[id] !== &#x27;undefined&#x27; &amp;&amp; e.source[id].call(e.source, e) === true) {
                        return true;
                    }

                    // call parent listeners
                    for(var t = e.source.parent; t !== null; t = t.parent){
                        if (typeof t[childEvent] !== &#x27;undefined&#x27;) {
                            t[childEvent].call(t, e);
                        }
                    }

                    return false;
                } else {
                    return true;
                }
            };
        }
    ]);

    /**
     * Event manager reference. The reference can be used to register listeners that can
     * get all events of the given type that are fired by zebkit UI. For instance you can
     * catch all pointer pressed events as follow:
     * @example
     *
     *     zebkit.ui.events.on(&quot;pointerPressed&quot;, function(e) {
     *         // handle pointer pressed event here
     *         ...
     *     });
     *
     * @attribute events
     * @type {zebkit.ui.event.EventManager}
     * @readOnly
     */

     // TODO: correct to event package
     //this.events = new pkg.EventManager();
     zebkit.ui.events = new pkg.EventManager();

     /**
      * Base class to implement clipboard manager.
      * @class zebkit.ui.event.Clipboard
      * @constructor
      * @extends zebkit.ui.event.Manager
      */
     pkg.Clipboard = Class(pkg.Manager, [
         function $prototype() {
             /**
              * Get destination component. Destination component is a component that
              * is currently should participate in clipboard data exchange.
              * @return {zebkit.ui.Panel} a destination component.
              * @method getDestination
              */
             this.getDestination = function() {
                 //TODO: may be focusManager has to be moved to &quot;ui.event&quot; package
                 return zebkit.ui.focusManager.focusOwner;
             };
         }
     ]);

     /**
      * Base class to implement cursor manager.
      * @class zebkit.ui.event.CursorManager
      * @constructor
      * @extends zebkit.ui.event.Manager
      */
     pkg.CursorManager = Class(pkg.Manager, [
        function $prototype() {
            /**
             * Current cursor type
             * @attribute cursorType
             * @type {String}
             * @readOnly
             * @default &quot;default&quot;
             */
            this.cursorType = &quot;default&quot;;
        }
     ]);


    /**
     * Focus event class.
     * @class zebkit.ui.event.FocusEvent
     * @constructor
     * @extends zebkit.util.Event
     */
    pkg.FocusEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Related to the event component. For focus gained event it should be a component
             * that lost focus. For focus lost event it should be a component that is going to
             * get a focus.
             * @attribute related
             * @readOnly
             * @default null
             * @type {zebkit.ui.Panel}
             */
            this.related = null;
        }
    ]);

    var FOCUS_EVENT = new pkg.FocusEvent();

    /**
     * Focus manager class defines the strategy of focus traversing among hierarchy of UI components.
     * It keeps current focus owner component and provides API to change current focus component
     * @class zebkit.ui.event.FocusManager
     * @constructor
     * @extends zebkit.ui.event.Manager
     */
    pkg.FocusManager = Class(pkg.Manager, [
        function $prototype() {
            /**
             * Reference to the current focus owner component.
             * @attribute focusOwner
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.focusOwner = null;

            this.$freeFocus = function(comp) {
                if ( this.focusOwner !== null &amp;&amp;
                    (this.focusOwner === comp || zebkit.layout.isAncestorOf(comp, this.focusOwner)))
                {
                    this.requestFocus(null);
                }
            };

            /**
             * Component enabled event handler
             * @param  {zebkit.ui.Panel} c a component
             * @method compEnabled
             */
            this.compEnabled = function(e) {
                var c = e.source;
                if (c.isVisible === true &amp;&amp; c.isEnabled === false &amp;&amp; this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Component shown event handler
             * @param  {zebkit.ui.Panel} c a component
             * @method compShown
             */
            this.compShown = function(e) {
                var c = e.source;
                if (c.isEnabled === true &amp;&amp; c.isVisible === false &amp;&amp; this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Component removed event handler
             * @param  {zebkit.ui.Panel} p a parent
             * @param  {Integer} i      a removed component index
             * @param  {zebkit.ui.Panel} c a removed component
             * @method compRemoved
             */
            this.compRemoved = function(e) {
                var c = e.kid;
                if (c.isEnabled === true &amp;&amp; c.isVisible === true &amp;&amp; this.focusOwner !== null) {
                    this.$freeFocus(c);
                }
            };

            /**
             * Test if the given component is a focus owner
             * @param  {zebkit.ui.Panel} c an UI component to be tested
             * @method hasFocus
             * @return {Boolean} true if the given component holds focus
             */
            this.hasFocus = function(c) {
                return this.focusOwner === c;
            };

            /**
             * Key pressed event handler.
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                if (&quot;Tab&quot; === e.code) {
                    var cc = this.ff(e.source, e.shiftKey ?  -1 : 1);
                    if (cc !== null) {
                        this.requestFocus(cc);
                    }
                    return true;
                }
            };

            /**
             * Find next candidate to grab focus starting from the given component.
             * @param  {zebkit.ui.Panel} c a component to start looking for next focusable.
             * @return {zebkit.ui.Panel} a next component to gain focus.
             * @method findFocusable
             */
            this.findFocusable = function(c) {
                return (this.isFocusable(c) ? c : this.fd(c, 0, 1));
            };

            /**
             * Test if the given component can catch focus
             * @param  {zebkit.ui.Panel} c an UI component to be tested
             * @method isFocusable
             * @return {Boolean} true if the given component can catch a focus
             */
            this.isFocusable = function(c) {
                var d = c.getCanvas();
                if (d !== null &amp;&amp;
                       (c.canHaveFocus === true ||
                         (typeof c.canHaveFocus === &quot;function&quot; &amp;&amp; c.canHaveFocus() === true)))
                {
                    for(;c !== d &amp;&amp; c !== null; c = c.parent) {
                        if (c.isVisible === false || c.isEnabled === false) {
                            return false;
                        }
                    }
                    return c === d;
                }

                return false;
            };

            // looking recursively a focusable component among children components of
            // the given target  starting from the specified by index kid with the
            // given direction (forward or backward lookup)
            this.fd = function(t, index, d) {
                if (t.kids.length &gt; 0){
                    var isNComposite = typeof t.catchInput === &#x27;undefined&#x27; || t.catchInput === false;
                    for(var i = index; i &gt;= 0 &amp;&amp; i &lt; t.kids.length; i += d) {
                        var cc = t.kids[i];

                        // check if the current children component satisfies
                        // conditions it can grab focus or any deeper in hierarchy
                        // component that can grab the focus exist
                        if (cc.isEnabled === true                                           &amp;&amp;
                            cc.isVisible === true                                           &amp;&amp;
                            cc.width      &gt;  0                                              &amp;&amp;
                            cc.height     &gt;  0                                              &amp;&amp;
                            (isNComposite || (t.catchInput !== true      &amp;&amp;
                                              t.catchInput(cc) === false)  )                &amp;&amp;
                            ( (cc.canHaveFocus === true || (typeof cc.canHaveFocus !== &#x27;undefined&#x27;  &amp;&amp;
                                                            cc.canHaveFocus !== false &amp;&amp;
                                                            cc.canHaveFocus())            ) ||
                              (cc = this.fd(cc, d &gt; 0 ? 0 : cc.kids.length - 1, d)) !== null)  )
                        {
                            return cc;
                        }
                    }
                }

                return null;
            };

            // find next focusable component
            // c - component starting from that a next focusable component has to be found
            // d - a direction of next focusable component lookup: 1 (forward) or -1 (backward)
            this.ff = function(c, d) {
                var top = c;
                while (top !== null &amp;&amp; typeof top.getFocusRoot === &#x27;undefined&#x27;) {
                    top = top.parent;
                }

                if (top === null) {
                    return null;
                }

                top = top.getFocusRoot();
                if (top === null) {
                    return null;
                }

                if (typeof top.traverseFocus !== &#x27;undefined&#x27;) {
                    return top.traverseFocus(c, d);
                }

                for(var index = (d &gt; 0) ? 0 : c.kids.length - 1; c !== top.parent; ){
                    var cc = this.fd(c, index, d);
                    if (cc !== null) {
                        return cc;
                    }
                    cc = c;
                    c = c.parent;
                    if (c !== null) {
                        index = d + c.indexOf(cc);
                    }
                }

                return this.fd(top, d &gt; 0 ? 0 : top.kids.length - 1, d);
            };

            /**
             * Force to pass a focus to the given UI component
             * @param  {zebkit.ui.Panel} c an UI component to pass a focus
             * @method requestFocus
             */
            this.requestFocus = function(c) {
                if (c !== this.focusOwner &amp;&amp; (c === null || this.isFocusable(c))) {
                    var oldFocusOwner = this.focusOwner;
                    if (c !== null) {
                        var nf = c.getEventDestination();
                        if (nf === null || oldFocusOwner === nf) {
                            return;
                        }
                        this.focusOwner = nf;
                    } else {
                        this.focusOwner = c;
                    }

                    if (oldFocusOwner !== null) {
                        FOCUS_EVENT.source  = oldFocusOwner;
                        FOCUS_EVENT.related = this.focusOwner;
                        oldFocusOwner.focused();
                        zebkit.ui.events.fire(&quot;focusLost&quot;, FOCUS_EVENT);
                    }

                    if (this.focusOwner !== null) {
                        FOCUS_EVENT.source  = this.focusOwner;
                        FOCUS_EVENT.related = oldFocusOwner;
                        this.focusOwner.focused();
                        zebkit.ui.events.fire(&quot;focusGained&quot;, FOCUS_EVENT);
                    }
                }
            };

            /**
             * Pointer pressed event handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e){
                if (e.isAction()) {
                    this.requestFocus(e.source);
                }
            };
        }
    ]);


    // add shortcut event type
    zebkit.ui.events.regEvents(&quot;shortcutFired&quot;);

    /**
     * Shortcut event class
     * @constructor
     * @param  {zebkit.ui.Panel} src a source of the event
     * @param  {String} shortcut a shortcut name
     * @param  {String} keys a keys combination (&quot;Control + KeyV&quot;)
     * @class zebkit.ui.event.ShortcutEvent
     * @extends zebkit.util.Event
     */
    pkg.ShortcutEvent = Class(zebkit.util.Event, [
        function(src, shortcut, keys) {
            this.source = src;

            /**
             * Shortcut name
             * @attribute shortcut
             * @readOnly
             * @type {String}
             */
            this.shortcut = shortcut;

            /**
             * Shortcut keys combination
             * @attribute keys
             * @readOnly
             * @type {String}
             */
            this.keys = keys;
        }
    ]);

    var SHORTCUT_EVENT = new pkg.ShortcutEvent();

    /**
     *  Shortcut manager supports short cut (keys) definition and listening. The shortcuts have to be defined in
     *  zebkit JSON configuration files. There are two sections:

        - **osx** to keep shortcuts for Mac OS X platform
        - **common** to keep shortcuts for all other platforms

     *  The JSON configuration entity has simple structure:


          {
            &quot;common&quot;: {
                &quot;UNDO&quot;: &quot;Control + KeyZ&quot;,
                &quot;REDO&quot;: &quot;Control + Shift + KeyZ&quot;,
                 ...
            },
            &quot;osx&quot; : {
                &quot;UNDO&quot;:  &quot;MetaLeft + KeyZ&quot;,
                 ...
            }
          }

     *  The configuration contains list of shortcuts. Every shortcut is bound to a key combination that triggers it.
     *  Shortcut has a name and an optional list of arguments that have to be passed to a shortcut listener method.
     *  The optional arguments can be used to differentiate two shortcuts that are bound to the same command.
     *
     *  On the component level shortcut can be listened by implementing &quot;shortcutFired(e)&quot; listener handler.
     *  Pay attention to catch shortcut your component has to be focusable - be able to hold focus.
     *  For instance, to catch &quot;UNDO&quot; shortcut do the following:

            var pan = new zebkit.ui.Panel([
                function shortcutFired(e) {
                    // handle shortcut here
                    if (e.shortcut === &quot;UNDO&quot;) {

                    }
                },

                // visualize the component gets focus
                function focused() {
                    this.$super();
                    this.setBackground(this.hasFocus()?&quot;red&quot;:null);
                }
            ]);

            // let our panel to hold focus by setting appropriate property
            pan.canHaveFocus = true;


     *  @constructor
     *  @class zebkit.ui.event.ShortcutManager
     *  @extends zebkit.ui.event.Manager
     */
    pkg.ShortcutManager = Class(pkg.Manager, [
        function(shortcuts) {
            this.$super();

            // special structure that is a path from the first key of a sjortcut to the ID
            // for instance SELECTALL : [ &quot;Control + KeyA&quot;, &quot;Control + KeyW&quot;], ... } will
            // be stored as:
            //  {
            //     &quot;Control&quot; : {
            //         &quot;KeyA&quot; : SELECTALL,
            //         &quot;KeyW&quot; : SELECTALL
            //     }
            //  }

            this.keyShortcuts = {};

            if (arguments.length &gt; 0) {
                this.setShortcuts(shortcuts.common);
                if (zebkit.isMacOS === true &amp;&amp; typeof shortcuts.osx !== &#x27;undefined&#x27;) {
                    this.setShortcuts(shortcuts.osx);
                }
            }
        },

        function $prototype() {
            this.keyPath = [];

            /**
             * Key pressed event handler.
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e) {
                if (e.code === null || this.keyPath.length &gt; 5) {
                    this.keyPath = [];
                } else if (e.repeat === 1) {
                    this.keyPath[this.keyPath.length] = e.code;
                }

                // TODO: may be focus manager has to be moved to &quot;ui.event&quot; package
                var fo = zebkit.ui.focusManager.focusOwner;
                if (this.keyPath.length &gt; 1) {
                    var sh = this.keyShortcuts;
                    for(var i = 0; i &lt; this.keyPath.length; i++) {
                        var code = this.keyPath[i];
                        if (sh.hasOwnProperty(code)) {
                            sh = sh[code];
                        } else {
                            sh = null;
                            break;
                        }
                    }

                    if (sh !== null) {
                        SHORTCUT_EVENT.source   = fo;
                        SHORTCUT_EVENT.shortcut = sh;
                        SHORTCUT_EVENT.keys     = this.keyPath.join(&#x27;+&#x27;);
                        zebkit.ui.events.fire(&quot;shortcutFired&quot;, SHORTCUT_EVENT);
                    }
                }
            };

            this.keyReleased = function(e) {
                if (e.key === &quot;Meta&quot;) {
                    this.keyPath = [];
                } else {
                    for(var i = 0; i &lt; this.keyPath.length; i++) {
                        if (this.keyPath[i] === e.code) {
                            this.keyPath.splice(i, 1);
                            break;
                        }
                    }
                }
            };

            /**
             * Set shortcuts. Expected shortcuts format is:
             *
             *      { &quot;&lt;ID&gt;&quot;  : &quot;Control + KeyZ&quot;, ... }
             *
             * or
             *
             *       { &quot;&lt;ID&gt;&quot;  :  [&quot;Control + KeyZ&quot;, &quot;Control + KeyV&quot; ], ... }
             *
             * @param {shortcuts} shortcuts
             * @method setShortcuts
             */
            this.setShortcuts = function(shortcuts) {
                for (var id in shortcuts) {
                    var shortcut = shortcuts[id];
                    id = id.trim();

                    if (Array.isArray(shortcut) === false) {
                        shortcut = [ shortcut ];
                    }

                    for(var j = 0; j &lt; shortcut.length; j++) {
                        var keys  = shortcut[j].replace(/\s+/g, &#x27;&#x27;).split(&#x27;+&#x27;),
                            st    = this.keyShortcuts,
                            len   = keys.length;

                        for(var i = 0; i &lt; len; i++) {
                            var key = keys[i];
                            if (i === (len - 1)) {
                                st[key] = id;
                            } else if (st.hasOwnProperty(key) === false || zebkit.isString(st[key])) {
                                st[key] = {};
                            }

                            st = st[key];
                        }
                    }
                }
            };
        }
    ]);
});
zebkit.package(&quot;ui&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    // Panel WEB specific dependencies:
    //   -  getCanvas() -&gt; zCanvas
    //      -  $da (dirty area)
    //      -  $isRootCanvas
    //      -  $waitingForPaint (created and controlled by Panel painting !)
    //      -  $context
    //          - restore(...)
    //          - restoreAll(...)
    //          - save()
    //          - clipRect(...)
    //          - clip()
    //          - clearRect(...)
    //          - translate(...)
    //          - $states[g.$curState] ?
    //
    // Panel zebkit classes dependencies
    //   - ui.CompEvent
    //   - ui.events EventManager
    //   - util.*


    /**
     *  Zebkit UI package contains a lot of various components. Zebkit UI idea is rendering
     *  hierarchy of UI components on a canvas (HTML5 Canvas). Typical zebkit application
     *  looks as following:
     *
     *       zebkit.require(&quot;ui&quot;, &quot;layout&quot;, function(ui) {
     *           // create canvas and save reference to root layer
     *           // where zebkit UI components should live.
     *           var root = new ui.zCanvas(400, 400).root;
     *
     *           // build UI layout
     *           root.properties({
     *               layout : new layout.BorderLayout(4),
     *               padding: 8,
     *               kids   : {
     *                   &quot;center&quot; : new ui.TextArea(&quot;A text&quot;),
     *                   &quot;top&quot;    : new ui.ToolbarPan().properties({
     *                       kids : [
     *                           new ui.ImagePan(&quot;icon1.png&quot;),
     *                           new ui.ImagePan(&quot;icon2.png&quot;),
     *                           new ui.ImagePan(&quot;icon3.png&quot;)
     *                      ]
     *                   }),
     *                   &quot;bottom&quot; : new ui.Button(&quot;Apply&quot;)
     *               }
     *           });
     *       });
     *
     *  UI components are ordered with help of layout managers. You should not use absolute
     *  location or size your component. It is up to layout manager to decide which size and
     *  location the given  component has to have. In the example above we add number of UI
     *  components to &quot;root&quot; (UI Panel). The root panel uses &quot;BorderLayout&quot; [to order the
     *  added components. The layout manager split root area to number of areas: &quot;center&quot;,
     *  &quot;top&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot; where children components can be placed.
     *
     *  @class zebkit.ui
     *  @access package
     */


    // TODO: not stable API
    pkg.$configWith = function(pkg, path) {
        if (arguments.length &lt; 2) {
            var fn = pkg.fullname();
            path = fn.substring(fn.indexOf(&#x27;.&#x27;) + 1) + &quot;.json&quot;;
        }

        if (path[0] !== &#x27;/&#x27;) {
            var root = zebkit.config[&#x27;ui.theme.path&#x27;];
            if (typeof root === &quot;undefined&quot;) {
                root =  typeof zebkit.config[&#x27;ui.theme.name&#x27;] === &#x27;undefined&#x27; ? &quot;rs/themes/dark&quot;
                                                                              : &quot;rs/themes/&quot; + zebkit.config[&#x27;ui.theme.name&#x27;];
            }

            if (root[0] !== &#x27;/&#x27;) {
            path = zebkit.URI.join(zebkit.ui.$url, root, path);
            } else {
                path = zebkit.URI.join(root, path);
            }
        }

        // it guarantees that loading if JSONs will be done sequentially in
        // the order the JSON appeared
        zebkit.then(function() { // calling the guarantees it will be called when previous actions are completed
            this.till(new zebkit.util.Zson(pkg).then(path)); // now we can trigger other loading action
        });
    };


    // extend Zson with special method to fill prederfined views set
    zebkit.util.Zson.prototype.views = function(v) {
        for (var k in v) {
            if (v.hasOwnProperty(k)) {
                zebkit.draw.$views[k] = v[k];
            }
        }
    };


    // TODO: prototype of zClass, too simple to say something
    pkg.zCanvas = Class([]);

    /**
     * Get preferred size shortcut. Null can be passed as the method argument
     * @private
     * @param  {zebkit.ui.Layoutable} l a layoutable component
     * @return {Object}  a preferred size:
     *      { width : {Integer}, height: {Integer} }
     * @method $getPS
     * @for zebkit.ui
     */
    pkg.$getPS = function(l) {
        return l !== null &amp;&amp; l.isVisible === true ? l.getPreferredSize()
                                                  : { width:0, height:0 };
    };

    /**
     * Calculate visible area of the given components taking in account
     * intersections with parent hierarchy.
     * @private
     * @param  {zebkit.ui.Panel} c  a component
     * @param  {Object} r a variable to store visible area

            { x: {Integer}, y: {Integer}, width: {integer}, height: {Integer} }

     * @method $cvp
     * @for zebkit.ui
     */
    pkg.$cvp = function(c, r) {
        if (c.width &gt; 0 &amp;&amp; c.height &gt; 0 &amp;&amp; c.isVisible === true){
            var p  = c.parent,
                px = -c.x,
                py = -c.y;

            if (arguments.length &lt; 2) {
                r = { x:0, y:0, width : c.width, height : c.height };
            } else {
                r.x = r.y = 0;
                r.width  = c.width;
                r.height = c.height;
            }

            while (p !== null &amp;&amp; r.width &gt; 0 &amp;&amp; r.height &gt; 0) {
                var xx = r.x &gt; px ? r.x : px,
                    yy = r.y &gt; py ? r.y : py,
                    w1 = r.x + r.width,
                    w2 = px  + p.width,
                    h1 = r.y + r.height,
                    h2 = py  + p.height;

                r.width  = (w1 &lt; w2 ? w1 : w2) - xx;
                r.height = (h1 &lt; h2 ? h1 : h2) - yy;
                r.x = xx;
                r.y = yy;

                px -= p.x;
                py -= p.y;
                p = p.parent;
            }

            return r.width &gt; 0 &amp;&amp; r.height &gt; 0 ? r : null;
        }
        return null;
    };

    /**
     * Relocate the given component to make them fully visible.
     * @param  {zebkit.ui.Panel} [d] a parent component where the given component has to be re-located
     * @param  {zebkit.ui.Panel} c  a component to re-locate to make it fully visible in the parent
     * component
     * @method makeFullyVisible
     * @for  zebkit.ui
     */
    pkg.makeFullyVisible = function(d, c){
        if (arguments.length === 1) {
            c = d;
            d = c.parent;
        }

        var right  = d.getRight(),
            top    = d.getTop(),
            bottom = d.getBottom(),
            left   = d.getLeft(),
            xx     = c.x,
            yy     = c.y;

        if (xx &lt; left) {
            xx = left;
        }

        if (yy &lt; top)  {
            yy = top;
        }

        if (xx + c.width &gt; d.width - right) {
            xx = d.width + right - c.width;
        }

        if (yy + c.height &gt; d.height - bottom) {
            yy = d.height + bottom - c.height;
        }
        c.setLocation(xx, yy);
    };

    pkg.calcOrigin = function(x,y,w,h,px,py,t,tt,ll,bb,rr){
        if (arguments.length &lt; 8) {
        tt = t.getTop();
            ll = t.getLeft();
            bb = t.getBottom();
            rr = t.getRight();
        }

        var dw = t.width, dh = t.height;
        if (dw &gt; 0 &amp;&amp; dh &gt; 0){
            if (dw - ll - rr &gt; w){
                var xx = x + px;
                if (xx &lt; ll) {
                    px += (ll - xx);
                } else {
                    xx += w;
                    if (xx &gt; dw - rr) {
                        px -= (xx - dw + rr);
                    }
                }
            }
            if (dh - tt - bb &gt; h){
                var yy = y + py;
                if (yy &lt; tt) {
                    py += (tt - yy);
                } else {
                    yy += h;
                    if (yy &gt; dh - bb) {
                        py -= (yy - dh + bb);
                    }
                }
            }
            return [px, py];
        }
        return [0, 0];
    };


    var $paintTask = null,
        $paintTasks = [],
        temporary = { x:0, y:0, width:0, height:0 },
        COMP_EVENT = new zebkit.ui.event.CompEvent();

    /**
     * Trigger painting for all collected paint tasks
     * @protected
     * @method $doPaint
     * @for zebkit.ui
     */
    pkg.$doPaint = function() {
        for (var i = $paintTasks.length - 1; i &gt;= 0; i--) {
            var canvas = $paintTasks.shift();
            try {
                // do validation before timer will be set to null to avoid
                // unnecessary timer initiating what can be caused by validation
                // procedure by calling repaint method
                if (canvas.isValid === false || canvas.isLayoutValid === false) {
                    canvas.validate();
                }

                if (canvas.$da.width &gt; 0) {
                    canvas.$context.save();

                    // check if the given canvas has transparent background
                    // if it is true call clearRect method to clear dirty area
                    // with transparent background, otherwise it will be cleaned
                    // by filling the canvas with background later
                    if (canvas.bg === null || canvas.bg.isOpaque !== true) {
                        canvas.$context.clearRect(canvas.$da.x, canvas.$da.y,
                                                  canvas.$da.width, canvas.$da.height);
                    }
                    // !!!
                    // call clipping area later than possible
                    // clearRect since it can bring to error in IE
                    canvas.$context.clipRect(canvas.$da.x,
                                             canvas.$da.y,
                                             canvas.$da.width,
                                             canvas.$da.height);

                    // no dirty area anymore. put it hear to prevent calling
                    // animation  task from repaint() method that can be called
                    // inside paintComponent method.
                    canvas.$da.width = -1;

                    // clear flag that says the canvas is waiting for repaint, that allows to call
                    // repaint from paint method
                    canvas.$waitingForPaint = false;

                    canvas.paintComponent(canvas.$context);
                    canvas.$context.restore();
                } else {
                    canvas.$waitingForPaint = false;
                }
            } catch(ex) {
                // catch error and clean task list if any to avoid memory leaks
                try {
                    if (canvas !== null) {
                        canvas.$waitingForPaint = false;
                        canvas.$da.width = -1;
                        if (canvas.$context !== null) {
                            canvas.$context.restoreAll();
                        }
                    }
                } catch(exx) {
                    $paintTask = null;
                    $paintTasks.length = 0;
                    throw exx;
                }

                zebkit.dumpError(ex);
            }
        }

        // paint task is done
        $paintTask = null;

        // test if new dirty canvases have appeared and start
        // animation again
        if ($paintTasks.length !== 0) {
            $paintTask = zebkit.environment.animate(pkg.$doPaint);
        }
    };

    /**
     *  This the core UI component class. All other UI components has to be successor of panel class.

          // instantiate panel with no arguments
          var p = new zebkit.ui.Panel();

          // instantiate panel with border layout set as its layout manager
          var p = new zebkit.ui.Panel(new zebkit.layout.BorderLayout());

          // instantiate panel with the given properties (border
          // layout manager, blue background and plain border)
          var p = new zebkit.ui.Panel({
             layout: new zebkit.ui.BorderLayout(),
             background : &quot;blue&quot;,
             border     : &quot;plain&quot;
          });

     *  **Container**
     * Panel can contains number of other UI components as its children where the children components
     * are placed with a defined by the panel layout manager:

          // add few children component to panel top, center and bottom parts
          // with help of border layout manager
          var p = new zebkit.ui.Panel();
          p.setLayout(new zebkit.layout.BorderLayout(4)); // set layout manager to
                                                         // order children components

          p.add(&quot;top&quot;, new zebkit.ui.Label(&quot;Top label&quot;));
          p.add(&quot;center&quot;, new zebkit.ui.TextArea(&quot;Text area&quot;));
          p.add(&quot;bottom&quot;, new zebkit.ui.Button(&quot;Button&quot;));

     * **Input and component events**
     * The class provides possibility to catch various component and input events by declaring an
     * appropriate event method handler. The most simple case you just define a method:

          var p = new zebkit.ui.Panel();
          p.pointerPressed = function(e) {
              // handle event here
          };

    * If you prefer to create an anonymous class instance you can do it as follow:

          var p = new zebkit.ui.Panel([
              function pointerPressed(e) {
                  // handle event here
              }
          ]);

    * One more way to add the event handler is dynamic extending of an instance class demonstrated
    * below:

          var p = new zebkit.ui.Panel(&quot;Test&quot;);
          p.extend([
              function pointerPressed(e) {
                  // handle event here
              }
          ]);

     * Pay attention Zebkit UI components often declare own event handlers and in this case you can
     * overwrite the default event handler with a new one. Preventing the basic event handler execution
     * can cause the component will work improperly. You should care about the base event handler
     * execution as follow:

          // button component declares own pointer pressed event handler
          // we have to call the original handler to keep the button component
          // properly working
          var p = new zebkit.ui.Button(&quot;Test&quot;);
          p.extend([
              function pointerPressed(e) {
                  this.$super(e); // call parent class event handler implementation
                  // handle event here
              }
          ]);

     *  @class zebkit.ui.Panel
     *  @param {Object|zebkit.layout.Layout} [l] pass a layout manager or number of properties that have
     *  to be applied to the instance of the panel class.
     *  @constructor
     *  @extends zebkit.layout.Layoutable
     */

    /**
     * Implement the event handler method to catch pointer pressed event. The event is triggered every time
     * a pointer button has been pressed or a finger has touched a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerPressed = function(e) { ... }; // add event handler

     * @event pointerPressed
     * @param {zebkit.ui.event.PointerEvent} e a pointer event
    */

    /**
     * Implement the event handler method to catch pointer released event. The event is triggered every time
     * a pointer button has been released or a finger has untouched a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerReleased = function(e) { ... }; // add event handler

     * @event pointerReleased
     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     */

    /**
     * Implement the event handler method  to catch pointer moved event. The event is triggered every time
     * a pointer cursor has been moved with no a pointer button pressed.

         var p = new zebkit.ui.Panel();
         p.pointerMoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerMoved
     */

    /**
     * Implement the event handler method to catch pointer entered event. The event is triggered every
     * time a pointer cursor entered the given component.

         var p = new zebkit.ui.Panel();
         p.pointerEntered = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerEntered
     */

    /**
     * Implement the event handler method to catch pointer exited event. The event is triggered every
     * time a pointer cursor exited the given component.

         var p = new zebkit.ui.Panel();
         p.pointerExited = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerExited
     */

    /**
     * Implement the event handler method to catch pointer clicked event. The event is triggered every
     * time a pointer button has been clicked. Click events are generated only if no one pointer moved
     * or drag events has been generated in between pointer pressed -&gt; pointer released events sequence.

         var p = new zebkit.ui.Panel();
         p.pointerClicked = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerClicked
     */

    /**
     * Implement the event handler method to catch pointer dragged event. The event is triggered every
     * time a pointer cursor has been moved when a pointer button has been pressed. Or when a finger
     * has been moved over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragged = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerDragged
     */

    /**
     * Implement the event handler method to catch pointer drag started event. The event is triggered
     * every time a pointer cursor has been moved first time when a pointer button has been pressed.
     * Or when a finger has been moved first time over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragStarted = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerDragStarted
    */

    /**
     * Implement the event handler method to catch pointer drag ended event. The event is triggered
     * every time a pointer cursor has been moved last time when a pointer button has been pressed.
     * Or when a finger has been moved last time over a touch screen.

         var p = new zebkit.ui.Panel();
         p.pointerDragEnded = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.PointerEvent} e a pointer event
     * @event  pointerDragEnded
    */

    /**
     * Implement the event handler method to catch key pressed event The event is triggered every
     * time a key has been pressed.

         var p = new zebkit.ui.Panel();
         p.keyPressed = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.KeyEvent} e a key event
     * @event  keyPressed
     */

    /**
     * Implement the event handler method to catch key types event The event is triggered every
     *     time a key has been typed.

         var p = new zebkit.ui.Panel();
         p.keyTyped = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.KeyEvent} e a key event
     * @event  keyTyped
     */

    /**
     * Implement the event handler method to catch key released event
     * The event is triggered every time a key has been released.

         var p = new zebkit.ui.Panel();
         p.keyReleased = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.KeyEvent} e a key event
     * @event  keyReleased
     */

    /**
     * Implement the event handler method to catch the component sized event
     * The event is triggered every time the component has been re-sized.

         var p = new zebkit.ui.Panel();
         p.compSized = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.CompEvent} e a component event. Source of the event
     * is a component that has been sized, &quot;prevWidth&quot; and &quot;prevHeight&quot; fields
     * keep a previous size the component had.
     * @event compSized
     */

    /**
     * Implement the event handler method to catch component moved event
     * The event is triggered every time the component location has been
     * updated.

         var p = new zebkit.ui.Panel();
         p.compMoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.Panel} c a component that has been moved
     * @param {Integer} px a previous x coordinate the moved component had
     * @param {Integer} py a previous y coordinate the moved component had
     * @param {zebkit.ui.event.CompEvent} e a component event. Source of the event
     * is a component that has been moved. &quot;prevX&quot; and &quot;prevY&quot; fields hold
     * a previous location the component had.
     * @event compMoved
     */

    /**
     * Implement the event handler method to catch component enabled event
     * The event is triggered every time a component enabled state has been
     * updated.

         var p = new zebkit.ui.Panel();
         p.compEnabled = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.CompEvent} e a component event.
     * @event compEnabled
     */

    /**
     * Implement the event handler method to catch component shown event
     * The event is triggered every time a component visibility state has
     * been updated.

         var p = new zebkit.ui.Panel();
         p.compShown = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.CompEvent} e a component event.
     * @event compShown
     */

    /**
     * Implement the event handler method to catch component added event
     * The event is triggered every time the component has been inserted into
     * another one.

         var p = new zebkit.ui.Panel();
         p.compAdded = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.CompEvent} e a component event. The source of the passed event
     * is set to a container component, &quot;kid&quot; field is set to a component that has been
     * added to the container, &quot;constraints&quot; holds a constraints the child component has been
     * added.
     * @event compAdded
     */

    /**
     * Implement the event handler method to catch component removed event
     * The event is triggered every time the component has been removed from
     * its parent UI component.

         var p = new zebkit.ui.Panel();
         p.compRemoved = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.CompEvent} e a component event. The source of the passed event
     * is set to the container component. &quot;kid&quot; field is set to a child component that has
     * been removed from the container and &quot;index&quot; field is set to the index the kid component
     * was added before it had been removed from the container.
     * @event compRemoved
     */

    /**
     * Implement the event handler method to catch component focus gained event
     * The event is triggered every time a component has gained focus.

         var p = new zebkit.ui.Panel();
         p.focusGained = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.FocusEvent} e an input event
     * @event  focusGained
     */

    /**
     * Implement the event handler method to catch component focus lost event
     * The event is triggered every time a component has lost focus

         var p = new zebkit.ui.Panel();
         p.focusLost = function(e) { ... }; // add event handler

     * @param {zebkit.ui.event.FocusEvent} e an input event
     * @event  focusLost
     */

    /**
     * It is also possible to listen all the listed above event for children component. To handle
     * the event register listener method following the pattern below:
     *
         var p = new zebkit.ui.Panel();
         p.child&lt;EventName&gt; = function(e) { ... }; // add event handler

     * @param {Integer} id a component event ID. The id can have one of the following value:


     * @param {zebkit.ui.Panel} src a component that triggers the event
     * @param {zebkit.ui.event.KeyEvent | zebkit.ui.event.PointerEvent | zebkit.ui.event.CompEvent| zebkit.ui.event.FocusEvent} e
     * an UI event fired by a child component.
     * @event  child&lt;EventName&gt;
     */

     /**
      * The method is called for focusable UI components (components that can hold input focus) to ask
      * a string to be saved in native clipboard
      *
      * @return {String} a string to be copied in native clipboard
      *
      * @event clipCopy
      */

     /**
      * The method is called to pass string from clipboard to a focusable (a component that can hold
      * input focus) UI component
      *
      * @param {String} s a string from native clipboard
      *
      * @event clipPaste
      */
    pkg.Panel = Class(zebkit.layout.Layoutable, [
        function $prototype() {
            this.bg = this.border = null;

            /**
             * Request the whole UI component or part of the UI component to be repainted
             * @param  {Integer} [x] x coordinate of the component area to be repainted
             * @param  {Integer} [y] y coordinate of the component area to be repainted
             * @param  {Integer} [w] width of the component area to be repainted
             * @param  {Integer} [h] height of the component area to be repainted
             * @method repaint
             */
            this.repaint = function(x, y, w ,h) {
                // step I: skip invisible components and components that are not in hierarchy
                //         don&#x27;t initiate repainting thread for such sort of the components,
                //         but don&#x27;t forget for zCanvas whose parent field is null, but it has $context
                if (this.isVisible === true &amp;&amp; (this.parent !== null || typeof this.$context !== &#x27;undefined&#x27;)) {
                    //!!! find context buffer that holds the given component

                    var canvas = this;
                    for(; typeof canvas.$context === &#x27;undefined&#x27;; canvas = canvas.parent) {
                        // component either is not in visible state or is not in hierarchy
                        // than stop repaint procedure
                        if (canvas.isVisible === false || canvas.parent === null) {
                            return;
                        }
                    }

                    // no arguments means the whole component has top be repainted
                    if (arguments.length === 0) {
                        x = y = 0;
                        w = this.width;
                        h = this.height;
                    }

                    // step II: calculate new actual dirty area
                    if (w &gt; 0 &amp;&amp; h &gt; 0) {
                        var r = pkg.$cvp(this, temporary);
                        if (r !== null) {
                            zebkit.util.intersection(r.x, r.y, r.width, r.height, x, y, w, h, r);

                            if (r.width &gt; 0 &amp;&amp; r.height &gt; 0) {
                                x = r.x;
                                y = r.y;
                                w = r.width;
                                h = r.height;

                                // calculate repainted component absolute location
                                var cc = this;
                                while (cc !== canvas) {
                                    x += cc.x;
                                    y += cc.y;
                                    cc = cc.parent;
                                }

                                // normalize repaint area coordinates
                                if (x &lt; 0) {
                                    w += x;
                                    x = 0;
                                }

                                if (y &lt; 0) {
                                    h += y;
                                    y = 0;
                                }

                                if (w + x &gt; canvas.width ) {
                                    w = canvas.width - x;
                                }

                                if (h + y &gt; canvas.height) {
                                    h = canvas.height - y;
                                }

                                // still have what to repaint than calculate new
                                // dirty area of target canvas element
                                if (w &gt; 0 &amp;&amp; h &gt; 0) {
                                    var da = canvas.$da;

                                    // if the target canvas already has a dirty area set than
                                    // unite it with requested
                                    if (da.width &gt; 0) {
                                        // check if the requested repainted area is not in
                                        // exiting dirty area
                                        if (x &lt; da.x                ||
                                            y &lt; da.y                ||
                                            x + w &gt; da.x + da.width ||
                                            y + h &gt; da.y + da.height  )
                                        {
                                            // !!!
                                            // speed up to comment method call
                                            //MB.unite(da.x, da.y, da.width, da.height, x, y, w, h, da);
                                            var dax = da.x, day = da.y;
                                            if (da.x &gt; x) {
                                                da.x = x;
                                            }
                                            if (da.y &gt; y) {
                                                da.y = y;
                                            }
                                            da.width  = Math.max(dax + da.width,  x + w) - da.x;
                                            da.height = Math.max(day + da.height, y + h) - da.y;
                                        }
                                    } else {
                                        // if the target canvas doesn&#x27;t have a dirty area set than
                                        // cut (if necessary) the requested repainting area by the
                                        // canvas size

                                        // !!!
                                        // not necessary to call the method since we have already normalized
                                        // repaint coordinates and sizes
                                        //!!! MB.intersection(0, 0, canvas.width, canvas.height, x, y, w, h, da);

                                        da.x      = x;
                                        da.width  = w;
                                        da.y      = y;
                                        da.height = h;
                                    }
                                }
                            }
                        }
                    }

                    if (canvas.$waitingForPaint !== true &amp;&amp; (canvas.isValid === false ||
                                                             canvas.$da.width &gt; 0     ||
                                                             canvas.isLayoutValid === false))
                    {
                        $paintTasks[$paintTasks.length] = canvas;
                        canvas.$waitingForPaint = true;
                        if ($paintTask === null) {
                            $paintTask = zebkit.environment.animate(pkg.$doPaint);
                        }
                    }
                }
            };

            // destination is component itself or one of his composite parent.
            // composite component is a component that grab control from his
            // children component. to make a component composite
            // it has to implement catchInput field or method. If composite component
            // has catchInput method it will be called
            // to detect if the composite component takes control for the given kid.
            // composite components can be embedded (parent composite can take
            // control on its child composite component)
            this.getEventDestination = function() {
                var c = this, p = this;
                while ((p = p.parent) !== null) {
                    if (typeof p.catchInput !== &#x27;undefined&#x27; &amp;&amp;
                        (p.catchInput === true || (p.catchInput    !== false &amp;&amp;
                                                   p.catchInput(c) === true     )))
                    {
                        c = p;
                    }
                }
                return c;
            };

            /**
             * Paint the component and all its child components using the
             * given 2D HTML Canvas context
             * @param  {CanvasRenderingContext2D} g a canvas 2D context
             * @method paintComponent
             */
            this.paintComponent = function(g) {
                var ts = g.$states[g.$curState];
                if (ts.width  &gt; 0  &amp;&amp;
                    ts.height &gt; 0  &amp;&amp;
                    this.isVisible === true)
                {
                    // !!!
                    // calling setSize in the case of raster layout doesn&#x27;t
                    // cause hierarchy layout invalidation
                    if (this.isLayoutValid === false) {
                        this.validate();
                    }

                    var b = this.bg !== null &amp;&amp; (this.parent === null || this.bg !== this.parent.bg);

                    // if component defines shape and has update, [paint?] or background that
                    // differs from parent background try to apply the shape and than build
                    // clip from the applied shape
                    if ( (this.border !== null &amp;&amp; typeof this.border.outline !== &#x27;undefined&#x27;) &amp;&amp;
                         (b === true || typeof this.update !== &#x27;undefined&#x27;)                   &amp;&amp;
                         this.border.outline(g, 0, 0, this.width, this.height, this) === true)
                    {
                        g.save();
                        g.clip();

                        if (b) {
                            this.bg.paint(g, 0, 0, this.width, this.height, this);
                        }

                        if (typeof this.update !== &#x27;undefined&#x27;) {
                            this.update(g);
                        }

                        g.restore();
                    } else {
                        if (b === true) {
                            this.bg.paint(g, 0, 0, this.width, this.height, this);
                        }

                        if (typeof this.update !== &#x27;undefined&#x27;) {
                            this.update(g);
                        }
                    }

                    if (this.border !== null) {
                        this.border.paint(g, 0, 0, this.width, this.height, this);
                    }

                    if (typeof this.paint !== &#x27;undefined&#x27;) {
                        var left   = this.getLeft(),
                            top    = this.getTop(),
                            bottom = this.getBottom(),
                            right  = this.getRight();

                        if (left &gt; 0 || right &gt; 0 || top &gt; 0 || bottom &gt; 0) {
                            if (ts.width &gt; 0 &amp;&amp; ts.height &gt; 0) {
                                var x1   = (ts.x &gt; left ? ts.x : left),
                                    y1   = (ts.y &gt; top  ? ts.y : top),
                                    cxcw = ts.x + ts.width,
                                    cych = ts.y + ts.height,
                                    cright = this.width - right,
                                    cbottom = this.height - bottom;

                                g.save();
                                g.clipRect(x1, y1, (cxcw &lt; cright  ? cxcw : cright)  - x1,
                                                   (cych &lt; cbottom ? cych : cbottom) - y1);

                                this.paint(g);
                                g.restore();
                            }
                        } else {
                            this.paint(g);
                        }
                    }

                    var count = this.kids.length;
                    for(var i = 0; i &lt; count; i++) {
                        var kid = this.kids[i];
                        if (kid.isVisible === true &amp;&amp; typeof kid.$context === &#x27;undefined&#x27;) {
                            // calculate if the given component area has intersection
                            // with current clipping area
                            var kidXW = kid.x + kid.width,
                                c_xw  = ts.x + ts.width,
                                kidYH = kid.y + kid.height,
                                c_yh  = ts.y + ts.height,
                                iw = (kidXW &lt; c_xw ? kidXW : c_xw) - (kid.x &gt; ts.x ? kid.x : ts.x),
                                ih = (kidYH &lt; c_yh ? kidYH : c_yh) - (kid.y &gt; ts.y ? kid.y : ts.y);

                            if (iw &gt; 0 &amp;&amp; ih &gt; 0) {
                                g.save();
                                g.translate(kid.x, kid.y);
                                g.clipRect(0, 0, kid.width, kid.height);
                                kid.paintComponent(g);
                                g.restore();
                            }
                        }
                    }

                    if (typeof this.paintOnTop !== &#x27;undefined&#x27;) {
                        this.paintOnTop(g);
                    }
                }
            };

            /**
             * UI component border view
             * @attribute border
             * @default null
             * @readOnly
             * @type {zebkit.draw.View}
             */

            /**
             * UI component background view
             * @attribute bg
             * @default null
             * @readOnly
             * @type {zebkit.draw.View}
            */

            /**
             * Define and set the property to true if the component has to catch focus
             * @attribute canHaveFocus
             * @type {Boolean}
             * @default undefined
             */

            this.top = this.left = this.right = this.bottom = 0;

            /**
             * UI component enabled state
             * @attribute isEnabled
             * @default true
             * @readOnly
             * @type {Boolean}
             */
            this.isEnabled = true;

            /**
             * Find a zebkit.ui.zCanvas where the given UI component is hosted
             * @return {zebkit.ui.zCanvas} a zebkit canvas
             * @method getCanvas
             */
            this.getCanvas = function() {
                var c = this;
                for(; c !== null &amp;&amp; c.$isRootCanvas !== true; c = c.parent) {}
                return c;
            };

            this.notifyRender = function(o, n){
                if (o !== null &amp;&amp; typeof o.ownerChanged !== &#x27;undefined&#x27;) {
                    o.ownerChanged(null);
                }
                if (n !== null &amp;&amp; typeof n.ownerChanged !== &#x27;undefined&#x27;) {
                    n.ownerChanged(this);
                }
            };

            /**
             * Shortcut method to register the specific to the concrete component
             * events listener. For instance &quot;zebkit.ui.Button&quot; component fires event
             * when it is pressed:

            var b = new zebkit.ui.Button(&quot;Test&quot;);
            b.on(function() {
                // button has been pressed
            });


             * @param {Function|Object} a listener function or an object that
             * declares events handler methods
             * @return {Function|Object} a registered listener
             * @method bind
             */

            /**
             * Shortcut method to remove the register component specific events listener
             * @param {Function|Object} a listener function to be removed
             * @method unbind
             */


            /**
             * Load content of the panel UI components from the specified JSON file.
             * @param  {String|Object} JSON URL, JSON string or JS object tthat describes UI
             * to be loaded into the panel
             * @return {zebkit.DoIt} a runner to track JSON loading
             * @method load
             */
            this.load = function(jsonPath) {
                return new zebkit.util.Zson(this).then(jsonPath);
            };

            /**
             * Get a children UI component that embeds the given point. The method
             * calculates the component visible area first and than looks for a
             * children component only in this calculated visible area. If no one
             * children component has been found than component return itself as
             * a holder of the given point if one of the following condition is true:
             *
             *   - The component doesn&#x27;t implement custom &quot;contains(x, y)&quot; method
             *   - The component implements &quot;contains(x, y)&quot; method and for the given point the method return true
             *
             * @param  {Integer} x x coordinate
             * @param  {Integer} y y coordinate
             * @return {zebkit.ui.Panel} a children UI component
             * @method getComponentAt
             */
            this.getComponentAt = function(x, y){
                var r = pkg.$cvp(this, temporary);

                if (r === null ||
                    (x &lt; r.x || y &lt; r.y || x &gt;= r.x + r.width || y &gt;= r.y + r.height))
                {
                    return null;
                }

                if (this.kids.length &gt; 0){
                    for(var i = this.kids.length; --i &gt;= 0; ){
                        var kid = this.kids[i];
                        kid = kid.getComponentAt(x - kid.x,
                                                 y - kid.y);
                        if (kid !== null) {
                            return kid;
                        }
                    }
                }
                return typeof this.contains === &#x27;undefined&#x27; || this.contains(x, y) === true ? this : null;
            };

            /**
             * Shortcut method to invalidating the component and then initiating the component
             * repainting.
             * @method vrp
             */
            this.vrp = function(){
                this.invalidate();

                // extra condition to save few millisecond on repaint() call
                if (this.isVisible === true &amp;&amp; this.parent !== null) {
                    this.repaint();
                }
            };

            this.getTop = function() {
                return this.border !== null ? this.top + this.border.getTop()
                                            : this.top;
            };

            this.getLeft = function() {
                return this.border !== null ? this.left + this.border.getLeft()
                                            : this.left;
            };

            this.getBottom = function() {
                return this.border !== null ? this.bottom + this.border.getBottom()
                                            : this.bottom;
            };

            this.getRight  = function() {
                return this.border !== null ? this.right  + this.border.getRight()
                                            : this.right;
            };

            //TODO: the method is not used yet
            this.isInvalidatedByChild = function(c) {
                return true;
            };

            /**
             * The method is implemented to be aware about a children component insertion.
             * @param  {Integer} index an index at that a new children component
             * has been added
             * @param  {Object} constr a layout constraints of an inserted component
             * @param  {zebkit.ui.Panel} l a children component that has been inserted
             * @method kidAdded
             */
            this.kidAdded = function(index, constr, l) {
                COMP_EVENT.source = this;
                COMP_EVENT.constraints = constr;
                COMP_EVENT.kid = l;

                pkg.events.fire(&quot;compAdded&quot;, COMP_EVENT);

                if (l.width &gt; 0 &amp;&amp; l.height &gt; 0) {
                    l.repaint();
                } else {
                    this.repaint(l.x, l.y, 1, 1);
                }
            };

            /**
             * Set the component layout constraints.
             * @param {Object} ctr a constraints whose value depends on layout manager that has been set
             * @method setConstraints
             * @chainable
             */
            this.setConstraints = function(ctr) {
                if (this.constraints !== ctr) {
                    this.constraints = ctr;
                    if (this.parent !== null) {
                        this.vrp();
                    }
                }
                return this;
            };

            /**
             * The method is implemented to be aware about a children component removal.
             * @param  {Integer} i an index of a removed component
             * @param  {zebkit.ui.Panel} l a removed children component
             * @method kidRemoved
             */
            this.kidRemoved = function(i,l){
                COMP_EVENT.source = this;
                COMP_EVENT.index  = i;
                COMP_EVENT.kid    = l;
                pkg.events.fire(&quot;compRemoved&quot;, COMP_EVENT);
                if (l.isVisible === true) {
                    this.repaint(l.x, l.y, l.width, l.height);
                }
            };

            /**
             * The method is implemented to be aware the component location updating
             * @param  {Integer} px a previous x coordinate of the component
             * @param  {Integer} py a previous y coordinate of the component
             * @method relocated
             */
            this.relocated = function(px, py) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevX  = px;
                COMP_EVENT.prevY  = py;
                pkg.events.fire(&quot;compMoved&quot;, COMP_EVENT);

                var p = this.parent,
                    w = this.width,
                    h = this.height;

                if (p !== null &amp;&amp; w &gt; 0 &amp;&amp; h &gt; 0) {
                    var x = this.x,
                        y = this.y,
                        nx = x &lt; px ? x : px,
                        ny = y &lt; py ? y : py;

                    //TODO: some mobile browser has bug: moving a component
                    //      leaves 0.5 sized traces to fix it 1 pixel extra
                    //      has to be added to all sides of repainted rect area
                    // nx--;
                    // ny--;

                    if (nx &lt; 0) {
                        nx = 0;
                    }
                    if (ny &lt; 0) {
                        ny = 0;
                    }

                    var w1 = p.width - nx,
                        w2 = w + (x &gt; px ? x - px : px - x),
                        h1 = p.height - ny,
                        h2 = h + (y &gt; py ? y - py : py - y);

                    // TODO: add crappy 2 for mobile (android)
                    p.repaint(nx, ny, (w1 &lt; w2 ? w1 : w2),// + 2,
                                      (h1 &lt; h2 ? h1 : h2));// + 2);
                }
            };

            /**
             * The method is implemented to be aware the component size updating
             * @param  {Integer} pw a previous width of the component
             * @param  {Integer} ph a previous height of the component
             * @method resized
             */
            this.resized = function(pw,ph) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevWidth  = pw;
                COMP_EVENT.prevHeight = ph;
                pkg.events.fire(&quot;compSized&quot;, COMP_EVENT);

                if (this.parent !== null) {
                    this.parent.repaint(this.x, this.y,
                                        ((this.width  &gt; pw) ? this.width  : pw),
                                        ((this.height &gt; ph) ? this.height : ph));
                }
            };

            /**
             * Checks if the component has a focus
             * @return {Boolean} true if the component has focus
             * @method hasFocus
             */
            this.hasFocus = function(){
                return pkg.focusManager.hasFocus(this);
            };

            /**
             * Force the given component to catch focus if the component is focusable.
             * @method requestFocus
             */
            this.requestFocus = function(){
                pkg.focusManager.requestFocus(this);
            };

            /**
             * Force the given component to catch focus in the given timeout.
             * @param {Integer} [timeout] a timeout in milliseconds. The default value is 50
             * milliseconds
             * @method requestFocusIn
             */
            this.requestFocusIn = function(timeout) {
                if (arguments.length === 0) {
                    timeout = 50;
                }

                var $this = this;
                zebkit.util.tasksSet.runOnce(function () {
                    $this.requestFocus();
                }, timeout);
            };

            /**
             * Set the UI component visibility
             * @param  {Boolean} b a visibility state
             * @method setVisible
             * @chainable
             */
            this.setVisible = function (b) {
                if (this.isVisible !== b) {
                    this.isVisible = b;
                    this.invalidate();

                    COMP_EVENT.source = this;
                    pkg.events.fire(&quot;compShown&quot;, COMP_EVENT);

                    if (this.parent !== null) {
                        if (b) {
                            this.repaint();
                        } else {
                            this.parent.repaint(this.x, this.y, this.width, this.height);
                        }
                    }
                }
                return this;
            };

            /**
             *  Set the UI component enabled state. Using this property
             *  an UI component can be excluded from getting input events
             *  @param  {Boolean} b a enabled state
             *  @method setEnabled
             *  @chainable
             */
            this.setEnabled = function (b){
                if (this.isEnabled !== b){
                    this.isEnabled = b;

                    COMP_EVENT.source = this;
                    pkg.events.fire(&quot;compEnabled&quot;, COMP_EVENT);
                    if (this.kids.length &gt; 0) {
                        for(var i = 0;i &lt; this.kids.length; i++) {
                            this.kids[i].setEnabled(b);
                        }
                    }
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the UI component top, right, left, bottom paddings to the same given value
             * @param  {Integer} v the value that will be set as top, right, left, bottom UI
             * component paddings
             * @method setPadding
             * @chainable
             */

            /**
             * Set UI component top, left, bottom, right paddings. The paddings are
             * gaps between component border and painted area.
             * @param  {Integer} top a top padding
             * @param  {Integer} left a left padding
             * @param  {Integer} bottom a bottom padding
             * @param  {Integer} right a right padding
             * @method setPadding
             * @chainable
             */
            this.setPadding = function (top,left,bottom,right){
                if (arguments.length === 1) {
                    left = bottom = right = top;
                }

                if (this.top    !== top    || this.left  !== left  ||
                    this.bottom !== bottom || this.right !== right   )
                {
                    this.top = top;
                    this.left = left;
                    this.bottom = bottom;
                    this.right = right;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set top padding
             * @param {Integer} top a top padding
             * @method  setTopPadding
             * @chainable
             */
            this.setTopPadding = function(top) {
                if (this.top !== top) {
                    this.top = top;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set left padding
             * @param {Integer} left a left padding
             * @method  setLeftPadding
             * @chainable
             */
            this.setLeftPadding = function(left) {
                if (this.left !== left) {
                    this.left = left;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set bottom padding
             * @param {Integer} bottom a bottom padding
             * @method  setBottomPadding
             * @chainable
             */
            this.setBottomPadding = function(bottom) {
                if (this.bottom !== bottom) {
                    this.bottom = bottom;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set right padding
             * @param {Integer} right a right padding
             * @method  setRightPadding
             * @chainable
             */
            this.setRightPadding = function(right) {
                if (this.right !== right) {
                    this.right = right;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the border view
             * @param  {zebkit.draw.View|Function|String} v a border view or border &quot;paint(g,x,y,w,h,c)&quot;
             * rendering function or one of predefined border name: &quot;plain&quot;, &quot;sunken&quot;, &quot;raised&quot;, &quot;etched&quot;
             * @method setBorder
             * @example
             *
             *      var pan = new zebkit.ui.Panel();
             *
             *      // set round border
             *      pan.setBorder(zebkit.draw.RoundBorder(&quot;red&quot;));
             *
             *      ...
             *      // set one of predefined border
             *      pan.setBorder(&quot;plain&quot;);
             *
             * @chainable
             */
            this.setBorder = function (v) {
                var old = this.border;
                v = zebkit.draw.$view(v);
                if (v != old){
                    this.border = v;
                    this.notifyRender(old, v);

                    if ( old === null || v === null       ||
                         old.getTop()    !== v.getTop()    ||
                         old.getLeft()   !== v.getLeft()   ||
                         old.getBottom() !== v.getBottom() ||
                         old.getRight()  !== v.getRight()     )
                    {
                        this.invalidate();
                    }

                    if (v !== null &amp;&amp; typeof v.activate !== &#x27;undefined&#x27;) {
                        v.activate(this.hasFocus() ?  &quot;focuson&quot;: &quot;focusoff&quot;, this);
                    }

                    this.repaint();
                }
                return this;
            };

            /**
             * Set the background. Background can be a color string or a zebkit.draw.View class
             * instance, or a function(g,x,y,w,h,c) that paints the background:
             *
             *     // set background color
             *     comp.setBackground(&quot;red&quot;);
             *
             *     // set a picture as a component background
             *     comp.setBackground(new zebkit.draw.Picture(...));
             *
             *     // set a custom rendered background
             *     comp.setBackground(function(g,x,y,w,h,target) {
             *         // paint a component background here
             *         g.setColor(&quot;blue&quot;);
             *         g.fillRect(x,y,w,h);
             *         g.drawLine(...);
             *         ...
             *     });
             *
             *
             * @param  {String|zebkit.draw.View|Function} v a background view, color or
             * background &quot;paint(g,x,y,w,h,c)&quot; rendering function.
             * @method setBackground
             * @chainable
             */
            this.setBackground = function (v){
                var old = this.bg;
                v = zebkit.draw.$view(v);
                if (v !== old) {
                    this.bg = v;
                    this.notifyRender(old, v);
                    this.repaint();
                }
                return this;
            };

            /**
             * Add the given children component or number of components to the given panel.
             * @protected
             * @param {zebkit.ui.Panel|Array|Object} a children component of number of
             * components to be added. The parameter can be:
             *
             *   - Component
             *   - Array of components
             *   - Dictionary object where every element is a component to be added and the key of
             *     the component is stored in the dictionary is considered as the component constraints
             *
             * @method setKids
             * @chainable
             */
            this.setKids = function(a) {
                if (arguments.length === 1 &amp;&amp; zebkit.instanceOf(a, pkg.Panel)) {
                   this.add(a);
                } else {
                    var i = 0;

                    // if components list passed as number of arguments
                    if (arguments.length &gt; 1) {
                        for(i = 0; i &lt; arguments.length; i++) {
                            var kid = arguments[i];
                            if (kid !== null) {
                                this.add(typeof kid.$new !== &#x27;undefined&#x27; ? kid.$new() : kid);
                            }
                        }
                    } else {
                        if (Array.isArray(a)) {
                            for(i = 0; i &lt; a.length; i++) {
                                if (a[i] !== null) {
                                    this.add(a[i]);
                                }
                            }
                        } else {
                            var kids = a;
                            for(var k in kids) {
                                if (kids.hasOwnProperty(k)) {
                                    this.add(k, kids[k]);
                                }
                            }
                        }
                    }
                }
                return this;
            };

            /**
             * The method is called whenever the UI component gets or looses focus
             * @method focused
             * @protected
             */
            this.focused = function() {
                // extents of activate method indicates it is
                if (this.border !== null &amp;&amp; typeof this.border.activate !== &#x27;undefined&#x27;) {
                    var id = this.hasFocus() ? &quot;focuson&quot; : &quot;focusoff&quot; ;
                    if (typeof this.border.views[id] !== &#x27;undefined&#x27;) {
                        this.border.activate(id, this);
                        this.repaint();
                    }
                }

                // TODO: think if the background has to be focus dependent
                // if (this.bg !== null &amp;&amp; typeof this.bg.activate !== &#x27;undefined&#x27;) {
                //     var id = this.hasFocus() ? &quot;focuson&quot; : &quot;focusoff&quot; ;
                //     if (this.bg.views[id]) {
                //         this.bg.activate(id);
                //         this.repaint();
                //     }
                // }
            };

            /**
             * Remove all children components
             * @method removeAll
             * @chainable
             */
            this.removeAll = function (){
                if (this.kids.length &gt; 0){
                    var size = this.kids.length, mx1 = Number.MAX_VALUE, my1 = mx1, mx2 = 0, my2 = 0;
                    for(; size &gt; 0; size--){
                        var child = this.kids[size - 1];
                        if (child.isVisible === true){
                            var xx = child.x, yy = child.y;
                            mx1 = mx1 &lt; xx ? mx1 : xx;
                            my1 = my1 &lt; yy ? my1 : yy;
                            mx2 = Math.max(mx2, xx + child.width);
                            my2 = Math.max(my2, yy + child.height);
                        }
                        this.removeAt(size - 1);
                    }
                    this.repaint(mx1, my1, mx2 - mx1, my2 - my1);
                }
                return this;
            };

            /**
             * Bring the UI component to front
             * @method toFront
             * @chainable
             */
            this.toFront = function(){
                if (this.parent !== null &amp;&amp; this.parent.kids[this.parent.kids.length-1] !== this){
                    var p = this.parent;
                    p.kids.splice(p.indexOf(this), 1);
                    p.kids[p.kids.length] = this;
                    p.vrp();
                }
                return this;
            };

            /**
             * Send the UI component to back
             * @method toBack
             * @chainable
             */
            this.toBack = function(){
                if (this.parent !== null &amp;&amp; this.parent.kids[0] !== this){
                    var p = this.parent;
                    p.kids.splice(p.indexOf(this), 1);
                    p.kids.unshift(this);
                    p.vrp();
                }
                return this;
            };

            /**
             * Set the UI component size to its preferred size
             * @return {Object} a preferred size applied to the component.
             * The structure of the returned object is the following:

                { width:{Integer}, height:{Integer} }

             * @method toPreferredSize
             */
            this.toPreferredSize = function (){
                var ps = this.getPreferredSize();
                this.setSize(ps.width, ps.height);
                return ps;
            };

            /**
             * Build zebkit.draw.View that represents the UI component
             * @return {zebkit.draw.View} a view of the component
             * @param {zebkit.ui.Panel} target a target component
             * @method toView
             */
            this.toView = function(target) {
                return new pkg.CompRender(this);
            };

            // TODO: not stable API
            this.paintViewAt = function(g, ax, ay, v) {
                var x  = this.getLeft(),
                    y  = this.getTop(),
                    ps = v.getPreferredSize();

                if (ax === &quot;center&quot;) {
                    x = Math.floor((this.width - ps.width)/2);
                } else if (ax === &quot;right&quot;) {
                    x = this.width - this.getRight() - ps.width;
                }

                if (ay === &quot;center&quot;) {
                    y = Math.floor((this.height - ps.height)/2);
                } else if (ay === &quot;bottom&quot;) {
                    y = this.height - this.getBottom() - ps.height;
                }

                v.paint(g, x, y, ps.width, ps.height, this);
            };

            this[&#x27;&#x27;] = function(l) {
                // !!! dirty trick to call super, for the sake of few milliseconds back
                //this.$super();
                if (typeof this.kids === &quot;undefined&quot;) {
                    this.kids = [];
                }

                if (this.layout === null) {
                    this.layout = this;
                }

                if (this.clazz.inheritProperties === true) {
                    // instead of recursion collect stack in array than go through it
                    var hierarchy = [],
                        pp        = this.clazz;

                    // collect clazz hierarchy
                    while(pp.$parent !== null &amp;&amp; pp.inheritProperties === true) {
                        pp = pp.$parent;
                        hierarchy[hierarchy.length] = pp;
                    }

                    // apply properties from the hierarchy
                    for(var i = hierarchy.length; i &gt;= 0; i--) {
                        this.properties(hierarchy[i]);
                    }
                }
                this.properties(this.clazz);

                if (arguments.length &gt; 0) {
                    if (l.constructor === Object) {  // TODO: not 100% method to detetect &quot;{}&quot; type
                        this.properties(l);
                    } else {
                        this.setLayout(l);
                    }
                }
            };
        }
    ]);

    /**
     * Root layer interface.
     * @class zebkit.ui.RootLayerMix
     * @constructor
     * @interface zebkit.ui.RootLayerMix
     */
    pkg.RootLayerMix = zebkit.Interface([
        function $clazz() {
            /**
             * Root layer id.
             * @attribute id
             * @type {String}
             * @readOnly
             * @default &quot;root&quot;
             */
            this.id = &quot;root&quot;;
        },

        function $prototype() {
            this.getFocusRoot = function() {
                return this;
            };
        }
    ]);

    /**
     * Root layer panel implementation basing on zebkit.ui.Panel component.
     * @class zebkit.ui.RootLayer
     * @extends zebkit.ui.Panel
     * @uses zebkit.ui.RootLayerMix
     */
    pkg.RootLayer = Class(pkg.Panel, pkg.RootLayerMix, []);


    /**
     * Class that holds mouse cursor constant.
     * @constructor
     * @class zebkit.ui.Cursor
     */
    pkg.Cursor = {
        /**
         * &quot;default&quot;
         * @const DEFAULT
         * @type {String}
         */
        DEFAULT: &quot;default&quot;,

        /**
         * &quot;move&quot;
         * @const MOVE
         * @type {String}
         */
        MOVE: &quot;move&quot;,

        /**
         * &quot;wait&quot;
         * @const WAIT
         * @type {String}
         */
        WAIT: &quot;wait&quot;,

        /**
         * &quot;text&quot;
         * @const TEXT
         * @type {String}
         */
        TEXT: &quot;text&quot;,

        /**
         * &quot;pointer&quot;
         * @const HAND
         * @type {String}
         */
        HAND: &quot;pointer&quot;,

        /**
         * &quot;ne-resize&quot;
         * @const NE_RESIZE
         * @type {String}
         */
        NE_RESIZE: &quot;ne-resize&quot;,

        /**
         * &quot;sw-resize&quot;
         * @const SW_RESIZE
         * @type {String}
         */
        SW_RESIZE: &quot;sw-resize&quot;,

        /**
         * &quot;se-resize&quot;
         * @const SE_RESIZE
         * @type {String}
         */
        SE_RESIZE: &quot;se-resize&quot;,

        /**
         * &quot;nw-resize&quot;
         * @const NW_RESIZE
         * @type {String}
         */
        NW_RESIZE: &quot;nw-resize&quot;,

        /**
         * &quot;s-resize&quot;
         * @const S_RESIZE
         * @type {String}
         */
        S_RESIZE: &quot;s-resize&quot;,

        /**
         * &quot;w-resize&quot;
         * @const W_RESIZE
         * @type {String}
         */
        W_RESIZE: &quot;w-resize&quot;,

        /**
         * &quot;n-resize&quot;
         * @const N_RESIZE
         * @type {String}
         */
        N_RESIZE: &quot;n-resize&quot;,

        /**
         * &quot;e-resize&quot;
         * @const E_RESIZE
         * @type {String}
         */
        E_RESIZE: &quot;e-resize&quot;,

        /**
         * &quot;col-resize&quot;
         * @const COL_RESIZE
         * @type {String}
         */
        COL_RESIZE: &quot;col-resize&quot;,

        /**
         * &quot;help&quot;
         * @const HELP
         * @type {String}
         */
        HELP: &quot;help&quot;
    };

    /**
     *  UI component render class. Renders the given target UI component
     *  on the given surface using the specified 2D context
     *  @param {zebkit.layout.Layoutable} [target] an UI component to be rendered
     *  @class zebkit.ui.CompRender
     *  @constructor
     *  @extends zebkit.draw.Render
     */
    pkg.CompRender = Class(zebkit.draw.Render, [
        function $prototype() {
            /**
             * Get preferred size of the render. The method doesn&#x27;t calculates
             * preferred size it simply calls the target component &quot;getPreferredSize&quot;
             * method.
             * @method getPreferredSize
             * @return {Object} a preferred size
             *
             *      {width:&lt;Integer&gt;, height: &lt;Integer&gt;}
             */
            this.getPreferredSize = function(){
                return this.target === null || this.target.isVisible === false ? { width:0, height:0 }
                                                                               : this.target.getPreferredSize();
            };

            this.paint = function(g,x,y,w,h,d){
                var c = this.target;
                if (c !== null &amp;&amp; c.isVisible) {
                    var prevW  = -1,
                        prevH  = 0,
                        parent = null;

                    if (w !== c.width || h !== c.height) {
                        if (c.getCanvas() !== null) {
                            parent = c.parent;
                            c.parent = null;
                        }

                        prevW = c.width;
                        prevH = c.height;
                        c.setSize(w, h);
                    }

                    // validate should be done here since setSize can be called
                    // above
                    c.validate();
                    g.translate(x, y);

                    try {
                        c.paintComponent(g);
                    } catch(e) {
                        if (parent !== null) {
                            c.parent = parent;
                        }
                        g.translate(-x, -y);
                        throw e;
                    }
                    g.translate(-x, -y);

                    if (prevW &gt;= 0){
                        c.setSize(prevW, prevH);
                        if (parent !== null) {
                            c.parent = parent;
                        }
                        c.validate();
                    }
                }
            };
        }
    ]);

    /**
     * Shortcut to create a UI component by the given description. Depending on the description type
     * the following components are created:
     *
     *    - **String** zebkit.ui.Label
     *    - **Array** zebkit.ui.Combobox
     *    - **2D Array** zebkit.ui.grid.Grid
     *
     * @method $component
     * @protected
     * @for  zebkit.ui
     * @param  {Object} desc a description
     * @return {zebkit.ui.Panel}  a created UI component
     */
    pkg.$component = function(desc, instance) {
        var hasInstance = arguments.length &gt; 1;

        if (zebkit.isString(desc)) {
            //  [x] Text
            //  @(image-path:wxh) Text
            //  Text

            var m   = desc.match(/^(\[[x ]?\])/),
                txt = null;

            if (m !== null) {
                txt = desc.substring(m[1].length);
                var ch  = hasInstance &amp;&amp; typeof instance.clazz.Checkbox !== &#x27;undefined&#x27; ? new instance.clazz.Checkbox(txt)
                                                                                        : new pkg.Checkbox(txt);
                ch.setValue(m[1].indexOf(&#x27;x&#x27;) &gt; 0);
                return ch;
            } else {
                m = desc.match(/^@\((.*)\)(\:[0-9]+x[0-9]+)?/);
                if (m !== null) {
                    var path = m[1];

                    txt  = desc.substring(path.length + 3 + (typeof m[2] !== &#x27;undefined&#x27; ? m[2].length : 0)).trim();

                    var img = hasInstance &amp;&amp; typeof instance.clazz.ImagePan !== &#x27;undefined&#x27; ? new instance.clazz.ImagePan(path)
                                                                                            : new pkg.ImagePan(path);

                    if (typeof m[2] !== &#x27;undefined&#x27;) {
                        var s = m[2].substring(1).split(&#x27;x&#x27;),
                            w = parseInt(s[0], 10),
                            h = parseInt(s[1], 10);

                        img.setPreferredSize(w, h);
                    }

                    if (txt.length === 0) {
                        return img;
                    }

                    return hasInstance &amp;&amp; typeof instance.clazz.ImageLabel !== &#x27;undefined&#x27; ? new instance.clazz.ImageLabel(txt, img)
                                                                                           : new pkg.ImageLabel(txt, img);
                } else {
                    return hasInstance &amp;&amp; typeof instance.clazz.Label !== &#x27;undefined&#x27; ? new instance.clazz.Label(desc)
                                                                                      : new pkg.Label(desc);
                }
            }
        } else if (Array.isArray(desc)) {
            if (desc.length &gt; 0 &amp;&amp; Array.isArray(desc[0])) {
                var model = new zebkit.data.Matrix(desc.length, desc[0].length);
                for(var row = 0; row &lt; model.rows; row++) {
                    for(var col = 0; col &lt; model.cols; col++) {
                        model.put(row, col, desc[row][col]);
                    }
                }
                return new pkg.grid.Grid(model);
            } else {
                var clz = hasInstance &amp;&amp; typeof instance.clazz.Combo !== &#x27;undefined&#x27; ? instance.clazz.Combo
                                                                                     : pkg.Combo,
                    combo = new clz(new clz.CompList(true)),
                    selectedIndex = -1;

                for(var i = 0; i &lt; desc.length; i++) {
                    var ss = desc[i];
                    if (zebkit.isString(ss)) {
                        if (selectedIndex === -1 &amp;&amp; ss.length &gt; 1 &amp;&amp; ss[0] === &#x27;*&#x27;) {
                            selectedIndex = i;
                            desc[i] = ss.substring(1);
                        }
                    }
                    combo.list.add(pkg.$component(desc[i], combo.list));
                }

                combo.select(selectedIndex);
                return combo;
            }
        } else if (desc instanceof Image) {
            return hasInstance &amp;&amp; typeof instance.clazz.ImagePan !== &#x27;undefined&#x27; ? new instance.clazz.ImagePan(desc)
                                                                                 : new pkg.ImagePan(desc);
        } else if (zebkit.instanceOf(desc, zebkit.draw.View)) {
            var v = hasInstance &amp;&amp; typeof instance.clazz.ViewPan !== &#x27;undefined&#x27; ? new instance.clazz.ViewPan()
                                                                                 : new pkg.ViewPan();
            v.setView(desc);
            return v;
        }

        return desc;
    };

    /**
     * Named views holder interface.
     * @class  zebkit.ui.DecorationViews
     * @interface  zebkit.ui.DecorationViews
     */
    pkg.DecorationViews = zebkit.Interface([
        function $prototype() {
            /**
             * Set views set.
             * @param {Object} v named views set.
             * @method setViews
             * @chainable
             */
            this.setViews = function(v){
                if (typeof this.views === &#x27;undefined&#x27;) {
                    this.views = {};
                }

                var b = false;
                for(var k in v) {
                    if (v.hasOwnProperty(k)) {
                        var nv = zebkit.draw.$view(v[k]);
                        if (this.views[k] !== nv) {
                            this.views[k] = nv;
                            b = true;
                        }
                    }
                }

                if (b === true) {
                    this.vrp();
                }

                return this;
            };
        }
    ]);

    /**
     *  UI component to keep and render the given &quot;zebkit.draw.View&quot; class
     *  instance. The target view defines the component preferred size
     *  and the component view.
     *  @class zebkit.ui.ViewPan
     *  @constructor
     *  @extends zebkit.ui.Panel
     */
    pkg.ViewPan = Class(pkg.Panel, [
        function $prototype() {
            /**
             * Reference to a view that the component visualize
             * @attribute view
             * @type {zebkit.draw.View}
             * @default null
             * @readOnly
             */
            this.view = null;

            this.paint = function (g){
                if (this.view !== null){
                    var l = this.getLeft(),
                        t = this.getTop();

                    this.view.paint(g, l, t, this.width  - l - this.getRight(),
                                             this.height - t - this.getBottom(), this);
                }
            };

            /**
             * Set the target view to be wrapped with the UI component
             * @param  {zebkit.draw.View|Function} v a view or a rendering
             * view &quot;paint(g,x,y,w,h,c)&quot; function
             * @method setView
             * @chainable
             */
            this.setView = function(v){
                var old = this.view;
                v = zebkit.draw.$view(v);

                if (v !== old) {
                    this.view = v;
                    this.notifyRender(old, v);
                    this.vrp();
                }

                return this;
            };

            /**
             * Override the parent method to calculate preferred size basing on a target view.
             * @param  {zebkit.ui.Panel} t a target container
             * @return {Object} return a target view preferred size if it is defined.
             * The returned structure is the following:
             *
             *     { width: {Integer}, height:{Integer} }
             *
             *  @method  calcPreferredSize
             */
            this.calcPreferredSize = function (t) {
                return this.view !== null ? this.view.getPreferredSize() : { width:0, height:0 };
            };
        }
    ]);

    /**
     *  Image panel UI component class. The component renders an image.
     *  @param {String|Image} [img] a path or direct reference to an image object.
     *  If the passed parameter is string it considered as path to an image.
     *  In this case the image will be loaded using the passed path.
     *  @param {Integer} [w] a preferred with of the image
     *  @param {Integer} [h] a preferred height of the image
     *  @class zebkit.ui.ImagePan
     *  @constructor
     *  @extends zebkit.ui.ViewPan
     */
    pkg.ImagePan = Class(pkg.ViewPan, [
        function(img, w, h) {
            this.setImage(arguments.length &gt; 0 ? img : null);
            this.$super();
            if (arguments.length &gt; 1) {
                this.setPreferredSize(w, arguments &lt; 3 ? w : h);
            }
        },

        function $prototype() {
            this.$runner = null;

            /**
             * Set image to be rendered in the UI component
             * @method setImage
             * @param {String|Image|zebkit.draw.Picture} img a path or direct reference to an
             * image or zebkit.draw.Picture render.
             * If the passed parameter is string it considered as path to an image.
             * In this case the image will be loaded using the passed path
             * @chainable
             */
            this.setImage = function(img) {
                var $this = this;

                if (img !== null) {
                    var isPic     = zebkit.instanceOf(img, zebkit.draw.Picture),
                        imgToLoad = isPic ? img.target : img ;

                    this.setView(isPic ? img : new zebkit.draw.Picture(img));


                    this.$runner = zebkit.util.image(imgToLoad);
                    this.$runner.then(function(img) {
                        $this.$runner = null;
                        $this.setView(isPic ? img : new zebkit.draw.Picture(img));
                        $this.vrp();

                        if (typeof $this.imageLoaded !== &#x27;undefined&#x27;) {
                            $this.imageLoaded(img);
                        }

                        // fire imageLoaded event to children
                        for(var t = $this.parent; t !== null; t = t.parent){
                            if (typeof t.childImageLoaded !== &#x27;undefined&#x27;) {
                                t.childImageLoaded(img);
                            }
                        }
                    }).catch(function(e) {
                        console.log(img);
                        zebkit.dumpError(e);

                        $this.$runner = null;
                        $this.setView(null);
                    });
                } else {
                    if (this.$runner === null) {
                        this.setView(null);
                    } else {
                        this.$runner.then(function() {
                            $this.setView(null);
                        });
                    }
                }
                return this;
            };
        }
    ]);

    /**
     * Line UI component class. Draw series of vertical or horizontal lines of using
     * the given line width and color. Vertical or horizontal line rendering s selected
     * depending on the line component size: if height is greater than width than vertical
     * line will be rendered.
     * @constructor
     * @class zebkit.ui.Line
     * @extends zebkit.ui.Panel
     */
    pkg.Line = Class(pkg.Panel, [
        function() {
            /**
             * Line colors
             * @attribute colors
             * @type {Array}
             * @readOnly
             * @default [ &quot;gray&quot; ]
             */
            this.$super();

            if (arguments.length &gt; 0) {
                this.setColors.apply(this, arguments);
            }
        },

        function $prototype() {
            this.colors = [ &quot;gray&quot; ];

            /**
             * Line width
             * @attribute lineWidth
             * @type {Integer}
             * @default 1
             */
            this.lineWidth = 1;

            /**
             * Set line color
             * @param {String} c a color
             * @method  setColor
             * @chainable
             */
            this.setColor = function(c) {
                this.setColors(c);
                return this;
            };

            /**
             * Set set of colors to be used to paint the line. Number of colors defines the number of
             * lines to be painted.
             * @param {String} colors* colors
             * @method setLineColors
             * @chainable
             */
            this.setColors = function() {
                this.colors = (arguments.length === 1) ? (Array.isArray(arguments[0]) ? arguments[0].slice(0)
                                                                                      : [ arguments[0] ] )
                                                       : Array.prototype.slice.call(arguments);
                this.repaint();
                return this;
            };

            this.paint = function(g) {
                var isHor  = this.width &gt; this.height,
                    left   = this.getLeft(),
                    right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    xy     = isHor ? top : left;

                for(var i = 0; i &lt; this.colors.length; i++) {
                    if (this.colors[i] !== null) {
                        g.setColor(this.colors[i]);
                        if (isHor === true) {
                            g.drawLine(this.left, xy, this.width - right - left, xy, this.lineWidth);
                        } else {
                            g.drawLine(xy, top, xy, this.height - top - bottom, this.lineWidth);
                        }
                    }
                    xy += this.lineWidth;
                }
            };

            this.calcPreferredSize = function(target) {
                var s = this.colors.length * this.lineWidth;
                return { width: s, height:s};
            };
        }
    ]);

    /**
     * Label UI component class. The label can be used to visualize simple string or multi lines text or
     * the given text render implementation:

            // render simple string
            var l = new zebkit.ui.Label(&quot;Simple string&quot;);

            // render multi lines text
            var l = new zebkit.ui.Label(new zebkit.data.Text(&quot;Multiline\ntext&quot;));

            // render password text
            var l = new zebkit.ui.Label(new zebkit.draw.PasswordText(&quot;password&quot;));

     * @param  {String|zebkit.data.TextModel|zebkit.draw.TextRender} [r] a text to be shown with the label.
     * You can pass a simple string or an instance of a text model or an instance of text render as the
     * text value.
     * @class zebkit.ui.Label
     * @constructor
     * @extends zebkit.ui.ViewPan
     */
    pkg.Label = Class(pkg.ViewPan, [
        function (r) {
            if (arguments.length === 0) {
                this.setView(new zebkit.draw.StringRender(&quot;&quot;));
            } else {
                // test if input string is string
                if (typeof r === &quot;string&quot; || r.constructor === String) {
                    this.setView(r.length === 0 || r.indexOf(&#x27;\n&#x27;) &gt;= 0 ? new zebkit.draw.TextRender(new zebkit.data.Text(r))
                                                                        : new zebkit.draw.StringRender(r));
                } else if (typeof r.clazz         !== &quot;undefined&quot; &amp;&amp;
                           typeof r.getTextLength !== &#x27;undefined&#x27; &amp;&amp;   // a bit faster tnan instanceOf checking if
                           typeof r.getLines      !== &#x27;undefined&#x27;   )  // test if this is an instance of zebkit.data.TextModel
                {
                    this.setView(new zebkit.draw.TextRender(r));
                } else {
                    this.setView(r);
                }
            }
            this.$super();
        },

        function $prototype() {
            /**
             * Get the label text
             * @return {String} a zebkit label text
             * @method getValue
             */
            this.getValue = function() {
                return this.view.toString();
            };

            /**
             * Set the text field text model
             * @param  {zebkit.data.TextModel|String} m a text model to be set
             * @method setModel
             * @chainable
             */
            this.setModel = function(m) {
                this.setView(zebkit.isString(m) ? new zebkit.draw.StringRender(m)
                                                : new zebkit.draw.TextRender(m));
                return this;
            };

            /**
             * Get a text model
             * @return {zebkit.data.TextModel} a text model
             * @method getModel
             */
            this.getModel = function() {
                return this.view !== null ? this.view.target : null;
            };

            /**
             * Get the label text color
             * @return {String} a zebkit label color
             * @method getColor
             */
            this.getColor = function (){
                return this.view.color;
            };

            /**
             * Get the label text font
             * @return {zebkit.Font} a zebkit label font
             * @method getFont
             */
            this.getFont = function (){
                return this.view.font;
            };

            /**
             * Set the label text value
             * @param  {String} s a new label text
             * @method setValue
             * @chainable
             */
            this.setValue = function(s){
                if (s === null) {
                    s = &quot;&quot;;
                }

                var old = this.view.toString();
                if (old !== s) {
                    this.view.setValue(s);
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the label text color
             * @param  {String} c a text color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                var old = this.view.color;
                if (old !== c) {
                    this.view.setColor(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the label text font
             * @param  {zebkit.Font} f a text font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                var old = this.view.font;
                this.view.setFont.apply(this.view, arguments);
                if (old != this.view.font) {
                    this.repaint();
                }
                return this;
            };
        }
    ]);

    /**
     * Shortcut class to render bold text in Label
     * @param {String|zebkit.draw.TextRender|zebkit.data.TextModel} [t] a text string,
     * text model or text render instance
     * @constructor
     * @class zebkit.ui.BoldLabel
     * @extends zebkit.ui.Label
     */
    pkg.BoldLabel = Class(pkg.Label, []);

    /**
     * Image label UI component. This is UI container that consists from an image
     * component and an label component.Image is located at the left size of text.
     * @param {Image|String} img an image or path to the image
     * @param {String|zebkit.draw.TextRender|zebkit.data.TextModel} txt a text string,
     * text model or text render instance
     * @constructor
     * @class zebkit.ui.ImageLabel
     * @extends zebkit.ui.Panel
     */
    pkg.ImageLabel = Class(pkg.Panel, [
        function(txt, path) {
            var img = zebkit.instanceOf(path, pkg.ImagePan) ? path : new this.clazz.ImagePan(path),
                lab = zebkit.instanceOf(txt, pkg.Panel)     ? txt  : new this.clazz.Label(txt);

            img.constraints = &quot;image&quot;;
            lab.constraints = &quot;label&quot;;

            // TODO: this is copy paste of Panel constructor to initialize fields that has to
            // be used for adding child components. these components have to be added before
            // properties() call. a bit dirty trick
            if (typeof this.kids === &quot;undefined&quot;) {
                this.kids = [];
            }

            this.layout = new zebkit.layout.FlowLayout(&quot;left&quot;, &quot;center&quot;, &quot;horizontal&quot;, 6);

            // add before panel constructor thanks to copy pasted code above
            this.add(img);
            this.add(lab);

            this.$super();

            lab.setVisible(txt !== null);
        },

        function $clazz() {
            this.ImagePan = Class(pkg.ImagePan, []);
            this.Label    = Class(pkg.Label, []);
        },

        function $prototype() {
            /**
             * Set the specified caption
             * @param {String|zebkit.ui.Label} c a label text or component
             * @method setValue
             * @chainable
             */
            this.setValue = function(c) {
                var lab = this.byConstraints(&quot;label&quot;);

                if (zebkit.instanceOf(c, pkg.Label)) {
                    var i = -1;
                    if (lab !== null) {
                        i = this.indexOf(lab);
                    }

                    c.constraints = &quot;label&quot;;
                    if (i &gt;= 0) {
                        this.setAt(i, c);
                    }
                } else {
                    lab.setValue(c);
                    lab.setVisible(c !== null);
                }

                return this;
            };

            /**
             * Set the specified label image
             * @param {String|Image} p a path to an image of image object
             * @method setImage
             * @chainable
             */
            this.setImage = function(p) {
                var image = this.byConstraints(&quot;image&quot;);
                image.setImage(p);
                image.setVisible(p !== null);
                return this;
            };

            /**
             * Set the caption font
             * @param {zebkit.Font} a font
             * @method setFont
             * @chainable
             */
            this.setFont = function() {
                var lab = this.byConstraints(&quot;label&quot;);
                if (lab !== null) {
                    lab.setFont.apply(lab, arguments);
                }
                return this;
            };

            /**
             * Set the caption color
             * @param {String} a color
             * @method setColor
             * @chainable
             */
            this.setColor = function (c) {
                var lab = this.byConstraints(&quot;label&quot;);
                if (lab !== null) {
                    lab.setColor(c);
                }
                return this;
            };

            /**
             * Get caption value
             * @return {zebkit.ui.Panel} a caption value
             * @method getValue
             */
            this.getValue = function () {
                var lab = this.byConstraints(&quot;label&quot;);
                return lab === null ? null : lab.getValue();
            };

            /**
             * Set the image alignment.
             * @param {String} an alignment. Following values are possible:
             *
             *    - &quot;left&quot;
             *    - &quot;right&quot;
             *    - &quot;top&quot;
             *    - &quot;bottom&quot;
             *
             * @method  setImgAlignment
             * @chainable
             */
            this.setImgAlignment = function(a) {
                var b   = false,
                    img = this.byConstraints(&quot;image&quot;),
                    i   = this.indexOf(img);

                if (a === &quot;top&quot; || a === &quot;bottom&quot;) {
                    if (this.layout.direction !== &quot;vertical&quot;) {
                        this.layout.direction = &quot;vertical&quot;;
                        b = true;
                    }
                } else if (a === &quot;left&quot; || a === &quot;right&quot;) {
                    if (this.layout.direction !== &quot;horizontal&quot;) {
                        this.layout.direction = &quot;horizontal&quot;;
                        b = true;
                    }
                }

                if (this.layout.ax !== &quot;center&quot;) {
                    this.layout.ax = &quot;center&quot;;
                    b = true;
                }

                if (this.layout.ay !== &quot;center&quot;) {
                    this.layout.ay = &quot;center&quot;;
                    b = true;
                }

                if ((a === &quot;top&quot; || a === &quot;left&quot;) &amp;&amp; i !== 0 ) {
                    this.insert(&quot;image&quot;, 0, this.removeAt(i));
                    b = false;
                } else if ((a === &quot;bottom&quot;  || a === &quot;right&quot;) &amp;&amp; i !== 1) {
                    this.add(&quot;image&quot;, this.removeAt(i));
                    b = false;
                }

                if (b) {
                    this.vrp();
                }

                return this;
            };

            /**
             * Set image preferred size.
             * @param {Integer} w a width and height if the second argument has not been specified
             * @param {Integer} [h] a height
             * @method setImgPreferredSize
             * @chainable
             */
            this.setImgPreferredSize = function (w, h) {
                if (arguments.length === 1) {
                    h = w;
                }
                this.byConstraints(&quot;image&quot;).setPreferredSize(w, h);
                return this;
            };
        }
    ]);

    /**
     * Progress bar UI component class.
     * @class zebkit.ui.Progress
     * @constructor
     * @extends zebkit.ui.Panel
     */

    /**
     * Fired when a progress bar value has been updated

            progress.on(function(src, oldValue) {
                ...
            });

     *  @event fired
     *  @param {zebkit.ui.Progress} src a progress bar that triggers
     *  the event
     *  @param {Integer} oldValue a progress bar previous value
     */
    pkg.Progress = Class(pkg.Panel, [
        function () {
            this.setBundleView(&quot;darkBlue&quot;);
            this._ = new zebkit.util.Listeners();
            this.$super();
        },

        function $prototype() {
            /**
             * Progress bar value
             * @attribute value
             * @type {Integer}
             * @readOnly
             */
            this.value = 0;

            /**
             * Progress bar bundle width
             * @attribute bundleWidth
             * @type {Integer}
             * @readOnly
             * @default 6
             */

            /**
             * Progress bar bundle height
             * @attribute bundleHeight
             * @type {Integer}
             * @readOnly
             * @default 6
             */
            this.bundleWidth = this.bundleHeight = 6;

            /**
             * Gap between bundle elements
             * @default 2
             * @attribute gap
             * @type {Integer}
             * @readOnly
             */
            this.gap = 2;

            /**
             * Progress bar maximal value
             * @attribute maxValue
             * @type {Integer}
             * @readOnly
             * @default 20
             */
            this.maxValue = 20;


            this.bundleView = this.titleView = null;

            /**
             * Progress bar orientation
             * @default &quot;horizontal&quot;
             * @attribute orient
             * @type {String}
             * @readOnly
             */
            this.orient = &quot;horizontal&quot;;

            this.paint = function(g){
                var left    = this.getLeft(),
                    right   = this.getRight(),
                    top     = this.getTop(),
                    bottom  = this.getBottom(),
                    rs      = (this.orient === &quot;horizontal&quot;) ? this.width - left - right
                                                             : this.height - top - bottom,
                    bundleSize = (this.orient === &quot;horizontal&quot;) ? this.bundleWidth
                                                                : this.bundleHeight;

                if (rs &gt;= bundleSize){
                    var vLoc   = Math.floor((rs * this.value) / this.maxValue),
                        x      = left,
                        y      = this.height - bottom,
                        bundle = this.bundleView,
                        wh     = this.orient === &quot;horizontal&quot; ? this.height - top - bottom
                                                              : this.width - left - right;

                    while (x &lt; (vLoc + left) &amp;&amp; this.height - vLoc - bottom &lt; y){
                        if (this.orient === &quot;horizontal&quot;){
                            bundle.paint(g, x, top, bundleSize, wh, this);
                            x += (bundleSize + this.gap);
                        } else {
                            bundle.paint(g, left, y - bundleSize, wh, bundleSize, this);
                            y -= (bundleSize + this.gap);
                        }
                    }

                    if (this.titleView !== null) {
                        var ps = this.bundleView.getPreferredSize();
                        this.titleView.paint(g, Math.floor((this.width  - ps.width ) / 2),
                                                Math.floor((this.height - ps.height) / 2),
                                                ps.width, ps.height, this);
                    }
                }
            };

            this.calcPreferredSize = function(l) {
                var bundleSize = (this.orient === &quot;horizontal&quot;) ? this.bundleWidth
                                                                : this.bundleHeight,
                    v1 = (this.maxValue * bundleSize) + (this.maxValue - 1) * this.gap,
                    ps = this.bundleView.getPreferredSize();

                ps = (this.orient === &quot;horizontal&quot;) ? {
                                                         width :v1,
                                                         height:(this.bundleHeight &gt;= 0 ? this.bundleHeight
                                                                                        : ps.height)
                                                      }
                                                    : {
                                                        width:(this.bundleWidth &gt;= 0 ? this.bundleWidth
                                                                                     : ps.width),
                                                        height: v1
                                                      };
                if (this.titleView !== null) {
                    var tp = this.titleView.getPreferredSize();
                    ps.width  = Math.max(ps.width, tp.width);
                    ps.height = Math.max(ps.height, tp.height);
                }
                return ps;
            };
        },

        /**
         * Set the progress bar orientation
         * @param {String} o an orientation: &quot;vertical&quot; or &quot;horizontal&quot;
         * @method setOrientation
         * @chainable
         */
        function setOrientation(o){
            if (o !== this.orient) {
                this.orient = zebkit.util.$validateValue(o, &quot;horizontal&quot;, &quot;vertical&quot;);
                this.vrp();
            }
            return this;
        },

        /**
         * Set maximal integer value the progress bar value can rich
         * @param {Integer} m a maximal value the progress bar value can rich
         * @method setMaxValue
         * @chainable
         */
        function setMaxValue(m){
            if (m !== this.maxValue) {
                this.maxValue = m;
                this.setValue(this.value);
                this.vrp();
            }
            return this;
        },

        /**
         * Set the current progress bar value
         * @param {Integer} p a progress bar
         * @method setValue
         * @chainable
         */
        function setValue(p){
            p = p % (this.maxValue + 1);
            if (this.value !== p){
                var old = this.value;
                this.value = p;
                this._.fired(this, old);
                this.repaint();
            }
            return this;
        },

        /**
         * Set the given gap between progress bar bundle elements
         * @param {Integer} g a gap
         * @method setGap
         * @chainable
         */
        function setGap(g){
            if (this.gap !== g){
                this.gap = g;
                this.vrp();
            }
            return this;
        },

        /**
         * Set the progress bar bundle element view
         * @param {zebkit.draw.View} v a progress bar bundle view
         * @method setBundleView
         * @chainable
         */
        function setBundleView(v){
            if (this.bundleView != v){
                this.bundleView = zebkit.draw.$view(v);
                this.vrp();
            }
            return this;
        },

        /**
         * Set the progress bar bundle element size
         * @param {Integer} w a bundle element width
         * @param {Integer} h a bundle element height
         * @method setBundleSize
         * @chainable
         */
        function setBundleSize(w, h){
            if (w !== this.bundleWidth &amp;&amp; h !== this.bundleHeight){
                this.bundleWidth  = w;
                this.bundleHeight = h;
                this.vrp();
            }
            return this;
        }
    ]);


    /**
     * State panel class. The class is UI component that allows to customize
     * the component  face, background and border depending on the component
     * state. Number and names of states the component can have is defined
     * by developers. To bind a view to the specified state use zebkit.draw.ViewSet
     * class. For instance if a component has to support two states : &quot;state1&quot; and
     * &quot;state2&quot; you can do it as following:

            // create state component
            var p = new zebkit.ui.StatePan();

            // define border view that contains views for &quot;state1&quot; and &quot;state2&quot;
            p.setBorder({
                &quot;state1&quot;: new zebkit.draw.Border(&quot;red&quot;, 1),
                &quot;state1&quot;: new zebkit.draw.Border(&quot;blue&quot;, 2)

            });

            // define background view that contains views for &quot;state1&quot; and &quot;state2&quot;
            p.setBackground({
                &quot;state1&quot;: &quot;yellow&quot;,
                &quot;state1&quot;: &quot;green&quot;
            });

            // set component state
            p.setState(&quot;state1&quot;);

     * State component children components can listening when the state of the component
     * has been updated by implementing &quot;parentStateUpdated(o,n,id)&quot; method. It gets old
     * state, new state and a view id that is mapped to the new state.  The feature is
     * useful if we are developing a composite components whose children component also
     * should react to a state changing.
     * @class  zebkit.ui.StatePan
     * @constructor
     * @extends zebkit.ui.ViewPan
     */
    pkg.StatePan = Class(pkg.ViewPan, [
        function $prototype() {
            /**
             * Current component state
             * @attribute state
             * @readOnly
             * @default null
             * @type {Object}
             */
            this.state = null;

            /**
             * Set the component state
             * @param {Object} s a state
             * @method  setState
             * @chainable
             */
            this.setState = function(s) {
                if (s !== this.state){
                    var prev = this.state;
                    this.state = s;
                    this.stateUpdated(prev, s);
                }
                return this;
            };

            /**
             * Define the method if the state value has to be
             * somehow converted to a view id. By default the state value
             * itself is used as a view id.
             * @param {Object} s a state to be converted
             * @return {String} a view ID
             * @method toViewId
             */

            /**
             * Called every time the component state has been updated
             * @param  {Integer} o a previous component state
             * @param  {Integer} n a new component state
             * @method stateUpdated
             */
            this.stateUpdated = function(o, n) {
                var b  = false,
                    id = (typeof this.toViewId !== &#x27;undefined&#x27; ? this.toViewId(n) : n);

                if (id !== null) {
                    for(var i = 0; i &lt; this.kids.length; i++) {
                        var kid = this.kids[i];
                        if (typeof kid.setState !== &#x27;undefined&#x27;) {
                            kid.setState(id);
                        }
                    }

                    if (this.border !== null &amp;&amp; typeof this.border.activate !== &#x27;undefined&#x27;) {
                        b = this.border.activate(id, this) === true || b;
                    }

                    if (this.view !== null &amp;&amp; typeof this.view.activate !== &#x27;undefined&#x27;) {
                        b = this.view.activate(id, this) === true || b;
                    }

                    if (this.bg !== null &amp;&amp; typeof this.bg.activate !== &#x27;undefined&#x27;) {
                        b = this.bg.activate(id, this) === true || b;
                    }

                    if (b) {
                        this.repaint();
                    }
                }
            };

            /**
             * Refresh state
             * @protected
             * @method syncState
             */
            this.syncState = function() {
                this.stateUpdated(this.state, this.state);
            };
        },

        function setView(v){
            if (v != this.view){
                this.$super(v);
                // check if the method called after constructor execution
                // otherwise sync is not possible
                if (typeof this.kids !== &#x27;undefined&#x27;) {
                    this.syncState(this.state, this.state);
                }
            }
            return this;
        },

        function setBorder(v){
            if (v != this.border){
                this.$super(v);
                this.syncState(this.state, this.state);
            }
            return this;
        },

        function setBackground(v){
            if (v != this.bg){
                this.$super(v);
                this.syncState(this.state, this.state);
            }
            return this;
        }
    ]);

    /**
     * Event state panel class. The class implements UI component whose face, border and
     * background view depends on its input events state. The component is good basis
     * for creation  dynamic view UI components.The state the component can be is:
     *
     *   - **over** the pointer cursor is inside the component
     *   - **out** the pointer cursor is outside the component
     *   - **pressed over** the pointer cursor is inside the component and an action pointer
     *     button or key is pressed
     *   - **pressed out** the pointer cursor is outside the component and an action pointer
     *     button or key is pressed
     *   - **disabled** the component is disabled
     *
     * The view border, background or face should be set as &quot;zebkit.draw.ViewSet&quot; where an required
     * for the given component state view is identified by an id. By default corresponding to
     * component states views IDs are the following: &quot;over&quot;, &quot;pressed.over&quot;, &quot;out&quot;, &quot;pressed.out&quot;,
     * &quot;disabled&quot;.  Imagine for example we have two colors and we need to change between the colors
     * every time pointer cursor is over/out of the component:

         // create state panel
         var statePan = new zebkit.ui.EvStatePan();

         // add dynamically updated background
         statePan.setBackground(new zebkit.draw.ViewSet({
            &quot;over&quot;: &quot;red&quot;,
            &quot;out&quot;: &quot;blue&quot;
         }));

     * Alone with background border view can be done also dynamic

         // add dynamically updated border
         statePan.setBorder(new zebkit.draw.ViewSet({
            &quot;over&quot;: new zebkit.draw.Border(&quot;green&quot;, 4, 8),
            &quot;out&quot;: null
         }));

     * Additionally the UI component allows developer to specify whether the component can hold
     * input focus and which UI component has to be considered as the focus marker. The focus marker
     * component is used as anchor to paint focus marker view. In simple case the view can be just
     * a border. So border will be rendered around the focus marker component:

         // create state panel that contains one label component
         var statePan = new zebkit.ui.EvStatePan();
         var lab      = new zebkit.ui.Label(&quot;Focus marker label&quot;);
         lab.setPadding(6);
         statePan.setPadding(6);
         statePan.setLayout(new zebkit.layout.BorderLayout());
         statePan.add(&quot;center&quot;, lab);

         // set label as an anchor for focus border indicator
         statePan.setFocusAnchorComponent(lab);
         statePan.setFocusMarkerView(&quot;plain&quot;);

     * @class zebkit.ui.EvStatePan
     * @constructor
     * @extends zebkit.ui.StatePan
     */
    var OVER         = &quot;over&quot;,
        PRESSED_OVER = &quot;pressed.over&quot;,
        OUT          = &quot;out&quot;,
        PRESSED_OUT  = &quot;pressed.out&quot;,
        DISABLED     = &quot;disabled&quot;;

    pkg.EvStatePan = Class(pkg.StatePan,  [
        function $prototype() {
            this.state = OUT;
            this.$isIn = false;

            this.toViewId = function(state) {
                return state;
            };

            this._keyPressed = function(e) {
                if (this.state !== PRESSED_OVER &amp;&amp;
                    this.state !== PRESSED_OUT  &amp;&amp;
                    (e.code === &quot;Enter&quot; || e.code === &quot;Space&quot;))
                {
                    this.setState(PRESSED_OVER);
                }
            };

            this._keyReleased = function(e) {
                if (this.state === PRESSED_OVER || this.state === PRESSED_OUT){
                    this.setState(OVER);
                    if (this.$isIn === false) {
                        this.setState(OUT);
                    }
                }
            };

            this._pointerEntered = function(e) {
                if (this.isEnabled === true) {
                    this.setState(this.state === PRESSED_OUT ? PRESSED_OVER : OVER);
                    this.$isIn = true;
                }
            };

            this._pointerPressed = function(e) {
                if (this.state !== PRESSED_OVER &amp;&amp; this.state !== PRESSED_OUT &amp;&amp; e.isAction()){
                    this.setState(PRESSED_OVER);
                }
            };

            this._pointerReleased = function(e) {
                if ((this.state === PRESSED_OVER || this.state === PRESSED_OUT) &amp;&amp; e.isAction()){
                    if (e.source === this) {
                        this.setState(e.x &gt;= 0 &amp;&amp; e.y &gt;= 0 &amp;&amp; e.x &lt; this.width &amp;&amp; e.y &lt; this.height ? OVER
                                                                                                    : OUT);
                    }
                    else {
                        var p = zebkit.layout.toParentOrigin(e.x, e.y, e.source, this);
                        this.$isIn = p.x &gt;= 0 &amp;&amp; p.y &gt;= 0 &amp;&amp; p.x &lt; this.width &amp;&amp; p.y &lt; this.height;
                        this.setState(this.$isIn ? OVER : OUT);
                    }
                }
            };

            this.childKeyPressed = function(e) {
                this._keyPressed(e);
            };

            this.childKeyReleased = function(e) {
                this._keyReleased(e);
            };

            this.childPointerEntered = function(e) {
                this._pointerEntered(e);
            };

            this.childPointerPressed = function(e) {
                this._pointerPressed(e);
            };

            this.childPointerReleased = function(e) {
                this._pointerReleased(e);
            };

            this.childPointerExited = function(e) {
                // check if the pointer cursor is in of the source component
                // that means another layer has grabbed control
                if (e.x &gt;= 0 &amp;&amp; e.y &gt;= 0 &amp;&amp; e.x &lt; e.source.width &amp;&amp; e.y &lt; e.source.height) {
                    this.$isIn = false;
                }
                else {
                    var p = zebkit.layout.toParentOrigin(e.x, e.y, e.source, this);
                    this.$isIn = p.x &gt;= 0 &amp;&amp; p.y &gt;= 0 &amp;&amp; p.x &lt; this.width &amp;&amp; p.y &lt; this.height;
                }

                if (this.$isIn === false) {
                    this.setState(this.state === PRESSED_OVER ? PRESSED_OUT : OUT);
                }
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                this._keyPressed(e);
            };

            /**
             * Define key released events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyReleased
             */
            this.keyReleased = function(e){
                this._keyReleased(e);
            };

            /**
             * Define pointer entered events handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerEntered
             */
            this.pointerEntered = function (e){
                this._pointerEntered();
            };

            /**
             * Define pointer exited events handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerExited
             */
            this.pointerExited = function(e){
                if (this.isEnabled === true) {
                    this.setState(this.state === PRESSED_OVER ? PRESSED_OUT : OUT);
                    this.$isIn = false;
                }
            };

            /**
             * Define pointer pressed events handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerPressed
             */
            this.pointerPressed = function(e){
                this._pointerPressed(e);
            };

            /**
             * Define pointer released events handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerReleased
             */
            this.pointerReleased = function(e){
                this._pointerReleased(e);
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (e.isAction()) {
                    var pressed = (this.state === PRESSED_OUT || this.state === PRESSED_OVER);
                    if (e.x &gt; 0 &amp;&amp; e.y &gt; 0 &amp;&amp; e.x &lt; this.width &amp;&amp; e.y &lt; this.height) {
                        this.setState(pressed ? PRESSED_OVER : OVER);
                    } else {
                        this.setState(pressed ? PRESSED_OUT : OUT);
                    }
                }
            };
        },

        function setEnabled(b) {
            this.$super(b);
            this.setState(b ? OUT : DISABLED);
            return this;
        }
    ]);

    /**
     * Composite event state panel
     * @constructor
     * @extends zebkit.ui.EvStatePan
     * @class  zebkit.ui.CompositeEvStatePan
     */
    pkg.CompositeEvStatePan = Class(pkg.EvStatePan, [
        function $prototype() {
            /**
             * Indicates if the component can have focus
             * @attribute canHaveFocus
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.canHaveFocus = true;

            /**
             * Indicates this composite component can make its children components
             * event transparent.
             * @attribute catchInput
             * @readOnly
             * @type {Boolean}
             * @default true
             */
            this.catchInput = true;

            /**
             * Component that has to be used as focus indicator anchor
             * @attribute focusComponent
             * @type {zebkit.ui.Panel}
             * @default null
             * @readOnly
             */
            this.focusComponent = null;

            /**
             * Reference to an anchor focus marker component
             * @attribute focusMarkerView
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.focusMarkerView = null;

            /**
             * Focus marker verical and horizontal gaps.
             * @attribute focusMarkerGaps
             * @type {Number}
             * @default 2
             */
            this.focusMarkerGaps = 2;

            this.paintOnTop = function(g){
                var fc = this.focusComponent;
                if (this.focusMarkerView !== null &amp;&amp; fc !== null &amp;&amp; this.hasFocus()) {
                    this.focusMarkerView.paint(g, fc.x - this.focusMarkerGaps,
                                                  fc.y - this.focusMarkerGaps,
                                                  this.focusMarkerGaps * 2 + fc.width,
                                                  this.focusMarkerGaps * 2 + fc.height,
                                                  this);
                }
            };

            /**
             * Set the view that has to be rendered as focus marker when the component gains focus.
             * @param  {String|zebkit.draw.View|Function} c a view.
             * The view can be a color or border string code or view
             * or an implementation of zebkit.draw.View &quot;paint(g,x,y,w,h,t)&quot; method.
             * @method setFocusMarkerView
             * @chainable
             */
            this.setFocusMarkerView = function (c){
                if (c != this.focusMarkerView){
                    this.focusMarkerView = zebkit.draw.$view(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Says if the component can hold focus or not
             * @param  {Boolean} b true if the component can gain focus
             * @method setCanHaveFocus
             */
            this.setCanHaveFocus = function(b){
                if (this.canHaveFocus !== b) {
                    var fm = pkg.focusManager;
                    if (b === false &amp;&amp; fm.focusOwner === this) {
                        fm.requestFocus(null);
                    }
                    this.canHaveFocus = b;
                }
                return this;
            };

            /**
             * Set the specified children component to be used as focus marker view anchor component.
             * Anchor component is a component over that the focus marker view is painted.
             * @param  {zebkit.ui.Panel} c an anchor component
             * @method setFocusAnchorComponent
             * @chainable
             */
            this.setFocusAnchorComponent = function(c) {
                if (this.focusComponent !== c) {
                    if (c !== null &amp;&amp; this.kids.indexOf(c) &lt; 0) {
                        throw new Error(&quot;Focus component doesn&#x27;t exist&quot;);
                    }
                    this.focusComponent = c;
                    this.repaint();
                }
                return this;
            };
        },

        function focused() {
            this.$super();
            this.repaint();
        },

        function kidRemoved(i,l){
            if (l === this.focusComponent) {
                this.focusComponent = null;
            }
            this.$super(i, l);
        }
    ]);


    /**
     * Special interface that provides set of method for state components to implement repeatable
     * state.
     * @class zebkit.ui.ButtonRepeatMix
     * @interface zebkit.ui.ButtonRepeatMix
     */
    pkg.ButtonRepeatMix = zebkit.Interface([
        function $prototype() {
            /**
             * Indicate if the button should
             * fire event by pressed event
             * @attribute isFireByPress
             * @type {Boolean}
             * @default false
             * @readOnly
             */
            this.isFireByPress = false;

            /**
             * Fire button event repeating period. -1 means
             * the button event repeating is disabled.
             * @attribute firePeriod
             * @type {Integer}
             * @default -1
             * @readOnly
             */
            this.firePeriod = -1;

            /**
             * Indicates a time the repeat state events have to start in
             * @attribute startIn
             * @type {Integer}
             * @readOnly
             * @default 400
             */
            this.startIn = 400;

            this.$repeatTask = null;

            /**
             * Set the mode the button has to fire events. Button can fire
             * event after it has been unpressed or immediately when it has
             * been pressed. Also button can start firing events periodically
             * when it has been pressed and held in the pressed state.
             * @param  {Boolean} b  true if the button has to fire event by
             * pressed event
             * @param  {Integer} firePeriod the period of time the button
             * has to repeat firing events if it has been pressed and
             * held in pressed state. -1 means event doesn&#x27;t have
             * repeated
             * @param  {Integer} [startIn] the timeout when repeat events
             * has to be initiated
             * @method setFireParams
             */
            this.setFireParams = function (b, firePeriod, startIn){
                if (this.$repeatTask !== null) {
                    this.$repeatTask.shutdown();
                }

                this.isFireByPress = b;
                this.firePeriod = firePeriod;
                if (arguments.length &gt; 2) {
                    this.startIn = startIn;
                }
                return this;
            };

            this.$fire = function() {
                this.fire();
                if (typeof this.fired !== &#x27;undefined&#x27;) {
                    this.fired();
                }
            };
        },

        function stateUpdated(o,n){
            this.$super(o, n);
            if (n === &quot;pressed.over&quot;) {
                if (this.isFireByPress === true){
                    this.$fire();

                    if (this.firePeriod &gt; 0) {
                        var $this = this;
                        this.$repeatTask = zebkit.util.tasksSet.run(function() {
                                if ($this.state === &quot;pressed.over&quot;) {
                                    $this.$fire();
                                }
                            },
                            this.startIn,
                            this.firePeriod
                        );
                    }
                }
            } else {
                if (this.firePeriod &gt; 0 &amp;&amp; this.$repeatTask !== null) {
                    this.$repeatTask.shutdown();
                }

                if (n === &quot;over&quot; &amp;&amp; (o === &quot;pressed.over&quot; &amp;&amp; this.isFireByPress === false)) {
                    this.$fire();
                }
            }
        }
    ]);

    /**
     * Arrow button component. The component use arrow views as its icon.
     * @class zebkit.ui.ArrowButton
     * @constructor
     * @param  {String} direction an arrow icon direction. Use &quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot; as
     * the parameter value.
     * @extends zebkit.ui.EvStatePan
     * @uses zebkit.ui.ButtonRepeatMix
     */

     /**
      * Fired when a button has been pressed

             var b = new zebkit.ui.ArrowButton(&quot;left&quot;);
             b.on(function (src) {
                 ...
             });

      * Button can be adjusted in respect how it generates the pressed event. Event can be
      * triggered by pressed or clicked even. Also event can be generated periodically if
      * the button is kept in pressed state.
      * @event fired
      * @param {zebkit.ui.ArrowButton} src a button that has been pressed
      */
    pkg.ArrowButton = Class(pkg.EvStatePan, zebkit.util.Fireable, pkg.ButtonRepeatMix, [
        function(direction) {
            this._ = new zebkit.util.Listeners();
            this.cursorType = pkg.Cursor.HAND;

            if (arguments.length &gt; 0) {
                this.direction = zebkit.util.$validateValue(direction, &quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot;);
            }

            var clz = typeof this.clazz.$colors !== &#x27;undefined&#x27; ? this.clazz : pkg.ArrowButton;
            this.setView({
                &quot;out&quot;          : new clz.ArrowView(this.direction, clz.$colors.out),
                &quot;over&quot;         : new clz.ArrowView(this.direction, clz.$colors.over),
                &quot;pressed.over&quot; : new clz.ArrowView(this.direction, clz.$colors[&quot;pressed.over&quot;]),
                &quot;disabled&quot;     : new clz.ArrowView(this.direction, clz.$colors.disabled)
            });

            this.$super();
            this.syncState(this.state, this.state);
        },

        function $clazz() {
            this.ArrowView = Class(zebkit.draw.ArrowView, []);

            this.$colors = {
                &quot;out&quot;          : &quot;red&quot;,
                &quot;over&quot;         : &quot;red&quot;,
                &quot;pressed.over&quot; : &quot;black&quot;,
                &quot;disabled&quot;     : &quot;lightGray&quot;
            };
        },

        function $prototype() {
            /**
             * Arrow icon view direction
             * @attribute direction
             * @type {String}
             * @default &quot;left&quot;
             * @readOnly
             */
            this.direction = &quot;left&quot;;

            /**
             * Set arrow view orientation.
             * @param {String} d an orientation of triangle arrow
             * @method setArrowDirection
             * @chainable
             */
            this.setArrowDirection = function(d) {
                this.iterateArrowViews(function(k, v) {
                    if (v !== null) {
                        v.direction = d;
                    }
                });
                this.repaint();
                return this;
            };

            /**
             * Set arrow view size.
             * @param {Integer} w an arrow view width
             * @param {Integer} h an arrow view height
             * @method setArrowSize
             * @chainable
             */
            this.setArrowSize = function(w, h) {
                if (arguments.length &lt; 2) {
                    h = w;
                }
                this.iterateArrowViews(function(k, v) {
                    if (v !== null) {
                        v.width  = w;
                        v.height = h;
                    }
                });
                this.vrp();
                return this;
            };

            /**
             * Set arrow views states colors.
             * @param {String} pressedColor a pressed state color
             * @param {String} overColor an over state color
             * @param {String} outColor an out state color
             * @method setArrowColors
             * @chainable
             */
            this.setArrowColors = function(pressedColor, overColor, outColor) {
                var views = this.view.views;
                if (views.out !== null &amp;&amp; typeof views.out !== &#x27;undefined&#x27;) {
                    views.out.color = outColor;
                }

                if (views.over.color !== null &amp;&amp; typeof views.over !== &#x27;undefined&#x27;) {
                    views.over.color = overColor;
                }

                if (views[&quot;pressed.over&quot;] !== null &amp;&amp; typeof views[&quot;pressed.over&quot;] !== &#x27;undefined&#x27;) {
                    views[&quot;pressed.over&quot;].color = pressedColor;
                }

                this.repaint();
                return this;
            };

            /**
             * Iterate button arrows views.
             * @param  {Function} callback a callback that is called for every found arrow view.
             * The method gets the view id and view itself as its arguments.
             * @chainable
             * @method iterateArrowViews
             */
            this.iterateArrowViews = function(callback) {
                var views = this.view.views;
                for(var k in views) {
                    if (views.hasOwnProperty(k)) {
                        callback.call(this, k, views[k]);
                    }
                }
                return this;
            };
        }
    ]);

    /**
     *  Button UI component. Button is composite component whose look and feel can
     *  be easily customized:

            // create image button
            var button = new zebkit.ui.Button(new zebkit.ui.ImagePan(&quot;icon1.gif&quot;));

            // create image + caption button
            var button = new zebkit.ui.Button(new zebkit.ui.ImageLabel(&quot;Caption&quot;, &quot;icon1.gif&quot;));

            // create multilines caption button
            var button = new zebkit.ui.Button(&quot;Line1\nLine2&quot;);


     *  @class  zebkit.ui.Button
     *  @constructor
     *  @param {String|zebkit.ui.Panel|zebkit.draw.View} [t] a button label.
     *  The label can be a simple text or an UI component.
     *  @extends zebkit.ui.CompositeEvStatePan
     *  @uses  zebkit.ui.ButtonRepeatMix
     */

    /**
     * Fired when a button has been pressed
     *
     *     var b = new zebkit.ui.Button(&quot;Test&quot;);
     *     b.on(function (src) {
     *         ...
     *     });
     *
     * Button can be adjusted in respect how it generates the pressed event. Event can be
     * triggered by pressed or clicked even. Also event can be generated periodically if
     * the button is kept in pressed state.
     * @event fired
     * @param {zebkit.ui.Button} src a button that has been pressed
     *
     */
    pkg.Button = Class(pkg.CompositeEvStatePan, zebkit.util.Fireable, pkg.ButtonRepeatMix, [
        function(t) {
            this._ = new zebkit.util.Listeners();

            this.$super();

            if (arguments.length &gt; 0 &amp;&amp; t !== null) {
                t = pkg.$component(t, this);
                this.add(t);
                this.setFocusAnchorComponent(t);
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);

            this.ViewPan = Class(pkg.ViewPan, [
                function(v) {
                    this.$super();
                    this.setView(v);
                },

                function $prototype() {
                    this.setState = function(id) {
                        if (this.view !== null &amp;&amp; typeof this.view.activate !== &#x27;undefined&#x27;) {
                            this.activate(id);
                        }
                    };
                }
            ]);

            this.ImageLabel = Class(pkg.ImageLabel, []);
        },

        function $prototype() {
            /**
             * Indicates the component can have focus
             * @attribute canHaveFocus
             * @type {Boolean}
             * @default true
             */
            this.canHaveFocus = true;
        }
    ]);

    /**
     * Group class to help managing group of element where only one can be on.
     *
     *     // create group of check boxes that will work as a radio group
     *     var gr  = new zebkit.ui.Group();
     *     var ch1 = new zebkit.ui.Checkbox(&quot;Test 1&quot;, gr);
     *     var ch2 = new zebkit.ui.Checkbox(&quot;Test 2&quot;, gr);
     *     var ch3 = new zebkit.ui.Checkbox(&quot;Test 3&quot;, gr);
     *
     * @class  zebkit.ui.Group
     * @param {Boolean} [un] indicates if group can have no one item selected.
     * @constructor
     */
    pkg.Group = Class(zebkit.EventProducer, [
        function(un) {
            this.selected = null;
            this._ = new zebkit.util.Listeners();
            if (arguments.length &gt; 0) {
                this.allowNoneSelected = un;
            }
        },

        function $prototype() {
            /**
             * indicates if group can have no one item selected.
             * @attribute allowNoneSelected
             * @readOnly
             * @type {Boolean}
             * @default false
             */
            this.allowNoneSelected = false;

            this.$group  = null;
            this.$locked = false;

            this.$allowValueUpdate = function(src) {
                if (this.$group === null || this.$group.indexOf(src) &lt; 0) {
                    throw new Error(&quot;Component is not the group member&quot;);
                }

                return (this.selected !== src ||
                        src.getValue() === false ||
                        this.allowNoneSelected === true);
            };

            this.attach = function(c) {
                if (this.$group === null) {
                    this.$group = [];
                }

                if (this.$group.indexOf(c) &gt;= 0) {
                    throw new Error(&quot;Duplicated group element&quot;);
                }

                if (this.selected !== null &amp;&amp; c.getValue() === true) {
                    c.setValue(false);
                }

                c.on(this);
                this.$group.push(c);
            };

            this.detach = function(c) {
                if (this.$group === null || this.$group.indexOf(c) &lt; 0) {
                    throw new Error(&quot;Component is not the group member&quot;);
                }

                if (this.selected !== null &amp;&amp; c.getValue() === true) {
                    c.setValue(false);
                }

                c.off(this);
                var i = this.$group.indexOf(c);
                this.$group.splice(i, 1);

                if (this.selected === c) {
                    if (this.allowNoneSelected !== true &amp;&amp; this.$group.length &gt; 0) {
                        this.$group[i % this.$group.length].setValue(true);
                    }
                    this.selected = null;
                }
            };

            this.fired = function(c) {
                if (this.$locked !== true) {
                    try {
                        this.$locked = true;
                        var b   = c.getValue(),
                            old = this.selected;

                        if (this.allowNoneSelected &amp;&amp; b === false &amp;&amp; this.selected !== null) {
                            this.selected = null;
                            this.updated(old);
                        } else if (b &amp;&amp; this.selected !== c) {
                            this.selected = c;
                            if (old !== null) {
                                old.setValue(false);
                            }
                            this.updated(old);
                        }
                    } finally {
                        this.$locked = false;
                    }
                }
            };

            this.updated = function(old) {
                this._.fired(this, this.selected, old);
            };
        }
    ]);

    /**
     * Check-box UI component. The component is a container that consists from two other UI components:
     *
     *   - Box component to keep checker indicator
     *   - Label component to paint label
     *
     * Developers are free to customize the component as they want. There is no limitation regarding
     * how the box and label components have to be laid out, which UI components have to be used as
     * the box or label components, etc. The check box extends state panel component and re-map states
     * to own views IDs:
     *
     *   - **&quot;pressed.out&quot;** - checked and pointer cursor is out
     *   - **&quot;out&quot;** - un-checked and pointer cursor is out
     *   - **&quot;pressed.disabled&quot;** - disabled and checked,
     *   - **&quot;disabled&quot;** - disabled and un-checked ,
     *   - **&quot;pressed.over&quot;** - checked and pointer cursor is over
     *   - **&quot;over&quot;** - un-checked and pointer cursor is out
     *
     *
     * Customize is quite similar to what explained for zebkit.ui.EvStatePan:
     *
     *
     *       // create checkbox component
     *       var ch = new zebkit.ui.Checkbox(&quot;Checkbox&quot;);
     *
     *       // change border when the component checked to green
     *       // otherwise set it to red
     *       ch.setBorder(new zebkit.draw.ViewSet({
     *           &quot;*&quot;: new zebkit.draw.Border(&quot;red&quot;),
     *           &quot;pressed.*&quot;: new zebkit.draw.Border(&quot;green&quot;)
     *       }));
     *
     *       // customize checker box children UI component to show
     *       // green for checked and red for un-cheked states
     *       ch.kids[0].setView(new zebkit.draw.ViewSet({
     *           &quot;*&quot;: &quot;red&quot;,
     *           &quot;pressed.*&quot;: &quot;green&quot;
     *       }));
     *       // sync current state with new look and feel
     *       ch.syncState();
     *
     * Listening checked event should be done by registering a listener in the check box switch manager
     * as follow:
     *
     *       // create check box component
     *       var ch = new zebkit.ui.Checkbox(&quot;Checkbox&quot;);
     *
     *       // register a check box listener
     *       ch.on(function(src) {
     *           var s = src.getValue();
     *           ...
     *       });
     *
     * @class  zebkit.ui.Checkbox
     * @extends zebkit.ui.CompositeEvStatePan
     * @constructor
     * @param {String|zebkit.ui.Panel} [label] a label
     */
    pkg.Checkbox = Class(pkg.CompositeEvStatePan, [
        function (c) {
            if (arguments.length &gt; 0 &amp;&amp; c !== null &amp;&amp; zebkit.isString(c)) {
                c = new this.clazz.Label(c);
            }

            this.$super();

            this._ = new zebkit.util.Listeners();

            /**
             * Reference to box component
             * @attribute box
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.box = new this.clazz.Box();
            this.add(this.box);

            if (arguments.length &gt; 0 &amp;&amp; c !== null) {
                this.add(c);
                this.setFocusAnchorComponent(c);
            }
        },

        function $clazz() {
            /**
             * The box UI component class that is used by default with the check box component.
             * @constructor
             * @class zebkit.ui.Checkbox.Box
             * @extends zebkit.ui.ViewPan
             */
            this.Box = Class(pkg.StatePan, []);

            /**
             * @for zebkit.ui.Checkbox
             */
            this.Label = Class(pkg.Label, []);
        },

        function $prototype() {
            /**
             * Check box state
             * @attribute value
             * @type {Boolean}
             * @readOnly
             * @protected
             */
            this.value = false;



            this.$group = null;

            /**
             * Set the check box state.
             * @param {Boolean} v a state of the check box
             * @method setValue
             * @chainable
             */
            this.setValue = function(v) {
                if (this.value !== v &amp;&amp; (this.$group === null || this.$group.$allowValueUpdate(this))) {
                    this.value = v;
                    this.stateUpdated(this.state, this.state);
                    if (typeof this.switched !== &#x27;undefined&#x27;) {
                        this.switched(this);
                    }
                    this._.fired(this);
                }
                return this;
            };

            /**
             * Get the check box state
             * @return {Boolean} a state
             * @method getValue
             */
            this.getValue = function() {
                return this.value;
            };

            /**
             * Toggle check box state.
             * @method toggle
             * @chainable
             */
            this.toggle = function() {
                this.setValue(this.value !== true);
                return this;
            };

            /**
             * Map the specified state into its symbolic name.
             * @protected
             * @param  {String} state a state
             * @return {String} a symbolic name of the state
             * @method toViewId
             */
            this.toViewId = function(state){
                if (this.isEnabled === true) {
                    return this.getValue() ? (state === &quot;over&quot; ? &quot;pressed.over&quot; : &quot;pressed.out&quot;)
                                           : (state === &quot;over&quot; ? &quot;over&quot; : &quot;out&quot;);
                } else {
                    return this.getValue() ? &quot;pressed.disabled&quot; : &quot;disabled&quot;;
                }
            };

            /**
             * Attach the given check box tho the specified group
             * @param {zebkit.ui.Group} g a group
             * @method setGroup
             * @chainable
             */
            this.setGroup = function(g) {
                if (this.$group !== null) {
                    this.$group.detach(this);
                    this.$group = null;
                }

                if (this.$group !== g) {
                    this.$group = g;
                    if (this.$group !== null) {
                        this.$group.attach(this);
                    }
                }

                return this;
            };
        },

        function stateUpdated(o, n) {
            if (o === &quot;pressed.over&quot; &amp;&amp; n === &quot;over&quot;) {
                this.toggle();
            }
            this.$super(o, n);
        },

        function kidRemoved(index,c) {
            if (this.box === c) {
                this.box = null;
            }
            this.$super(index,c);
        },

        function keyPressed(e){
            if (this.$group !== null &amp;&amp; this.getValue()){
                var d = 0;
                if (e.code === &quot;ArrowLeft&quot; || e.code === &quot;ArrowUp&quot;) {
                    d = -1;
                } else if (e.code === &quot;ArrowRight&quot; || e.code === &quot;ArrowDown&quot;) {
                    d = 1;
                }

                if (d !== 0) {
                    var p = this.parent;
                    for(var i = p.indexOf(this) + d; i &lt; p.kids.length &amp;&amp; i &gt;= 0; i += d) {
                        var l = p.kids[i];
                        if (l.isVisible === true &amp;&amp;
                            l.isEnabled === true &amp;&amp;
                            l.$group    === this.$group )
                        {
                            l.requestFocus();
                            l.setValue(true);
                            break;
                        }
                    }
                    return ;
                }
            }
            this.$super(e);
        }
    ]);

    /**
     * Radio-box UI component class. This class is extension of &quot;zebkit.ui.Checkbox&quot; class that sets group
     * as a default switch manager. The other functionality id identical to check box component. Generally
     * speaking this class is a shortcut for radio box creation.
     * @class  zebkit.ui.Radiobox
     * @constructor
     * @param {String|zebkit.ui.Panel} [label] a label
     * @param {zebkit.ui.Group} [m] a group
     * @extends zebkit.ui.Checkbox
     */
    pkg.Radiobox = Class(pkg.Checkbox, [
        function(lab, group) {
            if (arguments.length &gt; 0) {
                if (zebkit.instanceOf(lab, pkg.Group)) {
                    group = lab;
                    lab   = null;
                }

                this.$super(lab);
            } else {
                this.$super();
            }

            if (typeof group !== &#x27;undefined&#x27;) {
                this.setGroup(group);
            }
        }
    ]);

    /**
     * UI link component class.
     * @class zebkit.ui.Link
     * @param {String} s a link text
     * @constructor
     * @extends zebkit.ui.Button
     */
    pkg.Link = Class(pkg.Button, [
        function(s) {
            // do it before super
            this.view = new zebkit.draw.DecoratedTextRender(s);
            this.overDecoration = &quot;underline&quot;;

            this.$super(null);

            // if colors have not been set with default property set it here
            if (this.colors === null) {
                this.colors  = {
                    &quot;pressed.over&quot; : &quot;blue&quot;,
                    &quot;out&quot;          : &quot;white&quot;,
                    &quot;over&quot;         : &quot;white&quot;,
                    &quot;pressed.out&quot;  : &quot;black&quot;,
                    &quot;disabled&quot;     : &quot;gray&quot;
                };
            }

            this.stateUpdated(this.state, this.state);
        },

        function $prototype() {
            this.colors = null;

            /**
             * Mouse cursor type.
             * @attribute cursorType
             * @default zebkit.ui.Cursor.HAND;
             * @type {String}
             * @readOnly
             */
            this.cursorType = pkg.Cursor.HAND;

            /**
             * Set link font
             * @param {zebkit.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                var old = this.view !== null ? this.view.font
                                             : null;

                this.view.setFont.apply(this.view, arguments);
                if (old !== this.view.font) {
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the link text color for the specified link state
             * @param {String} state a link state
             * @param {String} c a link text color
             * @method  setColor
             * @chainable
             */
            this.setColor = function(state,c){
                if (this.colors[state] !== c){
                    this.colors[state] = c;
                    this.syncState();
                }
                return this;
            };

            this.setColors = function(colors) {
                this.colors = zebkit.clone(colors);
                this.syncState();
                return this;
            };

            this.setValue = function(s) {
                this.view.setValue(s.toString());
                this.repaint();
                return this;
            };
        },

        function stateUpdated(o, n){
            this.$super(o, n);

            var k = this.toViewId(n),
                b = false;

            if (this.view !== null &amp;&amp;
                this.view.color !== this.colors[k] &amp;&amp;
                this.colors[k]  !== null &amp;&amp;
                typeof this.colors[k] !== &#x27;undefined&#x27;)
            {
                this.view.setColor(this.colors[k]);
                b = true;
            }

            if (this.view.decorations &amp;&amp; this.overDecoration &amp;&amp; this.isEnabled === true) {
                if (n === &quot;over&quot;) {
                    this.view.setDecoration(this.overDecoration, this.colors[k]);
                    b = true;
                } else if (this.view.decorations[this.overDecoration]) {
                    this.view.setDecoration(this.overDecoration, null);
                    b = true;
                }
            }

            if (b) {
                this.repaint();
            }
        }
    ]);

    // cannot be declared in Button.$clazz since Link appears later and link inherits Button class
    pkg.Button.Link = Class(pkg.Link, []);


    /**
     * Toolbar UI component. Handy way to place number of click able elements
     * @class zebkit.ui.Toolbar
     * @constructor
     * @extends zebkit.ui.Panel
     */

    /**
     * Fired when a toolbar element has been pressed
     *
     *       var t = new zebkit.ui.Toolbar();
     *
     *       // add three pressable icons
     *       t.addImage(&quot;icon1.jpg&quot;);
     *       t.addImage(&quot;icon2.jpg&quot;);
     *       t.addLine();
     *       t.addImage(&quot;ico3.jpg&quot;);
     *
     *       // catch a toolbar icon has been pressed
     *       t.on(function (src) {
     *           ...
     *       });
     *
     * @event pressed
     * @constructor
     * @param {zebkit.ui.Panel} src a toolbar element that has been pressed
     */
    pkg.Toolbar = Class(pkg.Panel, [
        function () {
            this._ = new zebkit.util.Listeners();
            this.$super();
        },

        function $clazz() {
            this.ToolPan = Class(pkg.EvStatePan, [
                function(c) {
                    this.$super(new zebkit.layout.BorderLayout());
                    this.add(&quot;center&quot;, c);
                },

                function getContentComponent() {
                    return this.kids[0];
                },

                function stateUpdated(o, n) {
                    this.$super(o, n);
                    if (o === &quot;pressed.over&quot; &amp;&amp; n === &quot;over&quot;) {
                        this.parent._.fired(this);
                    }
                }
            ]);

            this.ImagePan = Class(pkg.ImagePan, []);
            this.Line     = Class(pkg.Line, []);
            this.Checkbox = Class(pkg.Checkbox, []);
            this.Radiobox = Class(pkg.Radiobox, []);

            // TODO: combo is not available in  this module yet
            // ui + ui.list has to be combined as one package
            //this.Combo    = Class(pkg.Combo, []);
        },

        function $prototype() {
            /**
             * Test if the given component is a decorative element
             * in the toolbar
             * @param  {zebkit.ui.Panel}  c a component
             * @return {Boolean} return true if the component is
             * decorative element of the toolbar
             * @method isDecorative
             * @protected
             */
            this.isDecorative = function(c){
                return zebkit.instanceOf(c, pkg.EvStatePan) === false;
            };

            /**
             * Add a radio box as the toolbar element that belongs to the
             * given group and has the specified content component
             * @param {zebkit.ui.Group} g a radio group the radio box belongs
             * @param {zebkit.ui.Panel} c a content
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addRadio
             */
            this.addRadio = function(g,c) {
                var cbox = new this.clazz.Radiobox(c, g);
                cbox.setCanHaveFocus(false);
                return this.add(cbox);
            };

            /**
             * Add a check box as the toolbar element with the specified content
             * component
             * @param {zebkit.ui.Panel} c a content
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addSwitcher
             */
            this.addSwitcher = function(c){
                var cbox = new this.clazz.Checkbox(c);
                cbox.setCanHaveFocus(false);
                return this.add(cbox);
            };

            /**
             * Add an image as the toolbar element
             * @param {String|Image} img an image or a path to the image
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addImage
             */
            this.addImage = function(img) {
                this.validateMetric();
                return this.add(new this.clazz.ImagePan(img));
            };

            /**
             * Add line to the toolbar component. Line is a decorative ]
             * element that logically splits toolbar elements. Line as any
             * other decorative element doesn&#x27;t fire event
             * @return {zebkit.ui.Panel} a component that has been added
             * @method addLine
             */
            this.addLine = function(){
                var line = new this.clazz.Line();
                line.constraints = &quot;stretch&quot;;
                return this.addDecorative(line);
            };
        },

        /**
         * Add the given component as decorative element of the toolbar.
         * Decorative elements don&#x27;t fire event and cannot be pressed
         * @param {zebkit.ui.Panel} c a component
         * @return {zebkit.ui.Panel} a component that has been added
         * @method addDecorative
         */
        function addDecorative(c) {
            return this.$getSuper(&quot;insert&quot;).call(this, this.kids.length, null, c);
        },

        function insert(i,id,d){
            if (d === &quot;-&quot;) {
                var line = new this.clazz.Line();
                line.constraints = &quot;stretch&quot;;
                return this.$super(i, null, line);
            } else if (Array.isArray(d)) {
                d = new this.clazz.Combo(d);
            }
            return this.$super(i, id, new this.clazz.ToolPan(d));
        }
    ]);


    /**
     *  Border panel UI component class. The component renders titled border around the
     *  given  content UI component. Border title can be placed on top or
     *  bottom border line and aligned horizontally (left, center, right). Every
     *  zebkit UI component can be used as a border title element.
     *  @param {zebkit.ui.Panel|String} [title] a border panel title. Can be a
     *  string or any other UI component can be used as the border panel title
     *  @param {zebkit.ui.Panel} [content] a content UI component of the border
     *  panel
     *  @param {Integer} [constraints] a title constraints. The constraints gives
     *  a possibility to place border panel title in different places. Generally
     *  the title can be placed on the top or bottom part of the border panel.
     *  Also the title can be aligned horizontally.
     *
     *  @example
     *
     *      // create border panel with a title located at the
     *      // top and aligned at the canter
     *      var bp = new zebkit.ui.BorderPan(&quot;Title&quot;,
     *                                       new zebkit.ui.Panel(),
     *                                       &quot;top&quot;, &quot;center&quot;);
     *
     *  @constructor
     *  @class zebkit.ui.BorderPan
     *  @extends zebkit.ui.Panel
     */
    pkg.BorderPan = Class(pkg.Panel, [
        function(title, center, o, a) {
            if (arguments.length &gt; 0) {
                title = pkg.$component(title, this);
            }

            if (arguments.length &gt; 2) {
                this.orient = o;
            }

            if (arguments.length &gt; 3) {
                this.alignment = a;
            }

            this.$super();
            if (arguments.length &gt; 0) {
                this.add(&quot;caption&quot;, title);
            }

            if (arguments.length &gt; 1) {
                this.add(&quot;center&quot;, center);
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);
            this.ImageLabel = Class(pkg.ImageLabel, []);
            this.Checkbox = Class(pkg.Checkbox, []);
        },

        function $prototype() {
            /**
             * Border panel label content component
             * @attribute content
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.content = null;

            /**
             * Border panel label component
             * @attribute label
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
             this.label = null;

            /**
             * Vertical gap. Define top and bottom paddings between
             * border panel border and the border panel content
             * @attribute vGap
             * @type {Integer}
             * @readOnly
             * @default 0
             */

             /**
              * Horizontal gap. Define left and right paddings between
              * border panel border and the border panel content
              * @attribute hGap
              * @type {Integer}
              * @readOnly
              * @default 0
              */
            this.vGap = this.hGap = 2;

             /**
              * Border panel label indent
              * @type {Integer}
              * @attribute indent
              * @readOnly
              * @default 4
              */
            this.indent = 4;

            /**
             * Border panel title area arrangement. Border title can be placed
             * either at the top or bottom area of border panel component.
             * @type {String}
             * @attribute orient
             * @readOnly
             * @default &quot;top&quot;
             */
            this.orient = &quot;top&quot;;

            /**
             * Border panel title horizontal alignment.
             * @type {String}
             * @attribute alignment
             * @readOnly
             * @default &quot;left&quot;
             */
            this.alignment = &quot;left&quot;;

             /**
              * Get the border panel title info. The information
              * describes a rectangular area the title occupies, the
              * title location and alignment
              * @return {Object} a title info
              *
              *  {
              *      x: {Integer}, y: {Integer},
              *      width: {Integer}, height: {Integer},
              *      orient: {Integer}
              *  }
              *
              * @method getTitleInfo
              * @protected
              */
            this.getTitleInfo = function() {
                return (this.label !== null) ? { x      : this.label.x,
                                                 y      : this.label.y,
                                                 width  : this.label.width,
                                                 height : this.label.height,
                                                 orient: this.orient }
                                             : null;
            };

            this.calcPreferredSize = function(target){
                var ps = this.content !== null &amp;&amp; this.content.isVisible === true ? this.content.getPreferredSize()
                                                                                  : { width:0, height:0 };
                if (this.label !== null &amp;&amp; this.label.isVisible === true){
                    var lps = this.label.getPreferredSize();
                    ps.height += lps.height;
                    ps.width = Math.max(ps.width, lps.width + this.indent);
                }
                ps.width  += (this.hGap * 2);
                ps.height += (this.vGap * 2);
                return ps;
            };

            this.doLayout = function (target){
                var h = 0,
                    right  = this.getRight(),
                    left   = this.getLeft(),
                    top    = this.orient === &quot;top&quot;   ? this.top    : this.getTop(),
                    bottom = this.orient === &quot;bottom&quot;? this.bottom : this.getBottom();

                if (this.label !== null &amp;&amp; this.label.isVisible === true){
                    var ps = this.label.getPreferredSize();
                    h = ps.height;
                    this.label.setBounds((this.alignment === &quot;left&quot;) ? left + this.indent
                                                                      : ((this.alignment === &quot;right&quot;) ? this.width - right - ps.width - this.indent
                                                                                                       : Math.floor((this.width - ps.width) / 2)),
                                         (this.orient === &quot;bottom&quot;) ? (this.height - bottom - ps.height) : top,
                                         ps.width, h);
                }

                if (this.content !== null &amp;&amp; this.content.isVisible === true){
                    this.content.setBounds(left + this.hGap,
                                           (this.orient === &quot;bottom&quot; ? top : top + h) + this.vGap,
                                            this.width  - right - left - 2 * this.hGap,
                                            this.height - top - bottom - h - 2 * this.vGap);
                }
            };

            /**
             * Set vertical and horizontal paddings between the border panel border and the content
             * of the border panel
             * @param {Integer} vg a top and bottom paddings
             * @param {Integer} hg a left and right paddings
             * @method setGaps
             * @chainable
             */
            this.setGaps = function(vg, hg){
                if (this.vGap !== vg || hg !== this.hGap){
                    this.vGap = vg;
                    this.hGap = hg;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set border panel title orientation. The title area can be
             * placed either at the top or at the bottom of border panel
             * component.
             * @param {String} o a border title orientation. Can be &quot;top&quot; or &quot;bottom&quot;
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, &quot;top&quot;, &quot;bottom&quot;);
                    this.vrp();
                }
                return this;
            };

            /**
             * Set border panel title horizontal alignment.
             * @param {String} a a horizontal alignment. Use &quot;left&quot;, &quot;right&quot;, &quot;center&quot; as
             * the parameter value.
             * @method setAlignment
             * @chainable
             */
            this.setAlignment = function(a) {
                if (this.alignment !== a) {
                    this.alignment = zebkit.util.$validateValue(a, &quot;left&quot;, &quot;right&quot;, &quot;center&quot;);
                    this.vrp();
                }
                return this;
            };
        },

        function setBorder(br) {
            br = zebkit.draw.$view(br);
            if (zebkit.instanceOf(br, zebkit.draw.TitledBorder) === false) {
                br = new zebkit.draw.TitledBorder(br, &quot;center&quot;);
            }
            return this.$super(br);
        },

        function kidAdded(index, ctr, lw) {
            this.$super(index, ctr, lw);
            if ((ctr === null &amp;&amp; this.content === null) || &quot;center&quot; === ctr) {
                this.content = lw;
            } else if (this.label === null) {
                this.label = lw;
            }
        },

        function kidRemoved(index,lw){
            this.$super(index, lw);
            if (lw === this.label) {
                this.label = null;
            } else if (this.content === lw) {
                this.content = null;
            }
        }
    ]);

    /**
     * Splitter panel UI component class. The component splits its area horizontally or vertically into two areas.
     * Every area hosts an UI component. A size of the parts can be controlled by pointer cursor dragging. Gripper
     * element is children UI component that can be customized. For instance:

          // create split panel
          var sp = new zebkit.ui.SplitPan(new zebkit.ui.Label(&quot;Left panel&quot;),
                                          new zebkit.ui.Label(&quot;Right panel&quot;));

          // customize gripper background color depending on its state
          sp.gripper.setBackground(new zebkit.draw.ViewSet({
               &quot;over&quot; : &quot;yellow&quot;
               &quot;out&quot; : null,
               &quot;pressed.over&quot; : &quot;red&quot;
          }));


     * @param {zebkit.ui.Panel} [first] a first UI component in splitter panel
     * @param {zebkit.ui.Panel} [second] a second UI component in splitter panel
     * @param {String} [o] an orientation of splitter element: &quot;vertical&quot; or &quot;horizontal&quot;
     * @class zebkit.ui.SplitPan
     * @constructor
     * @extends zebkit.ui.Panel
     */
    pkg.SplitPan = Class(pkg.Panel, [
        function(f,s,o) {
            if (arguments.length &gt; 2) {
                this.orient = o;
            }

            this.$super();

            if (arguments.length &gt; 0) {
                this.add(&quot;left&quot;, f);
                if (arguments.length &gt; 1) {
                    this.add(&quot;right&quot;, s);
                }
            }

            this.add(&quot;center&quot;, new this.clazz.Bar(this));
        },

        function $clazz() {
            this.Bar = Class(pkg.EvStatePan, [
                function(target) {
                    this.target = target;
                    this.$super();
                },

                function $prototype() {
                    this.prevLoc = 0;

                    this.pointerDragged = function(e){
                        var x = this.x + e.x, y = this.y + e.y;
                        if (this.target.orient === &quot;vertical&quot;){
                            if (this.prevLoc !== x){
                                x = this.target.normalizeBarLoc(x);
                                if (x &gt; 0){
                                    this.prevLoc = x;
                                    this.target.setGripperLoc(x);
                                }
                            }
                        } else {
                            if (this.prevLoc !== y) {
                                y = this.target.normalizeBarLoc(y);
                                if (y &gt; 0){
                                    this.prevLoc = y;
                                    this.target.setGripperLoc(y);
                                }
                            }
                        }
                    };

                    this.pointerDragStarted = function (e){
                        var x = this.x + e.x,
                            y = this.y + e.y;

                        if (e.isAction()) {
                            if (this.target.orient === &quot;vertical&quot;){
                                x = this.target.normalizeBarLoc(x);
                                if (x &gt; 0) {
                                    this.prevLoc = x;
                                }
                            } else {
                                y = this.target.normalizeBarLoc(y);
                                if (y &gt; 0) {
                                    this.prevLoc = y;
                                }
                            }
                        }
                    };

                    this.pointerDragEnded = function(e){
                        var xy = this.target.normalizeBarLoc(this.target.orient === &quot;vertical&quot; ? this.x + e.x
                                                                                               : this.y + e.y);
                        if (xy &gt; 0) {
                            this.target.setGripperLoc(xy);
                        }
                    };

                    this.getCursorType = function(t, x, y) {
                        return (this.target.orient === &quot;vertical&quot; ? pkg.Cursor.W_RESIZE
                                                                  : pkg.Cursor.N_RESIZE);
                    };
                }
            ]);
        },

        function $prototype() {
            /**
             * A minimal size of the left (or top) sizable panel
             * @attribute leftMinSize
             * @type {Integer}
             * @readOnly
             * @default 50
             */

            /**
             * A minimal size of right (or bottom) sizable panel
             * @attribute rightMinSize
             * @type {Integer}
             * @readOnly
             * @default 50
             */

            /**
             * Indicates if the splitter bar can be moved
             * @attribute isMoveable
             * @type {Boolean}
             * @readOnly
             * @default true
             */

            /**
             * A gap between gripper element and first and second UI components
             * @attribute gap
             * @type {Integer}
             * @readOnly
             * @default 1
             */

            /**
             * A reference to gripper UI component
             * @attribute gripper
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            /**
             * A reference to left (top) sizable UI component
             * @attribute leftComp
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            /**
             * A reference to right (bottom) sizable UI component
             * @attribute rightComp
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.leftMinSize = this.rightMinSize = 50;
            this.isMoveable = true;
            this.gap = 1;
            this.orient = &quot;vertical&quot;;

            this.minXY = this.maxXY = 0;
            this.barLocation = 70;
            this.leftComp = this.rightComp = this.gripper = null;

            this.normalizeBarLoc = function(xy){
                if (xy &lt; this.minXY) {
                    xy = this.minXY;
                } else if (xy &gt; this.maxXY) {
                    xy = this.maxXY;
                }

                return (xy &gt; this.maxXY || xy &lt; this.minXY) ?  -1 : xy;
            };

            /**
             * Set split panel orientation.
             * @param  {String} o an orientation (&quot;horizontal&quot; or &quot;vertical&quot;)
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (o !== this.orient) {
                    this.orient = zebkit.util.$validateValue(o, &quot;horizontal&quot;, &quot;vertical&quot;);
                    this.vrp();
                }
                return this;
            };

            /**
             * Set gripper element location
             * @param  {Integer} l a location of the gripper element
             * @method setGripperLoc
             * @chainable
             */
            this.setGripperLoc = function(l){
                if (l !== this.barLocation){
                    this.barLocation = l;
                    this.vrp();
                }
                return this;
            };

            this.calcPreferredSize = function(c){
                var fSize = pkg.$getPS(this.leftComp),
                    sSize = pkg.$getPS(this.rightComp),
                    bSize = pkg.$getPS(this.gripper);

                if (this.orient === &quot;horizontal&quot;){
                    bSize.width = Math.max(((fSize.width &gt; sSize.width) ? fSize.width : sSize.width), bSize.width);
                    bSize.height = fSize.height + sSize.height + bSize.height + 2 * this.gap;
                }
                else {
                    bSize.width = fSize.width + sSize.width + bSize.width + 2 * this.gap;
                    bSize.height = Math.max(((fSize.height &gt; sSize.height) ? fSize.height : sSize.height), bSize.height);
                }
                return bSize;
            };

            this.doLayout = function(target){
                var right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    bSize  = pkg.$getPS(this.gripper);

                if (this.orient === &quot;horizontal&quot;){
                    var w = this.width - left - right;
                    if (this.barLocation &lt; top) {
                        this.barLocation = top;
                    } else if (this.barLocation &gt; this.height - bottom - bSize.height) {
                        this.barLocation = this.height - bottom - bSize.height;
                    }

                    if (this.gripper !== null){
                        if (this.isMoveable){
                            this.gripper.setBounds(left, this.barLocation, w, bSize.height);
                        } else {
                            this.gripper.toPreferredSize();
                            this.gripper.setLocation(Math.floor((w - bSize.width) / 2), this.barLocation);
                        }
                    }

                    if (this.leftComp !== null){
                        this.leftComp.setBounds(left, top, w, this.barLocation - this.gap - top);
                    }

                    if (this.rightComp !== null){
                        this.rightComp.setLocation(left, this.barLocation + bSize.height + this.gap);
                        this.rightComp.setSize(w, this.height - this.rightComp.y - bottom);
                    }
                } else {
                    var h = this.height - top - bottom;
                    if (this.barLocation &lt; left) {
                        this.barLocation = left;
                    } else if (this.barLocation &gt; this.width - right - bSize.width) {
                        this.barLocation = this.width - right - bSize.width;
                    }

                    if (this.gripper !== null){
                        if (this.isMoveable === true){
                            this.gripper.setBounds(this.barLocation, top, bSize.width, h);
                        } else {
                            this.gripper.setBounds(this.barLocation, Math.floor((h - bSize.height) / 2),
                                                   bSize.width, bSize.height);
                        }
                    }

                    if (this.leftComp !== null){
                        this.leftComp.setBounds(left, top, this.barLocation - left - this.gap, h);
                    }

                    if (this.rightComp !== null){
                        this.rightComp.setLocation(this.barLocation + bSize.width + this.gap, top);
                        this.rightComp.setSize(this.width - this.rightComp.x - right, h);
                    }
                }
            };

            /**
             * Set gap between gripper element and sizable panels
             * @param  {Integer} g a gap
             * @method setGap
             * @chainable
             */
            this.setGap = function (g){
                if (this.gap !== g){
                    this.gap = g;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the minimal size of the left (or top) sizeable panel
             * @param  {Integer} m  a minimal possible size
             * @method setLeftMinSize
             * @chainable
             */
            this.setLeftMinSize = function (m){
                if (this.leftMinSize !== m){
                    this.leftMinSize = m;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the minimal size of the right (or bottom) sizeable panel
             * @param  {Integer} m  a minimal possible size
             * @method setRightMinSize
             * @chainable
             */
            this.setRightMinSize = function(m){
                if (this.rightMinSize !== m){
                    this.rightMinSize = m;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given gripper movable state
             * @param  {Boolean} b the gripper movable state.
             * @method setGripperMovable
             */
            this.setGripperMovable = function (b){
                if (b !== this.isMoveable){
                    this.isMoveable = b;
                    this.vrp();
                }
                return this;
            };
        },

        function kidAdded(index, ctr, c){
            this.$super(index, ctr, c);

            if ((ctr === null &amp;&amp; this.leftComp === null) || &quot;left&quot; === ctr) {
                this.leftComp = c;
            } else if ((ctr === null &amp;&amp; this.rightComp === null) || &quot;right&quot; === ctr) {
                this.rightComp = c;
            } else {
                if (&quot;center&quot; === ctr) {
                    this.gripper = c;
                } else {
                    throw new Error(&quot;&quot; + ctr);
                }
            }
        },

        function kidRemoved(index,c){
            this.$super(index, c);
            if (c === this.leftComp) {
                this.leftComp = null;
            } else {
                if (c === this.rightComp) {
                    this.rightComp = null;
                } else if (c === this.gripper) {
                    this.gripper = null;
                }
            }
        },

        function resized(pw,ph) {
            var ps = this.gripper.getPreferredSize();
            if (this.orient === &quot;vertical&quot;){
                this.minXY = this.getLeft() + this.gap + this.leftMinSize;
                this.maxXY = this.width - this.gap - this.rightMinSize - ps.width - this.getRight();
            } else {
                this.minXY = this.getTop() + this.gap + this.leftMinSize;
                this.maxXY = this.height - this.gap - this.rightMinSize - ps.height - this.getBottom();
            }
            this.$super(pw, ph);
        }
    ]);

    /**
     * Extendable  UI panel class. Implement collapsible panel where
     * a user can hide of show content by pressing special control
     * element:

            // create extendable panel that contains list as its content
            var ext = zebkit.ui.CollapsiblePan(&quot;Title&quot;, new zebkit.ui.List([
                &quot;Item 1&quot;,
                &quot;Item 2&quot;,
                &quot;Item 3&quot;
            ]));


     * @constructor
     * @class zebkit.ui.CollapsiblePan
     * @extends zebkit.ui.Panel
     * @param {zebkit.ui.Panel|String} l a title label text or
     * @param {zebkit.ui.Panel} c a content of the extender panel
     * component
     */

     /**
      * Fired when extender is collapsed or extended

             var ex = new zebkit.ui.CollapsiblePan(&quot;Title&quot;, pan);
             ex.on(function (src, isCollapsed) {
                 ...
             });

      * @event fired
      * @param {zebkit.ui.CollapsiblePan} src an extender UI component that generates the event
      * @param {Boolean} isCollapsed a state of the extender UI component
      */
    pkg.CollapsiblePan = Class(pkg.Panel, [
        function(lab, content){
            this.$super();

            this.headerPan = new this.clazz.Header();
            this.togglePan = new this.clazz.Toogle();
            this.togglePan.on(this);

            this.add(&quot;top&quot;, this.headerPan);

            this.headerPan.add(this.togglePan);
            this.headerPan.add(pkg.$component(arguments.length === 0 || lab === null ? &quot;&quot; : lab, this));

            if (arguments.length &gt; 1 &amp;&amp; content !== null) {
                this.contentPan = content;
                content.setVisible(this.getValue());
                this.add(&quot;center&quot;, this.contentPan);
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label,[]);

            this.ImageLabel = Class(pkg.ImageLabel, []);

            this.Header = Class(pkg.CompositeEvStatePan, []);

            this.Toogle = Class(pkg.Checkbox, [
                function $prototype() {
                    this.cursorType = pkg.Cursor.HAND;
                },

                function $clazz() {
                    this.layout = new zebkit.layout.FlowLayout();
                }
            ]);

            this.GroupPan = Class(pkg.Panel, [
                function() {
                    this.group = new pkg.Group(true);

                    this.$super();
                    for(var i = 0; i &lt; arguments.length; i++) {
                        arguments[i].togglePan.setGroup(this.group);
                        this.add(arguments[i]);
                        arguments[i].setBorder(null);
                    }
                },

                function $prototype() {
                    this.doLayout = function(t) {
                        var y     = t.getTop(),
                            x     = t.getLeft(),
                            w     = t.width  - x - t.getRight(),
                            eh    = t.height - y - t.getBottom(),
                            kid   = null,
                            i     = 0;

                        // setup sizes for not selected item and calculate the vertical
                        // space that can be used for an expanded item
                        for(i = 0; i &lt; t.kids.length; i++) {
                            kid = t.kids[i];
                            if (kid.isVisible) {
                                if (kid.getValue() === false) {
                                    var psh = kid.getPreferredSize().height;
                                    eh -= psh;
                                    kid.setSize(w, psh);
                                }
                            }
                        }

                        for(i = 0; i &lt; t.kids.length; i++) {
                            kid = t.kids[i];
                            if (kid.isVisible) {
                                kid.setLocation(x, y);
                                if (kid.getValue()) {
                                    kid.setSize(w, eh);
                                }
                                y += kid.height;
                            }
                        }
                    };

                    this.calcPreferredSize = function(t) {
                        var w = 0,
                            h = 0;

                        for(var i = 0; i &lt; t.kids.length; i++) {
                            var kid = t.kids[i];
                            if (kid.isVisible) {
                                var ps = kid.getPreferredSize();
                                h += ps.height;
                                if (ps.width &gt; w) {
                                    w = ps.width;
                                }
                            }
                        }
                        return { width:w, height:h };
                    };

                    this.compAdded = function(e) {
                        if (this.group.selected === null) {
                            e.kid.setValue(true);
                        }
                    };

                    this.compRemoved = function(e) {
                        if (this.group.selected === e.kid.togglePan) {
                            e.kid.setValue(false);
                        }
                        e.kid.setGroup(null);
                    };
                }
            ]);
        },

        function $prototype() {
            /**
             * Title panel
             * @type {zebkit.ui.Panel}
             * @attribute headerPan
             * @readOnly
             */
            this.headerPan = null;

            /**
             * Content panel
             * @type {zebkit.ui.Panel}
             * @readOnly
             * @attribute contentPan
             */
            this.contentPan = null;

            /**
             * Toggle UI element
             * @type {zebkit.ui.Checkbox}
             * @readOnly
             * @attribute togglePan
             */
            this.togglePan = null;

            this.setValue = function(b) {
                if (this.togglePan !== null) {
                    this.togglePan.setValue(b);
                }
                return this;
            };

            this.getValue = function(b) {
                return (this.togglePan !== null) ? this.togglePan.getValue() : false;
            };

            this.setGroup = function(g) {
                if (this.togglePan !== null) {
                    this.togglePan.setGroup(g);
                }
                return this;
            };

            this.toggle = function() {
                if (this.togglePan !== null) {
                    this.togglePan.toggle();
                }
                return this;
            };

            this.fired = function(src) {
                var value = this.getValue();
                if (this.contentPan !== null) {
                    this.contentPan.setVisible(value);
                }
            };

            this.compRemoved = function(e) {
                if (this.headerPan === e.kid) {
                    this.headerPan = null;
                } else if (e.kid === this.contentPan) {
                    this.contentPan = null;
                } else if (e.kid === this.togglePan) {
                    this.togglePan.off(this);
                    this.togglePan = null;
                }
            };
        }
    ]);

    /**
     * Status bar UI component class
     * @class zebkit.ui.StatusBar
     * @constructor
     * @param {Integer} [gap] a gap between status bar children elements
     * @extends zebkit.ui.Panel
     */
    pkg.StatusBarPan = Class(pkg.Panel, [
        function (gap){
            if (arguments.length === 0) {
                gap = 2;
            }

            this.setPadding(gap, 0, 0, 0);
            this.$super(new zebkit.layout.PercentLayout(&quot;horizontal&quot;, gap));
        },

        function $prototype() {
            /**
             * Set the specified border to be applied for status bar children components
             * @param {zebkit.draw.View} v a border
             * @method setBorderView
             * @chainable
             */
            this.setBorderView = function(v){
                if (v != this.borderView){
                    this.borderView = v;
                    for(var i = 0; i &lt; this.kids.length; i++) {
                        this.kids[i].setBorder(this.borderView);
                    }
                    this.repaint();
                }
                return this;
            };
        },

        function insert(i,s,d){
            d.setBorder(this.borderView);
            this.$super(i, s, d);
        }
    ]);

    /**
     * Panel class that uses zebkit.layout.StackLayout as a default layout manager.
     * @class  zebkit.ui.StackPan
     * @param {zebkit.ui.Panel} [varname]* number of components to be added to the stack
     * panel
     * @constructor
     * @extends zebkit.ui.Panel
     */
    pkg.StackPan = Class(pkg.Panel, [
        function() {
            this.$super(new zebkit.layout.StackLayout());
            for(var i = 0; i &lt; arguments.length; i++) {
                this.add(arguments[i]);
            }
        }
    ]);


    /**
     * Scroll manager class.
     * @param {zebkit.ui.Panel} t a target component to be scrolled
     * @constructor
     * @class zebkit.ui.ScrollManager
     */

     /**
      * Fired when a target component has been scrolled

            scrollManager.on(function(px, py) {
                ...
            });

      * @event scrolled
      * @param  {Integer} px a previous x location target component scroll location
      * @param  {Integer} py a previous y location target component scroll location
      */

     /**
      * Fired when a scroll state has been updated

            scrollManager.scrollStateUpdated = function(x, y, px, py) {
                ...
            };

      * @event scrollStateUpdated
      * @param  {Integer} x a new x location target component scroll location
      * @param  {Integer} y a new y location target component scroll location
      * @param  {Integer} px a previous x location target component scroll location
      * @param  {Integer} py a previous y location target component scroll location
      */
    pkg.ScrollManager = Class(zebkit.EventProducer, [
        function(c) {
            this._  = new this.clazz.Listeners();

            /**
             * Target UI component for that the scroll manager has been instantiated
             * @attribute target
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.target = c;
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;scrolled&quot;);
        },

        function $prototype() {
            this.sx = this.sy = 0;

            /**
             * Get current target component x scroll location
             * @return {Integer} a x scroll location
             * @method getSX
             */
            this.getSX = function() {
                return this.sx;
            };

            /**
             * Get current target component y scroll location
             * @return {Integer} a y scroll location
             * @method getSY
             */
            this.getSY = function() {
                return this.sy;
            };

            /**
             * Set a target component scroll x location to the
             * specified value
             * @param  {Integer} v a x scroll location
             * @method scrollXTo
             */
            this.scrollXTo = function(v){
                this.scrollTo(v, this.getSY());
            };

            /**
             * Set a target component scroll y location to the
             * specified value
             * @param  {Integer} v a y scroll location
             * @method scrollYTo
             */
            this.scrollYTo = function(v){
                this.scrollTo(this.getSX(), v);
            };

            /**
             * Scroll the target component into the specified location
             * @param  {Integer} x a x location
             * @param  {Integer} y a y location
             * @method scrollTo
             */
            this.scrollTo = function(x, y){
                var psx = this.getSX(),
                    psy = this.getSY();

                if (psx !== x || psy !== y){
                    this.sx = x;
                    this.sy = y;
                    if (typeof this.scrollStateUpdated !== &#x27;undefined&#x27;) {
                        this.scrollStateUpdated(x, y, psx, psy);
                    }
                    if (typeof this.target.catchScrolled !== &#x27;undefined&#x27;) {
                        this.target.catchScrolled(psx, psy);
                    }
                    this._.scrolled(psx, psy);
                }
                return this;
            };

            /**
             * Make visible the given rectangular area of the
             * scrolled target component
             * @param  {Integer} x a x coordinate of top left corner
             * of the rectangular area
             * @param  {Integer} y a y coordinate of top left corner
             * of the rectangular area
             * @param  {Integer} w a width of the rectangular area
             * @param  {Integer} h a height of the rectangular area
             * @method makeVisible
             * @chainable
             */
            this.makeVisible = function(x,y,w,h){
                var p = pkg.calcOrigin(x, y, w, h, this.getSX(), this.getSY(), this.target);
                this.scrollTo(p[0], p[1]);
                return this;
            };
        }
    ]);

    /**
     * Scroll bar UI component
     * @param {String} [t] orientation of the scroll bar components:

            &quot;vertical&quot; - vertical scroll bar
            &quot;horizontal&quot;- horizontal scroll bar

     * @class zebkit.ui.Scroll
     * @constructor
     * @extends zebkit.ui.Panel
     * @uses zebkit.util.Position.Metric
     */
    pkg.Scroll = Class(pkg.Panel, zebkit.util.Position.Metric, [
        function(t) {
            if (arguments.length &gt; 0) {
                this.orient = zebkit.util.$validateValue(t, &quot;vertical&quot;, &quot;horizontal&quot;);
            }

            /**
             * Increment button
             * @attribute incBt
             * @type {zebkit.ui.Button}
             * @readOnly
             */

            /**
             * Decrement button
             * @attribute decBt
             * @type {zebkit.ui.Button}
             * @readOnly
             */

            /**
             * Scroll bar bundle component
             * @attribute bundle
             * @type {zebkit.ui.Panel}
             * @readOnly
             */

            this.bundleLoc = 0;
            this.startDragLoc = Number.MAX_VALUE;
            this.$super(this);

            var b = (this.orient === &quot;vertical&quot;);
            this.add(&quot;center&quot;, b ? new pkg.Scroll.VBundle()    : new pkg.Scroll.HBundle());
            this.add(&quot;top&quot;   , b ? new pkg.Scroll.VDecButton() : new pkg.Scroll.HDecButton());
            this.add(&quot;bottom&quot;, b ? new pkg.Scroll.VIncButton() : new pkg.Scroll.HIncButton());

            this.setPosition(new zebkit.util.SingleColPosition(this));
        },

        function $clazz() {
            this.isDragable = true;

            this.ArrowButton = Class(pkg.ArrowButton, [
                function $prototype() {
                    this.isFireByPress  = true;
                    this.firePeriod     = 20;
                }
            ]);

            this.VIncButton = Class(this.ArrowButton, []);
            this.VDecButton = Class(this.ArrowButton, []);
            this.HIncButton = Class(this.ArrowButton, []);
            this.HDecButton = Class(this.ArrowButton, []);

            this.VBundle = Class(pkg.Panel, []);
            this.HBundle = Class(pkg.Panel, []);

            this.MIN_BUNDLE_SIZE = 16;
        },

        function $prototype() {
            this.incBt = this.decBt = this.bundle = this.position = null;

            /**
             * Maximal possible value
             * @attribute max
             * @type {Integer}
             * @readOnly
             * @default 100
             */
            this.extra = this.max  = 100;

            /**
             * Page increment value
             * @attribute pageIncrement
             * @type {Integer}
             * @readOnly
             * @default 20
             */
            this.pageIncrement = 20;

            /**
             * Unit increment value
             * @attribute unitIncrement
             * @type {Integer}
             * @readOnly
             * @default 5
             */
            this.unitIncrement = 5;


            /**
             * Scroll orientation.
             * @attribute orient
             * @type {String}
             * @readOnly
             * @default &quot;vertical&quot;
             */
            this.orient = &quot;vertical&quot;;

            /**
             * Evaluate if the given point is in scroll bar bundle element
             * @param  {Integer}  x a x location
             * @param  {Integer}  y a y location
             * @return {Boolean}   true if the point is located inside the
             * scroll bar bundle element
             * @method isInBundle
             */
            this.isInBundle = function(x,y){
                var bn = this.bundle;
                return (bn !== null &amp;&amp;
                        bn.isVisible === true &amp;&amp;
                        bn.x &lt;= x &amp;&amp; bn.y &lt;= y &amp;&amp;
                        bn.x + bn.width &gt; x &amp;&amp;
                        bn.y + bn.height &gt; y);
            };

            this.amount = function(){
                var db = this.decBt;
                return (this.orient === &quot;vertical&quot;) ? this.incBt.y - db.y - db.height
                                                    : this.incBt.x - db.x - db.width;
            };

            this.pixel2value = function(p) {
                var db = this.decBt;
                return (this.orient === &quot;vertical&quot;) ? Math.floor((this.max * (p - db.y - db.height)) / (this.amount() - this.bundle.height))
                                                    : Math.floor((this.max * (p - db.x - db.width )) / (this.amount() - this.bundle.width));
            };

            this.value2pixel = function(){
                var db = this.decBt, bn = this.bundle, off = this.position.offset;
                return (this.orient === &quot;vertical&quot;) ? db.y + db.height +  Math.floor(((this.amount() - bn.height) * off) / this.max)
                                                    : db.x + db.width  +  Math.floor(((this.amount() - bn.width) * off) / this.max);
            };


            /**
             * Define composite component catch input method
             * @param  {zebkit.ui.Panel} child a children component
             * @return {Boolean} true if the given children component has to be input events transparent
             * @method catchInput
             */
            this.catchInput = function (child){
                return child === this.bundle || (this.bundle.kids.length &gt; 0 &amp;&amp;
                                                 zebkit.layout.isAncestorOf(this.bundle, child));
            };

            this.posChanged = function(target, po, pl, pc) {
                if (this.bundle !== null) {
                    if (this.orient === &quot;horizontal&quot;) {
                        this.bundle.setLocation(this.value2pixel(), this.getTop());
                    } else {
                        this.bundle.setLocation(this.getLeft(), this.value2pixel());
                    }
                }
            };

            this.getLines     = function ()     { return this.max; };
            this.getLineSize  = function (line) { return 1; };
            this.getMaxOffset = function ()     { return this.max; };

            this.fired = function(src){
                this.position.setOffset(this.position.offset + ((src === this.incBt) ? this.unitIncrement
                                                                                     : -this.unitIncrement));
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (Number.MAX_VALUE !== this.startDragLoc) {
                    this.position.setOffset(this.pixel2value(this.bundleLoc -
                                                             this.startDragLoc +
                                                             ((this.orient === &quot;horizontal&quot;) ? e.x : e.y)));
                }
            };

            /**
             * Define pointer drag started  events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function (e){
                if (this.isDragable === true &amp;&amp; this.isInBundle(e.x, e.y)) {
                    this.startDragLoc = this.orient === &quot;horizontal&quot; ? e.x : e.y;
                    this.bundleLoc    = this.orient === &quot;horizontal&quot; ? this.bundle.x : this.bundle.y;
                }
            };

            /**
             * Define pointer drag ended events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                this.startDragLoc = Number.MAX_VALUE;
            };

            /**
             * Define pointer clicked events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            this.pointerClicked = function (e){
                if (this.isInBundle(e.x, e.y) === false &amp;&amp; e.isAction()){
                    var d = this.pageIncrement;
                    if (this.orient === &quot;vertical&quot;){
                        if (e.y &lt; (this.bundle !== null ? this.bundle.y : Math.floor(this.height / 2))) {
                            d =  -d;
                        }
                    } else {
                        if (e.x &lt; (this.bundle !== null ? this.bundle.x : Math.floor(this.width / 2))) {
                            d =  -d;
                        }
                    }
                    this.position.setOffset(this.position.offset + d);
                }
            };

            this.calcPreferredSize = function (target){
                var ps1 = pkg.$getPS(this.incBt),
                    ps2 = pkg.$getPS(this.decBt),
                    ps3 = pkg.$getPS(this.bundle);

                if (this.orient === &quot;horizontal&quot;){
                    ps1.width += (ps2.width + ps3.width);
                    ps1.height = Math.max((ps1.height &gt; ps2.height ? ps1.height : ps2.height), ps3.height);
                } else {
                    ps1.height += (ps2.height + ps3.height);
                    ps1.width = Math.max((ps1.width &gt; ps2.width ? ps1.width : ps2.width), ps3.width);
                }
                return ps1;
            };

            this.doLayout = function(target){
                var right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    ew     = this.width - left - right,
                    eh     = this.height - top - bottom,
                    b      = (this.orient === &quot;horizontal&quot;),
                    ps1    = pkg.$getPS(this.decBt),
                    ps2    = pkg.$getPS(this.incBt),
                    minbs  = this.clazz.MIN_BUNDLE_SIZE;

                this.decBt.setBounds(left, top, b ? ps1.width
                                                  : ew,
                                                b ? eh
                                                  : ps1.height);


                this.incBt.setBounds(b ? this.width - right - ps2.width : left,
                                     b ? top : this.height - bottom - ps2.height,
                                     b ? ps2.width : ew,
                                     b ? eh : ps2.height);

                if (this.bundle !== null &amp;&amp; this.bundle.isVisible === true){
                    var am = this.amount();
                    if (am &gt; minbs) {
                        var bsize = Math.max(Math.min(Math.floor((this.extra * am) / this.max), am - minbs), minbs);
                        this.bundle.setBounds(b ? this.value2pixel() : left,
                                              b ? top   : this.value2pixel(),
                                              b ? bsize : ew,
                                              b ? eh    : bsize);
                    } else {
                        this.bundle.setSize(0, 0);
                    }
                }
            };

            /**
             * Set the specified maximum value of the scroll bar component
             * @param {Integer} m a maximum value
             * @method setMaximum
             * @chainable
             */
            this.setMaximum = function (m){
                if (m !== this.max) {
                    this.max = m;
                    if (this.position.offset &gt; this.max) {
                        this.position.setOffset(this.max);
                    }
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the scroll bar value.
             * @param {Integer} v a scroll bar value.
             * @method setValue
             * @chainable
             */
            this.setValue = function(v){
                this.position.setOffset(v);
                return this;
            };

            this.setPosition = function(p){
                if (p !== this.position){
                    if (this.position !== null) {
                        this.position.off(this);
                    }
                    this.position = p;

                    if (this.position !== null){
                        this.position.on(this);
                        this.position.setMetric(this);
                        this.position.setOffset(0);
                    }
                }
                return this;
            };

            this.setExtraSize = function(e){
                if (e !== this.extra){
                    this.extra = e;
                    this.vrp();
                }
                return this;
            };
        },

        function kidAdded(index,ctr,lw) {
            this.$super(index, ctr, lw);

            if (&quot;center&quot; === ctr) {
                this.bundle = lw;
            } else if (&quot;bottom&quot; === ctr) {
                this.incBt = lw;
                this.incBt.on(this);
            } else if (&quot;top&quot; === ctr) {
                this.decBt = lw;
                this.decBt.on(this);
            } else {
                throw new Error(&quot;Invalid constraints : &quot; + ctr);
            }
        },

        function kidRemoved(index,lw) {
            this.$super(index, lw);
            if (lw === this.bundle) {
                this.bundle = null;
            } else if (lw === this.incBt) {
                this.incBt.off(this);
                this.incBt = null;
            } else if (lw === this.decBt) {
                this.decBt.off(this);
                this.decBt = null;
            }
        }
    ]);

    /**
     * Scroll UI panel. The component is used to manage scrolling for a children UI component
     * that occupies more space than it is available. The usage is very simple, just put an
     * component you want to scroll horizontally or/and vertically in the scroll panel:

            // scroll vertically and horizontally a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan(&quot;largePicture.jpg&quot;));

            // scroll vertically  a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan(&quot;largePicture.jpg&quot;),
                                                   &quot;vertical&quot;);

            // scroll horizontally a large picture
            var scrollPan = new zebkit.ui.ScrollPan(new zebkit.ui.ImagePan(&quot;largePicture.jpg&quot;),
                                                   &quot;horizontal&quot;);



     * @param {zebkit.ui.Panel} [c] an UI component that has to be placed into scroll panel
     * @param {String} [scrolls] a scroll bars that have to be shown. Use &quot;vertical&quot;, &quot;horizontal&quot;
     * or &quot;both&quot; string value to control scroll bars visibility. By default the value is &quot;both&quot;
     * @constructor
     * @param {Boolean} [autoHide] a boolean value that says if the scrollbars have to work in
     * auto hide mode. Pass true to switch scrollbars in auto hide mode. By default the value is
     * false
     * @class zebkit.ui.ScrollPan
     * @extends zebkit.ui.Panel
     */
    pkg.ScrollPan = Class(pkg.Panel, [
        function (c, scrolls, autoHide) {
            if (arguments.length &lt; 2)  {
                scrolls = &quot;both&quot;;
            }

            this.$isPosChangedLocked = false;
            this.$super();

            if (arguments.length &gt; 0 &amp;&amp; c !== null) {
                this.add(&quot;center&quot;, c);
            }

            if (arguments.length &lt; 2 || scrolls === &quot;both&quot; || scrolls === &quot;horizontal&quot;) {
                this.add(&quot;bottom&quot;, new pkg.Scroll(&quot;horizontal&quot;));
            }

            if (arguments.length &lt; 2 || scrolls === &quot;both&quot; || scrolls === &quot;vertical&quot;) {
                this.add(&quot;right&quot;, new pkg.Scroll(&quot;vertical&quot;));
            }

            if (arguments.length &gt; 2) {
                this.setAutoHide(autoHide);
            }
        },

        function $clazz() {
            this.ContentPanLayout = Class(zebkit.layout.Layout, [
                function $prototype() {
                    this.calcPreferredSize = function(t) {
                        return t.kids[0].getPreferredSize();
                    };

                    this.doLayout = function(t) {
                        var kid = t.kids[0];
                        if (kid.constraints === &quot;stretch&quot;) {
                            var ps = kid.getPreferredSize(),
                                w  = t.parent.hBar !== null ? ps.width : t.width,
                                h  = t.parent.vBar !== null ? ps.height : t.height;
                            kid.setSize(w, h);
                        } else {
                            kid.toPreferredSize();
                        }
                    };
                }
            ]);

            var SM = this.ContentPanScrollManager = Class(pkg.ScrollManager, [
                function $prototype() {
                    this.getSX = function() {
                        return this.target.x;
                    };

                    this.getSY = function() {
                        return this.target.y;
                    };

                    this.scrollStateUpdated = function(sx,sy,psx,psy) {
                        this.target.setLocation(sx, sy);
                    };
                }
            ]);

            var contentPanLayout = new this.ContentPanLayout();
            this.ContentPan = Class(pkg.Panel, [
                function(c) {
                    this.$super(contentPanLayout);
                    this.scrollManager = new SM(c);
                    this.add(c);
                }
            ]);
        },

        function $prototype() {
            /**
             * Horizontal scroll bar component
             * @attribute hBar
             * @type {zebkit.ui.Scroll}
             * @readOnly
             */
            this.hBar = null;

            /**
             * Vertical scroll bar component
             * @attribute vBar
             * @type {zebkit.ui.Scroll}
             * @readOnly
             */
            this.vBar = null;

            /**
             * Scrollable target component
             * @attribute scrollObj
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.scrollObj = null;

            /**
             * Indicate if the scroll bars should be hidden
             * when they are not active
             * @attribute autoHide
             * @type {Boolean}
             * @readOnly
             */
            this.autoHide  = false;

            this.$interval = 0;

            /**
             * Set the given auto hide state.
             * @param  {Boolean} b an auto hide state.
             * @method setAutoHide
             * @chainable
             */
            this.setAutoHide = function(b) {
                if (this.autoHide !== b) {
                    this.autoHide = b;
                    if (this.hBar !== null) {
                        if (this.hBar.incBt !== null) {
                            this.hBar.incBt.setVisible(b === false);
                        }

                        if (this.hBar.decBt !== null) {
                            this.hBar.decBt.setVisible(b === false);
                        }

                        if (b === true) {
                            this.hBar.toBack();
                        } else {
                            this.hBar.toFront();
                        }
                    }

                    if (this.vBar !== null) {
                        if (this.vBar.incBt !== null) {
                            this.vBar.incBt.setVisible(b === false);
                        }

                        if (this.vBar.decBt !== null) {
                            this.vBar.decBt.setVisible(b === false);
                        }

                        if (b === true) {
                            this.vBar.toBack();
                        } else {
                            this.vBar.toFront();
                        }
                    }

                    if (this.$interval !== 0) {
                        zebkit.environment.clearInterval(this.$interval);
                        this.$interval = 0;
                    }

                    this.vrp();
                }
                return this;
            };

            /**
             * Scroll horizontally and vertically to the given positions
             * @param  {Integer} sx a horizontal position
             * @param  {Integer} sy a vertical position
             * @method scrollTo
             */
            this.scrollTo = function(sx, sy) {
                this.scrollObj.scrollManager.scrollTo(sx, sy);
            };

            /**
             * Scroll horizontally
             * @param  {Integer} sx a position
             * @method scrollXTo
             */
            this.scrollXTo = function(sx) {
                this.scrollObj.scrollManager.scrollXTo(sx);
            };

            /**
             * Scroll vertically
             * @param  {Integer} sy a position
             * @method scrollYTo
             */
            this.scrollYTo = function(sx, sy) {
                this.scrollObj.scrollManager.scrollYTo(sy);
            };

            this.doScroll = function(dx, dy, source) {
                var b = false, v = 0;

                if (dy !== 0 &amp;&amp; this.vBar !== null &amp;&amp; this.vBar.isVisible === true) {
                    v =  this.vBar.position.offset + dy;
                    if (v &gt;= 0) {
                        this.vBar.position.setOffset(v);
                    } else {
                        this.vBar.position.setOffset(0);
                    }
                    b = true;
                }

                if (dx !== 0 &amp;&amp; this.hBar !== null &amp;&amp; this.hBar.isVisible === true) {
                    v =  this.hBar.position.offset + dx;
                    if (v &gt;= 0) {
                        this.hBar.position.setOffset(v);
                    } else  {
                        this.hBar.position.setOffset(0);
                    }
                    b = true;
                }

                return b;
            };

            /**
             * Scroll manager listener method that is called every time
             * a target component has been scrolled
             * @param  {Integer} psx previous scroll x location
             * @param  {Integer} psy previous scroll y location
             * @method  scrolled
             */
            this.scrolled = function (psx,psy){
                this.validate();
                try {
                    this.$isPosChangedLocked = true;

                    if (this.hBar !== null) {
                        this.hBar.position.setOffset( -this.scrollObj.scrollManager.getSX());
                    }

                    if (this.vBar !== null) {
                        this.vBar.position.setOffset( -this.scrollObj.scrollManager.getSY());
                    }

                    if (this.scrollObj.scrollManager == null) {
                        this.invalidate();
                    }

                    this.$isPosChangedLocked = false;
                } catch(e) { this.$isPosChangedLocked = false; throw e; }
            };

            this.calcPreferredSize = function (target){
                return pkg.$getPS(this.scrollObj);
            };

            this.doLayout = function (target){
                var sman   = (this.scrollObj === null) ? null : this.scrollObj.scrollManager,
                    right  = this.getRight(),
                    top    = this.getTop(),
                    bottom = this.getBottom(),
                    left   = this.getLeft(),
                    ww     = this.width  - left - right,  maxH = ww,
                    hh     = this.height - top  - bottom, maxV = hh,
                    so     = this.scrollObj.getPreferredSize(),
                    vps    = this.vBar === null ? { width:0, height:0 } : this.vBar.getPreferredSize(),
                    hps    = this.hBar === null ? { width:0, height:0 } : this.hBar.getPreferredSize();

                // compensate scrolled vertical size by reduction of horizontal bar height if necessary
                // autoHidded scrollbars don&#x27;t have an influence to layout
                if (this.hBar !== null &amp;&amp; this.autoHide === false &amp;&amp;
                      (so.width  &gt; ww ||
                      (so.height &gt; hh &amp;&amp; so.width &gt; (ww - vps.width))))
                {
                    maxV -= hps.height;
                }
                maxV = so.height &gt; maxV ? (so.height - maxV) :  -1;

                // compensate scrolled horizontal size by reduction of vertical bar width if necessary
                // autoHidded scrollbars don&#x27;t have an influence to layout
                if (this.vBar !== null &amp;&amp; this.autoHide === false &amp;&amp;
                      (so.height &gt; hh ||
                      (so.width &gt; ww &amp;&amp; so.height &gt; (hh - hps.height))))
                {
                    maxH -= vps.width;
                }
                maxH = so.width &gt; maxH ? (so.width - maxH) :  -1;

                var sy = sman.getSY(), sx = sman.getSX();
                if (this.vBar !== null) {
                    if (maxV &lt; 0) {
                        if (this.vBar.isVisible === true){
                            this.vBar.setVisible(false);
                            sman.scrollTo(sx, 0);
                            this.vBar.position.setOffset(0);
                        }
                        sy = 0;
                    } else {
                        this.vBar.setVisible(true);
                    }
                }

                if (this.hBar !== null){
                    if (maxH &lt; 0){
                        if (this.hBar.isVisible === true){
                            this.hBar.setVisible(false);
                            sman.scrollTo(0, sy);
                            this.hBar.position.setOffset(0);
                        }
                    } else {
                        this.hBar.setVisible(true);
                    }
                }

                if (this.scrollObj.isVisible === true) {
                    this.scrollObj.setBounds(left, top,
                                             ww - (this.autoHide === false &amp;&amp; this.vBar !== null &amp;&amp; this.vBar.isVisible === true ? vps.width  : 0),
                                             hh - (this.autoHide === false &amp;&amp; this.hBar !== null &amp;&amp; this.hBar.isVisible === true ? hps.height : 0));
                }

                if (this.$interval === 0 &amp;&amp; this.autoHide === true) {
                    hps.height = vps.width = 0;
                }

                if (this.hBar !== null &amp;&amp; this.hBar.isVisible === true){
                    this.hBar.setBounds(left, this.height - bottom - hps.height,
                                        ww - (this.vBar !== null &amp;&amp; this.vBar.isVisible === true ? vps.width : 0),
                                        hps.height);
                    this.hBar.setMaximum(maxH);
                }

                if (this.vBar !== null &amp;&amp; this.vBar.isVisible === true){
                    this.vBar.setBounds(this.width - right - vps.width, top,
                                        vps.width,
                                        hh -  (this.hBar !== null &amp;&amp; this.hBar.isVisible === true ? hps.height : 0));
                    this.vBar.setMaximum(maxV);
                }
            };

            this.posChanged = function (target,prevOffset,prevLine,prevCol){
                if (this.$isPosChangedLocked === false) {
                    //  show if necessary hidden scroll bar(s)
                    if (this.autoHide === true) {
                        // make sure autohide thread has not been initiated and make sure it makes sense
                        // to initiate the thread (one of the scroll bar has to be visible)
                        if (this.$interval === 0 &amp;&amp; ((this.vBar !== null &amp;&amp; this.vBar.isVisible === true) ||
                                                     (this.hBar !== null &amp;&amp; this.hBar.isVisible === true)    ))
                        {
                            var $this = this;

                            // show scroll bar(s)
                            if (this.vBar !== null) {
                                this.vBar.toFront();
                            }

                            if (this.hBar !== null) {
                                this.hBar.toFront();
                            }

                            this.vrp();

                            // pointer move should keep scroll bars visible and pointer entered exited
                            // events have to be caught to track if pointer cursor is on a scroll
                            // bar. add temporary listeners
                            $this.$hiddingCounter = 2;
                            $this.$targetBar      = null;
                            var listener = pkg.events.on({
                                pointerMoved: function(e) {
                                    $this.$hiddingCounter = 1;
                                },

                                pointerExited: function(e) {
                                    $this.$targetBar = null;
                                },

                                pointerEntered: function(e) {
                                    if (e.source === $this.vBar) {
                                        $this.$targetBar = $this.vBar;
                                    } else {
                                        if (e.source === $this.hBar) {
                                            $this.$targetBar = $this.hBar;
                                            return;
                                        }

                                        $this.$targetBar = null;
                                    }
                                }
                            });

                            // start thread to autohide shown scroll bar(s)
                            this.$interval = zebkit.environment.setInterval(function() {
                                if ($this.$hiddingCounter-- === 0 &amp;&amp; $this.$targetBar === null) {
                                    zebkit.environment.clearInterval($this.$interval);
                                    $this.$interval = 0;
                                    pkg.events.off(listener);
                                    $this.doLayout();
                                }
                            }, 500);
                        }
                    }

                    if (this.vBar !== null &amp;&amp; this.vBar.position === target) {
                        this.scrollObj.scrollManager.scrollYTo(-this.vBar.position.offset);
                    } else if (this.hBar !== null &amp;&amp; this.hBar.position === target) {
                        this.scrollObj.scrollManager.scrollXTo(-this.hBar.position.offset);
                    }
                }
            };

            this.setIncrements = function (hUnit,hPage,vUnit,vPage) {
                if (this.hBar !== null){
                    if (hUnit !==  -1) {
                        this.hBar.unitIncrement = hUnit;
                    }

                    if (hPage !==  -1) {
                        this.hBar.pageIncrement = hPage;
                    }
                }

                if (this.vBar !== null){
                    if (vUnit !==  -1) {
                        this.vBar.unitIncrement = vUnit;
                    }
                    if (vPage !==  -1) {
                        this.vBar.pageIncrement = vPage;
                    }
                }
                return this;
            };
        },

        function insert(i,ctr,c) {
            if (&quot;center&quot; === ctr) {
                if (c.scrollManager == null) {
                    c = new this.clazz.ContentPan(c);
                }

                this.scrollObj = c;
                c.scrollManager.on(this);
            } else {
                if (&quot;bottom&quot; === ctr || &quot;top&quot; === ctr){
                    this.hBar = c;
                } else if (&quot;left&quot; === ctr || &quot;right&quot; === ctr) {
                    this.vBar = c;
                } else {
                    throw new Error(&quot;Invalid constraints&quot;);
                }

                // valid for scroll bar only
                if (c.incBt !== null) {
                    c.incBt.setVisible(!this.autoHide);
                }
                if (c.decBt !== null) {
                    c.decBt.setVisible(!this.autoHide);
                }
                c.position.on(this);
            }

            return this.$super(i, ctr, c);
        },

        function kidRemoved(index, comp){
            this.$super(index, comp);
            if (comp === this.scrollObj){
                this.scrollObj.scrollManager.off(this);
                this.scrollObj = null;
            } else if (comp === this.hBar) {
                this.hBar.position.off(this);
                this.hBar = null;
            } else if (comp === this.vBar) {
                this.vBar.position.off(this);
                this.vBar = null;
            }
        }
    ]);

    /**
     * Mobile scroll manager class. Implements inertial scrolling in zebkit mobile application.
     * @class zebkit.ui.MobileScrollMan
     * @extends zebkit.ui.event.Manager
     * @constructor
     */
    pkg.MobileScrollMan = Class(zebkit.ui.event.Manager, [
        function $prototype() {
            this.$timer = this.identifier = this.target = null;

            /**
             * Define pointer drag started events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e) {
                if (e.touchCounter === 1 &amp;&amp; e.pointerType === &quot;touch&quot;) {
                    this.$identifier = e.identifier;
                    this.$target     = e.source;

                    // detect scrollable component
                    while (this.$target !== null &amp;&amp; typeof this.$target.doScroll === &#x27;undefined&#x27;) {
                        this.$target = this.$target.parent;
                    }

                    if (this.$target !== null &amp;&amp; typeof this.$target.pointerDragged !== &#x27;undefined&#x27;) {
                         this.$target = null;
                    }
                }
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e) {
                if (e.touchCounter   === 1            &amp;&amp;
                    this.$target    !==  null         &amp;&amp;
                    this.$identifier === e.identifier &amp;&amp;
                    e.direction     !==  null            )
                {
                    this.$target.doScroll(-e.dx, -e.dy, &quot;touch&quot;);
                }
            };

            this.$taskMethod = function() {
                var bar = this.$target.vBar,
                    o   = bar.position.offset;

                // this is linear function with angel 42. every next value will
                // be slightly lower prev. one. theoretically angel 45 should
                // bring to infinite scrolling :)
                this.$dt = Math.tan(42 * Math.PI / 180) * this.$dt;
                bar.position.setOffset(o - Math.round(this.$dt));
                this.$counter++;

                if (o === bar.position.offset) {
                    this.$target = null;
                    zebkit.environment.clearInterval(this.$timer);
                    this.$timer = null;
                }
            };

            /**
             * Define pointer drag ended events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                if (this.$target !== null &amp;&amp;
                    this.$timer  === null  &amp;&amp;
                    this.$identifier === e.identifier &amp;&amp;
                    (e.direction === &quot;bottom&quot; || e.direction === &quot;top&quot;) &amp;&amp;
                    this.$target.vBar !== null &amp;&amp;
                    this.$target.vBar.isVisible &amp;&amp;
                    e.dy !== 0)
                {
                    this.$dt = 2 * e.dy;
                    this.$counter = 0;
                    var $this = this;
                    this.$timer = zebkit.environment.setInterval(function() {
                        $this.$taskMethod($this);
                    }, 50);
                }
            };

            /**
             * Define pointer pressed events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e) {
                if (this.$timer !== null) {
                    zebkit.environment.clearInterval(this.$timer);
                    this.$timer = null;
                }
                this.$target = null;
            };
        }
    ]);


    /**
     * Simple ruler panel class. The ruler can render minimal and maximal values of the
     * specified range.
     * @param  {String} [o] ruler orientation. Use &quot;horizontal&quot; or &quot;vertical&quot; as the
     * argument value
     * @constructor
     * @class zebkit.ui.RulerPan
     * @extends zebkit.ui.Panel
     */
    pkg.RulerPan = Class(pkg.Panel, [
        function(o) {
            this.$super();
            this.setLabelsRender(new this.clazz.PercentageLabels());
            if (arguments.length &gt; 0) {
                this.setOrientation(o);
            }
        },

        function $clazz() {
            // TODO: complete the class
            this.LabelsHighlighter = zebkit.Interface([
                function paintLabel(g, x, y, w, h, v, value) {
                    this.$super(g, x, y, w, h, v, value);

                    if (typeof this.$labelsInfo === &#x27;undefined&#x27;) {
                        this.$labelsInfo = [];
                    }

                    var found = false;
                    for (var i = 0; i &lt; this.$labelsInfo.length; i++) {
                        var info = this.$labelsInfo[i];
                        if (info.value === value) {
                            if (info.x !== x || info.y !== y || info.w !== w || info.h !== h) {
                                info.x = x;
                                info.y = y;
                                info.w = w;
                                info.h = h;
                            }
                            found = true;
                            break;
                        }
                    }

                    if (found === false) {
                        this.$labelsInfo.push({
                            value : value,
                            x     : x,
                            y     : y,
                            w     : w,
                            h     : h
                        });
                    }
                },

                function invalidate(p) {
                    this.$labelsInfo = [];
                    this.$selectedLabel = null;
                    this.$super();
                },

                function setParent(p) {
                    if (p === null &amp;&amp; this.$labelsInfo) {
                        this.$labelsInfo = [];
                        this.$selectedLabel = null;
                    }
                    return this.$super(p);
                },

                function paint(g) {
                    if (this.highlighterView !== null &amp;&amp; this.$selectedLabel !== null) {
                        this.highlighterView.paint(g, this.$selectedLabel.x,
                                                       this.$selectedLabel.y,
                                                       this.$selectedLabel.w,
                                                       this.$selectedLabel.h,
                                                    this);
                    }

                    this.$super(g);
                },

                function $prototype() {
                    this.$selectedLabel = null;
                    this.highlighterView = zebkit.draw.$view(&quot;yellow&quot;);

                    this.getLabelAt = function(x, y) {
                        if (typeof this.$labelsInfo !== &#x27;undefined&#x27;) {
                            for (var i = 0; i &lt; this.$labelsInfo.length; i++) {
                                var inf = this.$labelsInfo[i];
                                if (x &gt;= inf.x &amp;&amp; x &lt; inf.w + inf.x &amp;&amp; y &gt;= inf.y &amp;&amp; y &lt; inf.h + inf.y) {
                                    return inf;
                                }
                            }
                        }

                        return null;
                    },

                    this.pointerMoved = function(e) {
                        if (this.highlighterView !== null) {
                            var label = this.getLabelAt(e.x, e.y);
                            if (this.$selectedLabel !== label) {
                                this.$selectedLabel = label;
                                this.repaint();
                            }
                        }
                    };

                    this.pointerExited = function(e) {
                        if (this.highlighterView !== null) {
                            var label = this.getLabelAt(e.x, e.y);
                            if (this.$selectedLabel !== null) {
                                this.$selectedLabel = null;
                                this.repaint();
                            }
                        }
                    };

                    this.seHighlighterView = function(v) {
                        if (this.highlighterView !== v) {
                            this.highlighterView = v;
                            this.repaint();
                        }
                        return this;
                    };

                    this.pointerClicked = function(e) {
                        var label = this.getLabelAt(e.x, e.y);
                        if (label !== null) {
                            this.parent.setValue(label.value);
                        }
                    };
                }
            ]);

            /**
             * Numeric label renderer factory.
             * @param  {Integer} [numPrecision] precision of displayed numbers.
             * @class zebkit.ui.RulePan.NumLabels
             * @extends zebkit.draw.BaseViewProvider
             */
            this.NumLabels = Class(zebkit.draw.BaseViewProvider, [
                function(numPrecision) {
                    this.$super(new zebkit.draw.BoldTextRender(&quot;&quot;));
                    if (arguments.length &gt; 0) {
                        this.numPrecision = numPrecision;
                    }
                },

                function $prototype() {
                    /**
                     * Number precision.
                     * @attribute numPrecision
                     * @type {Integer}
                     * @readOnly
                     * @default  -1
                     */
                    this.numPrecision = -1;
                },

                /**
                 * Get a view to render the given number.
                 * @param  {zebkit.ui.RulerPan} t a target ruler panel.
                 * @param  {Number} v a number to be rendered
                 * @return {zebkit.draw.View}  a view to render the number
                 * @method getView
                 */
                function getView(t, v) {
                    if (v !== null &amp;&amp; typeof v !== &#x27;undefined&#x27; &amp;&amp; this.numPrecision !== -1 &amp;&amp; zebkit.isNumber(v)) {
                        v = v.toFixed(this.numPrecision);
                    }
                    return this.$super(t, v);
                },

                function $clazz() {
                    this.color = &quot;gray&quot;;
                    this.font  = new zebkit.Font(&quot;Arial&quot;, &quot;bold&quot;, 12);
                }
            ]);

            /**
             * Percentage label renderer factory.
             * @param  {Integer} [numPrecision] precision of displayed numbers.
             * @class zebkit.ui.RulePan.PercentageLabels
             * @extends zebkit.ui.RulePan.NumLabels
             */
            this.PercentageLabels = Class(this.NumLabels, [
                function(numPrecision) {
                    if (arguments.length === 0) {
                        numPrecision = 0;
                    }
                    this.$super(numPrecision);
                },

                function getView(t, v) {
                    var min = t.getMin(),
                        max = t.getMax();

                    v = ((v - min) * 100) / (max - min);
                    if (this.numPrecision !== -1) {
                        v = v.toFixed(this.numPrecision);
                    }

                    return this.$super(t, v + &quot;%&quot;);
                }
            ]);
        },

        /**
         * @for zebkit.ui.RulerPan
         */
        function $prototype() {
            /**
             * Gap between stroke and labels
             * @attribute gap
             * @type {Integer}
             * @readOnly
             * @default 2
             */
            this.gap = 2;

            /**
             * Stroke color.
             * @attribute color
             * @type {String}
             * @readOnly
             * @default &quot;gray&quot;
             */
            this.color = &quot;gray&quot;;

            /**
             * Stroke line width
             * @attribute lineWidth
             * @type {Integer}
             * @default 1
             * @readOnly
             */
            this.lineWidth  = 1;

            /**
             * Stroke line size
             * @attribute strokeSize
             * @type {Integer}
             * @default 4
             * @readOnly
             */
            this.strokeSize = 4;

            /**
             * Ruler orientation (&quot;horizontal&quot; or &quot;vertical&quot;).
             * @attribute orient
             * @type {String}
             * @readOnly
             * @default &quot;horizontal&quot;
             */
            this.orient = &quot;horizontal&quot;;

            /**
             * Ruler labels alignment
             * @type {String}
             * @attribute labelsAlignment
             * @default &quot;normal&quot;
             * @readOnly
             */
            this.labelsAlignment = &quot;normal&quot;; // &quot;invert&quot;

            /**
             * Ruler labels provider
             * @type {zebkit.draw.BaseViewProvider}
             * @attribute provider
             * @readOnly
             * @protected
             */
            this.provider = null;

            /**
             * Indicates if labels have to be rendered
             * @attribute showLabels
             * @type {Boolean}
             * @default true
             * @readOnly
             */
            this.showLabels = true;

            /**
             * Indicate if stroke has to be rendered
             * @type {Boolean}
             * @attribute showStrokes
             * @readOnly
             * @default true
             */
            this.showStrokes = true;

            this.$min    = 0;
            this.$max    = 100;

            this.$minGap = this.$maxGap = 0;
            this.$psW    = this.$psH = 0;
            this.$maxLabSize = 0;

            /**
             * Show ruler labels with percentage.
             * @param  {Integer} [precision] a precision
             * @chainable
             * @method showPercentage
             */
            this.showPercentage = function(precision) {
                this.setLabelsRender(new this.clazz.PercentageLabels(arguments.length &gt; 0 ? precision
                                                                                          : 0));
                return this;
            };

            /**
             * Show ruler labels with number.
             * @param  {Integer} [precision] a precision
             * @chainable
             * @method showNumbers
             */
            this.showNumbers = function(precision) {
                this.setLabelsRender(new this.clazz.NumLabels(arguments.length &gt; 0 ? precision : 0));
                return this;
            };

            /**
             * Set the ruler color.
             * @param {String} c a color
             * @method setColor
             * @chainable
             */
            this.setColor = function(c) {
                if (c !== this.color) {
                    this.color = c;
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the ruler gap between stroke and labels.
             * @param {Integer} gap a gap
             * @method setGap
             * @chainable
             */
            this.setGap = function(gap) {
                if (this.gap !== gap) {
                    this.gap = gap;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set visibility of labels
             * @param {Boolean} b a boolean value that indicates if the
             * labels has to be shown
             * @method setShowLabels
             * @chainable
             */
            this.setShowLabels = function(b) {
                if (this.showLabels !== b) {
                    this.showLabels = b;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set visibility of strokes
             * @param {Boolean} b a boolean value that indicates if the
             * strokes have to be shown
             * @method setShowStrokes
             * @chainable
             */
            this.setShowStrokes = function(b) {
                if (this.showStrokes !== b) {
                    this.showStrokes = b;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the labels font
             * @param {String|zebkit.Font} font a font of labels
             * @method setLabelsFont
             * @chainable
             */
            this.setLabelsFont = function() {
                if (this.provider !== null) {
                    this.provider.setFont.apply(this.provider,
                                                arguments);
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the labels color
             * @param {String} color a color of labels
             * @method setLabelsColor
             * @chainable
             */
            this.setLabelsColor = function() {
                if (this.provider !== null) {
                    this.provider.setColor.apply(this.provider,
                                                 arguments);
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the stroke size.
             * @param {Integer} strokeSize a stroke size
             * @method setStrokeSize
             * @chainable
             */
            this.setStrokeSize = function(strokeSize) {
                if (this.strokeSize !== strokeSize) {
                    this.strokeSize = strokeSize;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the labels render
             * @param {zebkit.draw.BaseViewProvider} r labels render
             * @method setLabelsRender
             * @chainable
             */
            this.setLabelsRender = function(p) {
                if (this.provider !== p) {
                    this.provider = p;
                    if (this.showLabels === true) {
                        this.vrp();
                    }
                }
                return this;
            };

            /**
             * Set the ruler labels alignment. Label alignment specifies a side the labels has
             * to be placed relatively stroke.
             * @param {String} a labels alignment. The value can be &quot;normal&quot; or &quot;invert&quot;
             * @method setLabelsAlignment
             * @chainable
             */
            this.setLabelsAlignment = function(a) {
                if (this.labelsAlignment !== a) {
                    zebkit.util.$validateValue(a, &quot;normal&quot;, &quot;invert&quot;);
                    this.labelsAlignment = a;
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the ruler range.
             * @param {Number} min a minimal value of the range
             * @param {Number} max a maximal value of the range
             * @method setRange
             * @chainable
             */
            this.setRange = function(min, max) {
                if (min &gt;= max) {
                    throw new Error(&quot;Invalid range [&quot; + min + &quot;,&quot; + max + &quot;]&quot;);
                }

                if (this.$min !== min || this.$max !== max) {
                    this.$min = min;
                    this.$max = max;
                    this.vrp();
                }
                return this;
            };

            /**
             * Get the ruler effective size. The size includes only pixels that are
             * used to be transformed into range values.
             * @return {Integer} a ruler size
             * @protected
             * @method $getRulerSize
             */
            this.$getRulerSize = function() {
                var s = (this.orient === &quot;horizontal&quot; ? this.width  - this.getLeft() - this.getRight()
                                                      : this.height - this.getTop()  - this.getBottom());
                return s - this.$minGap - this.$maxGap;
            };

            /**
             * Get a minimal value in the ruler values range
             * @return {Number} a minimal range value
             * @method getMin
             */
            this.getMin = function() {
                return this.$min;
            };

            /**
             * Get a maximal value in the ruler values range
             * @return {Number} a maximal range value
             * @method getMax
             */
            this.getMax = function() {
                return this.$max;
            };

            /**
             * Project the given range value to appropriate ruler component coordinate
             * @param  {Number} v a range value
             * @return {Integer} coordinate
             * @method toLocation
             */
            this.toLocation = function(v) {
                var max = this.getMax(),
                    min = this.getMin(),
                    xy  = Math.floor((this.$getRulerSize() * (v - min)) / (max - min));

                return  (this.orient === &quot;vertical&quot;) ? this.height - this.getBottom() - this.$minGap - xy
                                                     : this.getLeft() + this.$minGap + xy;
            };

            /**
             * Project the given ruler component coordinate to a range value.
             * @param  {Integer} xy a x or y (depending on the ruler orientation) coordinate
             * @return {Number} a range value
             * @method toValue
             */
            this.toValue = function(xy) {
                var min = this.getMin(),
                    max = this.getMax(),
                    sl  = (this.orient === &quot;horizontal&quot;) ? this.getLeft() + this.$minGap
                                                         : this.getTop()  + this.$minGap,
                    ss = this.$getRulerSize();

                if (this.orient === &quot;vertical&quot;) {
                    xy = this.height - xy - 1;
                }

                if (xy &lt; sl) {
                    xy = sl;
                } else if (xy &gt; sl + ss) {
                    xy = sl + ss;
                }

                return min + ((max - min) * (xy - sl)) / ss;
            };

            /**
             * Set the ruler orientation
             * @param {String} o an orientation. Use &quot;horizontal&quot; or &quot;vertical&quot; values.
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, &quot;vertical&quot;, &quot;horizontal&quot;);
                    this.vrp();
                }
                return this;
            };

            this.calcPreferredSize = function() {
                return {
                    width  : this.$psW,
                    height : this.$psH
                };
            };

            this.recalc = function() {
                this.$maxLabSize = this.$psW = this.$psH = this.$maxGap = this.$minGap = 0;
                if (this.isVisible) {
                    this.recalcMetrics();
                }
            };

            /**
             * Called when the ruler requires its metric recalculation
             * @method recalcMetrics
             */
            this.recalcMetrics = function() {
                if (this.provider !== null &amp;&amp; this.showLabels === true) {
                    // TODO: pay attention since view render shares single render
                    // don&#x27;t store instance of view and then store another instance
                    // of view
                    var minView   = this.provider.getView(this, this.getMin()),
                        minViewPs = minView === null ? { width: 0, height: 0 } : minView.getPreferredSize(),
                        maxView   = this.provider.getView(this, this.getMax()),
                        maxViewPs = maxView === null ? { width: 0, height: 0 } : maxView.getPreferredSize();

                    if (this.orient === &quot;horizontal&quot;) {
                        this.$minGap = Math.round(minViewPs.width / 2);
                        this.$maxGap = Math.round(maxViewPs.width / 2);
                        this.$maxLabSize = Math.max(minViewPs.height, maxViewPs.height);
                    } else {
                        this.$maxLabSize = Math.max(minViewPs.width, maxViewPs.width);
                        this.$minGap = Math.round(minViewPs.height / 2);
                        this.$maxGap = Math.round(maxViewPs.height / 2);
                    }
                }

                if (this.orient === &quot;vertical&quot;) {
                    this.$psH = 50 * this.lineWidth  + this.$minGap + this.$maxGap,
                    this.$psW = (this.showStrokes ? this.strokeSize : 0) +
                                (this.$maxLabSize === 0 ? 0 : this.$maxLabSize + this.gap);
                } else {
                    this.$psW = 50 * this.lineWidth + this.$minGap + this.$maxGap;
                    this.$psH = (this.showStrokes ? this.strokeSize : 0) +
                                (this.$maxLabSize === 0 ? 0 : this.$maxLabSize + this.gap);
                }
            };

            //   =================================================================
            //            ^                            ^
            //            |  top                       | top
            //        . . .                        +---------+ . . .
            //       ||   ^                        | Label   |   ^
            //       ||   | strokeSize             |         |   |  $maxLabSize
            //       ||   |                        +---------+ . |
            //            ^                                      ^
            //            |  gap                        . . . . .|  gap
            //    +---------+ . . .                    ||        ^
            //    | Label   |   ^                      ||        |
            //    |         |   |  $maxLabSize         ||        | strokeSize
            //    +---------+ . ^                       . . . . .^
            //                  |  bottom                        | bottom
            // ==================================================================

            this.paint = function(g) {
                if (this.provider !== null) {
                    var min  = this.getMin(),
                        max  = this.getMax(),
                        view = null,
                        yy   = 0,
                        xx   = 0,
                        ps   = null,
                        ss   = this.showStrokes ? this.strokeSize : 0;

                    g.setColor(this.color);

                    if (this.orient === &quot;horizontal&quot;) {
                        yy   = this.getTop();
                        xx   = this.getLeft() + this.$minGap;

                        if (this.showLabels) {
                            view = this.provider.getView(this, min);
                            if (view !== null) {
                                ps = view.getPreferredSize();
                                view.paint(g,
                                           this.toLocation(min) - Math.round(ps.width / 2),
                                           this.labelsAlignment === &quot;normal&quot; ? yy + ss + this.gap
                                                                             : yy + this.$maxLabSize - ps.height,
                                           ps.width,
                                           ps.height,
                                           this);
                            }

                            view = this.provider.getView(this, max);
                            if (view !== null) {
                                ps = view.getPreferredSize();
                                view.paint(g,
                                           this.toLocation(max) - Math.round(ps.width / 2),
                                           this.labelsAlignment === &quot;normal&quot; ? yy + ss + this.gap
                                                                             : yy + this.$maxLabSize - ps.height,
                                           ps.width,
                                           ps.height,
                                           this);
                            }

                            if (this.labelsAlignment !== &quot;normal&quot;) {
                                yy += (this.$maxLabSize + this.gap);
                            }
                        }

                        g.drawLine(xx, yy, xx, yy + ss, this.lineWidth);
                        xx = this.width - this.getRight() - this.$maxGap - 1;
                        g.drawLine(xx, yy, xx, yy + ss, this.lineWidth);

                    } else {
                        yy   = this.getTop() + this.$maxGap;
                        xx   = this.getLeft();
                        if (this.showLabels) {
                            view = this.provider.getView(this, min);
                            if (view !== null) {
                                ps = view.getPreferredSize();
                                this.paintLabel(g,
                                                this.labelsAlignment === &quot;normal&quot; ? xx + this.$maxLabSize - ps.width
                                                                                  : ss + this.gap + xx,
                                                this.toLocation(min) - Math.round(ps.height / 2),
                                                ps.width, ps.height,
                                                view, min);
                            }

                            view = this.provider.getView(this, max);
                            if (view !== null) {
                                ps = view.getPreferredSize();
                                this.paintLabel(g,
                                                this.labelsAlignment === &quot;normal&quot; ? xx + this.$maxLabSize - ps.width
                                                                                  : ss + this.gap + xx,
                                                this.toLocation(max) - Math.round(ps.height / 2),
                                                ps.width,
                                                ps.height,
                                                view, max);
                            }

                            if (this.labelsAlignment === &quot;normal&quot;) {
                                xx += (this.$maxLabSize + this.gap);
                            }
                        }

                        g.drawLine(xx, yy, xx + ss, yy, this.lineWidth);
                        yy = this.height - this.getBottom() - this.$minGap - 1;
                        g.drawLine(xx, yy, xx + ss, yy, this.lineWidth);
                    }
                }
            };

            this.paintLabel = function(g, x, y, w, h, v, value) {
                if (v !== null) {
                    v.paint(g, x, y, w, h, this);
                }
            };

            this.getLabelAt = function(x, y) {
                return null;
            };
        }
    ]);

    /**
     * Pointer ruler class. The ruler uses generator class instance to get and render labels values
     * @param  {String} o an orientation.
     * @constructor
     * @class zebkit.ui.PointRulerPan
     * @extends zebkit.ui.RulerPan
     */
    pkg.PointRulerPan = Class(pkg.RulerPan, [
        function() {
            this.$supera(arguments);
            this.$generator = new this.clazz.DeltaPointsGenerator(10);
        },

        function $clazz() {
            /**
             * Basic class to implement sequence of points values
             * @class zebkit.ui.PointRulerPan.PointsGenerator
             * @constructor
             */
            this.PointsGenerator = Class([
                function $prototype() {
                    /**
                     * Generate next point value in the sequence or null if end of sequence has been reached.
                     * @param  {zebkit.ui.RulerPan} ruler a ruler
                     * @param  {Integer} index a point index
                     * @return {Number} a value for the given point with the specified index
                     */
                    this.pointValue = function(ruler, index) {
                        return null;
                    };
                }
            ]);

            /**
             * Delta point generator implementation. The generator uses fixed delta value
             * to calculate next value of the points sequence.
             * @param {Number} [delta] a delta
             * @class zebkit.ui.PointRulerPan.DeltaPointsGenerator
             * @extends zebkit.ui.PointRulerPan.PointsGenerator
             * @constructor
             */
            this.DeltaPointsGenerator = Class(this.PointsGenerator, [
                function(delta) {
                    if (arguments.length &gt; 0) {
                        this.$delta = delta;
                    }
                },

                function $prototype() {
                    /**
                     * Delta
                     * @attribute $delta
                     * @type {Number}
                     * @readOnly
                     * @protected
                     */
                    this.$delta = 0;

                    this.pointValue = function(ruler, i) {
                        if (this.$delta === 0) {
                            return null;
                        } else {
                            var v = ruler.getMin() + i * this.$delta;
                            return (v &gt; ruler.getMax()) ? null : v;
                        }
                    };
                }
            ]);
        },

        /**
         * @for zebkit.ui.PointRulerPan
         */
        function $prototype() {
            this.$generator = null;

            /**
             * Set the points values generator
             * @param {zebkit.ui.PointRulerPan.PointsGenerator} g a point generator
             * @method setPointGenerator
             */
            this.setPointGenerator = function(g) {
                if (this.$generator !== g) {
                    this.$generator = g;
                    this.vrp();
                }
                return this;
            };

            /**
             * Setup delta points generator. The generator builds points sequence basing on incrementing
             * the sequence with fixed delta number.
             * @param  {Number} delta a delta
             * @chainable
             * @method useDeltaPointsGenerator
             */
            this.useDeltaPointsGenerator = function(delta) {
                this.setPointGenerator(new this.clazz.DeltaPointsGenerator(delta));
                return this;
            };

            this.recalcMetrics = function() {
                if (this.provider !== null &amp;&amp; this.showLabels === true) {
                    var i   = 0,
                        v   = null,
                        min = this.getMin(),
                        max = this.getMax();

                    while ((v = this.$generator.pointValue(this, i++)) !== null) {
                        var view = this.provider.getView(this, v);
                        if (view !== null) {
                            var ps = view.getPreferredSize();
                            if (this.orient === &quot;horizontal&quot;) {
                                if (ps.height &gt; this.$maxLabSize) {
                                    this.$maxLabSize = ps.height;
                                }

                                if (min === v) {
                                    this.$minGap = Math.round(ps.width / 2);
                                } else if (max === v) {
                                    this.$maxGap = Math.round(ps.width / 2);
                                }

                            } else {
                                if (ps.width &gt; this.$maxLabSize) {
                                    this.$maxLabSize = ps.width;
                                }

                                if (min === v) {
                                    this.$minGap = Math.round(ps.height / 2);
                                } else if (max === v) {
                                    this.$maxGap = Math.round(ps.height / 2);
                                }
                            }
                        }
                    }
                }

                if (this.orient === &quot;vertical&quot;) {
                    this.$psH = 50 + this.$minGap + this.$maxGap,
                    this.$psW = (this.showStrokes ? this.strokeSize : 0) +
                                (this.$maxLabSize === 0 ? 0 : this.$maxLabSize + this.gap);
                } else {
                    this.$psW = 50 + this.$minGap + this.$maxGap;
                    this.$psH = (this.showStrokes ? this.strokeSize : 0) +
                                (this.$maxLabSize === 0 ? 0 : this.$maxLabSize + this.gap);
                }
            };

            this.paint = function(g) {
                if (this.$generator !== null) {
                    var y          = this.getTop(),
                        x          = this.getLeft(),
                        prevLabLoc = null,
                        prevPs     = null,
                        v          = null,
                        i          = 0,
                        j          = 0,
                        ss         = this.showStrokes ? this.strokeSize : 0;

                    g.beginPath();
                    while ((v = this.$generator.pointValue(this, i++)) !== null) {
                        var loc = this.toLocation(v);

                        if (this.provider !== null &amp;&amp; this.showLabels === true) {
                            var view     = this.provider.getView(this, v),
                                rendered = false;

                            if (view !== null) {
                                var ps = view.getPreferredSize();

                                if (this.orient === &quot;horizontal&quot;) {
                                    if (prevLabLoc === null || loc &gt; prevLabLoc + prevPs.width) {
                                        this.paintLabel(g,
                                                        loc - Math.floor(ps.width / 2),
                                                        this.labelsAlignment === &quot;normal&quot; ?  y  + ss + this.gap
                                                                                          :  y,
                                                        ps.width, ps.height,
                                                        view, v);

                                        prevLabLoc = loc;
                                        prevPs     = ps;
                                        rendered   = true;
                                    }
                                } else {
                                    if (prevLabLoc === null || Math.round(loc + ps.height/2) &lt; prevLabLoc) {
                                        prevLabLoc = loc - Math.floor(ps.height / 2);
                                        this.paintLabel(g,
                                                        this.labelsAlignment === &quot;normal&quot; ? x  + ss + this.gap
                                                                                          : x,
                                                        prevLabLoc,
                                                        ps.width,
                                                        ps.height,
                                                        view, v);
                                        rendered = true;
                                    }
                                }
                            }

                            if (rendered === true &amp;&amp; this.showStrokes) {
                                if (this.orient === &quot;horizontal&quot;) {
                                    if (this.labelsAlignment === &quot;normal&quot;) {
                                        g.moveTo(loc + 0.5, y);
                                        g.lineTo(loc + 0.5, y + this.strokeSize);
                                    } else {
                                        g.moveTo(loc + 0.5, y + this.$maxLabSize + this.gap);
                                        g.lineTo(loc + 0.5, y + this.$maxLabSize + this.gap + this.strokeSize);
                                    }
                                } else {
                                    if (this.labelsAlignment === &quot;normal&quot;) {
                                        g.moveTo(x, loc + 0.5);
                                        g.lineTo(x + this.strokeSize, loc + 0.5);
                                    } else {
                                        g.moveTo(x + this.$maxLabSize + this.gap, loc + 0.5);
                                        g.lineTo(x + this.$maxLabSize + this.gap + this.strokeSize, loc + 0.5);
                                    }
                                }
                            }

                        } else {
                            if (this.showStrokes) {
                                if (this.orient === &quot;horizontal&quot;) {
                                    if (this.labelsAlignment === &quot;normal&quot;) {
                                        g.moveTo(loc + 0.5, y);
                                        g.lineTo(loc + 0.5, y + this.strokeSize);
                                    } else {
                                        g.moveTo(loc + 0.5, y + this.$maxLabSize + this.gap);
                                        g.lineTo(loc + 0.5, y + this.$maxLabSize + this.gap + this.strokeSize);
                                    }
                                } else {
                                    if (this.labelsAlignment === &quot;normal&quot;) {
                                        g.moveTo(x, loc + 0.5);
                                        g.lineTo(x + this.strokeSize, loc + 0.5);
                                    } else {
                                        g.moveTo(x + this.$maxLabSize + this.gap, loc + 0.5);
                                        g.lineTo(x + this.$maxLabSize + this.gap + this.strokeSize, loc + 0.5);
                                    }
                                }
                            }
                        }
                    }

                    g.lineWidth = this.lineWidth;
                    g.setColor(this.color);
                    g.stroke();
                }
            };
        }
    ]);

    /**
     * Linear ruler class. The ruler draws strokes using dedicated pixel delta value.
     * @param  {String} [o] an orientation (use &quot;vertical&quot; or &quot;horizontal&quot; as the parameter value)
     * @class zebkit.ui.LinearRulerPan
     * @constructor
     * @extends zebkit.ui.RulerPan
     */
    pkg.LinearRulerPan = Class(pkg.RulerPan, [
        function $prototype() {
            this.strokeStep = 2;
            this.longStrokeRate = this.strokeStep * 8;

            this.setStrokeStep = function(strokeStep, longStrokeRate) {
                var b = false;
                if (strokeStep !== this.strokeStep) {
                    this.strokeStep = strokeStep;
                    b = true;
                }

                if (arguments.length &gt; 1) {
                    if (this.longStrokeRate !== longStrokeRate) {
                        this.longStrokeRate = longStrokeRate;
                        b = true;
                    }
                } else if (this.longStrokeRate &lt;= 2 * strokeStep) {
                    this.longStrokeRate = strokeStep * 8;
                    b = true;
                }

                if (b) {
                    this.repaint();
                }

                return this;
            };

            this.paint = function(g) {
                var i          = 0,
                    ss         = this.showStrokes ? this.strokeSize : 0,
                    ps         = null,
                    prevLabLoc = null,
                    prevPs     = null;

                g.beginPath();

                if (this.orient === &quot;horizontal&quot;) {
                    var y          = this.getTop(),
                        xx         = this.getLeft() + this.$minGap,
                        maxX       = this.width - this.getRight() - this.$maxGap - 1;

                    for (i = 0; xx &lt;= maxX; i++, xx += this.strokeStep) {
                        if (i % this.longStrokeRate === 0) {
                            var rendered = false;

                            if (this.provider !== null &amp;&amp; this.showLabels) {
                                var v    = this.toValue(xx),
                                    view = this.provider.getView(this, v);

                                if (view !== null) {
                                    ps = view.getPreferredSize();

                                    var loc = xx - Math.round(ps.width / 2);
                                    if (prevLabLoc === null || loc &gt; prevLabLoc + prevPs.width) {
                                        this.paintLabel(g,
                                                        loc,
                                                        this.labelsAlignment === &quot;normal&quot; ? y + 2 * ss + this.gap
                                                                                          : y,
                                                        ps.width, ps.height, view, v);

                                        prevLabLoc = loc;
                                        prevPs  = ps;
                                        rendered = true;
                                    }
                                }
                            }

                            if (this.showStrokes) {
                                if (this.labelsAlignment === &quot;normal&quot;) {
                                    g.moveTo(xx + 0.5, y);
                                    g.lineTo(xx + 0.5, y + (rendered ? 2 * ss : ss));
                                } else {
                                    g.moveTo(xx + 0.5, y + this.$maxLabSize + this.gap + (rendered ? 0 : ss));
                                    g.lineTo(xx + 0.5, y + this.$maxLabSize + this.gap + 2 * ss);
                                }
                            }
                        } else if (this.showStrokes) {
                            if (this.labelsAlignment === &quot;normal&quot;) {
                                g.moveTo(xx + 0.5, y);
                                g.lineTo(xx + 0.5, y + ss);
                            } else {
                                g.moveTo(xx + 0.5, y + this.$maxLabSize + this.gap + ss);
                                g.lineTo(xx + 0.5, y + this.$maxLabSize + this.gap + 2 * ss);
                            }
                        }
                    }
                } else {
                    var x    = this.getLeft(),
                        yy   = this.height - this.getBottom() - this.$minGap - 1,
                        minY = this.getTop() + this.$maxGap;

                    for (i = 0; yy &gt;= minY; i++, yy -= this.strokeStep) {
                        if (i % this.longStrokeRate === 0) {
                            var rendered = false;

                            if (this.provider !== null &amp;&amp; this.showLabels) {
                                var v    = this.toValue(yy),
                                    view = this.provider.getView(this, v);

                                if (view !== null) {
                                    ps = view.getPreferredSize();

                                    var loc = yy - Math.round(ps.height / 2);
                                    if (prevLabLoc === null || (loc + ps.height) &lt; prevLabLoc) {
                                        this.paintLabel(g,
                                                        this.labelsAlignment === &quot;normal&quot; ? x + 2 * ss + this.gap
                                                                                          : x,
                                                        loc,
                                                        ps.width, ps.height, view, v);

                                        prevLabLoc = loc;
                                        rendered = true;
                                    }
                                }
                            }

                            if (this.showStrokes) {
                                if (this.labelsAlignment === &quot;normal&quot;) {
                                    g.moveTo(x, yy + 0.5);
                                    g.lineTo(x + (rendered ? 2 * ss : ss), yy + 0.5);
                                } else {
                                    g.moveTo(x + this.$maxLabSize + this.gap + (rendered ? 0 : ss), yy + 0.5);
                                    g.lineTo(x + this.$maxLabSize + this.gap + 2 * ss, yy + 0.5);
                                }
                            }
                        } else if (this.showStrokes) {
                            if (this.labelsAlignment === &quot;normal&quot;) {
                                g.moveTo(x, yy + 0.5);
                                g.lineTo(x + ss, yy + 0.5);
                            } else {
                                g.moveTo(x + this.$maxLabSize + this.gap + ss, yy + 0.5);
                                g.lineTo(x + this.$maxLabSize + this.gap + 2 * ss, yy + 0.5);
                            }
                        }
                    }
                }

                g.setColor(this.color);
                g.lineWidth = this.lineWidth;
                g.stroke();
            };
        },

        function recalcMetrics() {
            this.$super();
            if (this.orient === &quot;horizontal&quot;) {
                this.$psH += this.strokeSize;
            } else {
                this.$psW += this.strokeSize;
            }
        }
    ]);

    /**
     * Slider UI component class.
     * @class  zebkit.ui.Slider
     * @param {String} [o]  a slider orientation (&quot;vertical or &quot;horizontal&quot;)
     * @constructor
     * @extends zebkit.ui.Panel
     * @uses   zebkit.ui.DecorationViews
     */
    pkg.Slider = Class(pkg.Panel, pkg.DecorationViews, [
        function(o) {
            this._ = new zebkit.util.Listeners();
            this.views = {
                marker: null,
                gauge : null
            };

            this.$super();

            var ruler = null;
            if (arguments.length &gt; 0) {
                if (zebkit.instanceOf(o, zebkit.ui.RulerPan)) {
                    this.orient = o.orient;
                    ruler = o;
                } else {
                    ruler = new pkg.RulerPan(o);
                }
            } else {
                ruler = new pkg.RulerPan(this.orient);
            }

            this.add(&quot;ruler&quot;, ruler);
            this.add(&quot;gauge&quot;, new this.clazz.GaugePan());
        },

        function $clazz() {
            this.GaugePan = Class(pkg.Panel, []);
        },

        function $prototype() {
            /**
             * Current slider value
             * @type {Number}
             * @attribute value
             * @readOnly
             */
            this.value = 0;

            /**
             * Slider orientation.
             * @type {String}
             * @attribute orient
             * @readOnly
             */
            this.orient = &quot;horizontal&quot;;

            /**
             * Gap between slider handle and ruler
             * @type {Integer}
             * @attribute gap
             * @readOnly
             * @default 4
             */
            this.gap = 4;

            this.canHaveFocus = true;

            /**
             * Granularity of sliding.
             * @type {Number}
             * @attribute granularity
             * @readOnly
             * @default 1
             */
            this.granularity = 1;

            /**
             * Ruler component.
             * @type {zebkit.ui.RulerPan}
             * @attribute ruler
             * @readOnly
             */
            this.ruler = null;


            this.gauge = null;


            this.handle = null;

            this.$dragged = false;
            this.$dxy = this.$val = 0;

            this.compAdded = function(e) {
                if (e.constraints === &quot;ruler&quot;) {
                    this.ruler = e.kid;
                    this.orient = this.ruler.orient;
                    this.setValue(this.ruler.getMin());
                } else if (e.constraints === &quot;gauge&quot;) {
                    this.gauge = e.kid;
                }
            };

            this.compRemoved = function(e) {
                if (this.gauge === e.kid) {
                    this.gauge = null;
                }
            };

            this.setHandleView = function(v) {
                if (this.handle !== v) {
                    this.handle = zebkit.draw.$view(v);
                    this.vrp();
                }
                return this;
            };

            /**
             * Get maximal possible value.
             * @return {Number} a value
             * @method getMax
             */
            this.getMax = function() {
                return this.ruler.getMax();
            };

            /**
             * Get minimal possible value.
             * @return {Number} a value
             * @method getMin
             */
            this.getMin = function() {
                return this.ruler.getMin();
            };

            this.toLocation = function(v) {
                return (this.orient === &quot;horizontal&quot;) ? this.ruler.toLocation(v) + this.ruler.x
                                                      : this.ruler.toLocation(v) + this.ruler.y;
            };

            this.getHandleView = function() {
                var h = this.orient === &quot;horizontal&quot; ? this.views.horHandle
                                                     : this.views.verHandle;
                return typeof h === &#x27;undefined&#x27; ? null : h;
            };

            this.getHandlePreferredSize = function() {
                var h = this.orient === &quot;horizontal&quot; ? this.views.horHandle
                                                     : this.views.verHandle;
                return typeof h === &#x27;undefined&#x27; || h === null ? { width: 0, height: 0}
                                                              : h.getPreferredSize();
            };

            /**
             * Set orientation
             * @param {String} o an orientation. Use &quot;horizontal&quot; or &quot;vertical&quot; as the parameter value
             * @method setOrientation
             * @chainable
             */
            this.setOrientation = function(o) {
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, &quot;vertical&quot;, &quot;horizontal&quot;);
                    this.ruler.setOrientation(o);
                    this.vrp();
                }
                return this;
            };

            this.pointerDragged = function(e){
                if (this.$dragged) {
                    var max  = this.ruler.getMax(),
                        min  = this.ruler.getMin(),
                        dxy = (this.orient === &quot;horizontal&quot; ? e.x - this.$sxy : this.$sxy - e.y);

                    // TODO: ruler.toValue
                    this.setValue(this.$val + dxy * ((max - min)/ this.ruler.$getRulerSize()));
                }
            };

            //
            //    +---------------------------------------------------------
            //    |        ^
            //    |        | top
            //    |      . . . . . . . . . . . . . . . . . . . . . . . . . .
            //    | left .                ------ ----------------------
            //    |&lt;----&gt;.               |      |                    ^
            //    |      .               |      |                    |
            //    |      . ==============|      |=================   |  handler
            //    |      . ==============|      |=================   | preferred
            //    |      .               |      |                    |   height
            //    \      .               |      |                    |
            //    |      .                ------
            //    |      .                  ^
            //    |      .                  | gap
            //    |      .  |---|---|---|---|---|---|---|---|---|---|---|  ^
            //    |      .              |               |               |  | 2 * netSize
            //    |      .              ^
            //    |      .              | gap
            //    |      .            Num_1            Num_2          Num_3
            //

            this.paintOnTop = function(g) {
                var left        = this.getLeft(),
                    top         = this.getTop(),
                    right       = this.getRight(),
                    bottom      = this.getBottom(),
                    handleView  = this.getHandleView(),
                    handlePs    = this.getHandlePreferredSize(),
                    w           = this.width  - left - right,
                    h           = this.height - top  - bottom;

                if (this.orient === &quot;horizontal&quot;) {
                    if (handleView !== null) {
                        handleView.paint(g, this.getHandleLoc(),
                                            top,
                                            handlePs.width,
                                            handlePs.height,
                                            this);
                    }
                } else {
                    if (handleView !== null) {
                        handleView.paint(g, left,
                                            this.getHandleLoc(),
                                            handlePs.width,
                                            handlePs.height,
                                            this);
                    }
                }

                if (this.hasFocus() &amp;&amp; this.views.marker) {
                    this.views.marker.paint(g, left, top, w, h, this);
                }
            };

            this.getHandleLoc = function() {
                var hs = this.getHandlePreferredSize();
                return (this.orient === &quot;horizontal&quot;) ? this.toLocation(this.value) - Math.round(hs.width  / 2)
                                                      : this.toLocation(this.value) - Math.round(hs.height / 2);
            };

            this.getHandleBounds = function() {
                var bs = this.getHandlePreferredSize();
                return this.orient === &quot;horizontal&quot; ? {
                    x: this.getHandleLoc(),
                    y: this.getTop(),
                    width : bs.width,
                    height: bs.height
                }
                                                   : {
                    x: this.getLeft(),
                    y: this.getHandleLoc(),
                    width : bs.width,
                    height: bs.height
                };
            };

            this.catchInput = function(target) {
                return target !== this.ruler;
            };

            this.doLayout = function(t) {
                var gaugePs = this.gauge !== null &amp;&amp; this.gauge.isVisible ? this.gauge.getPreferredSize() : null,
                    hs      = this.getHandlePreferredSize(),
                    h2s     = this.orient === &quot;vertical&quot; ? Math.round(hs.height / 2)
                                                         : Math.round(hs.width / 2);


                if (this.orient === &quot;vertical&quot;) {
                    var y = this.getTop() + (this.ruler.$maxGap &gt;= h2s ? 0 : h2s - this.ruler.$maxGap);

                    this.ruler.setLocation(this.getLeft() + hs.width + this.gap, y);
                    this.ruler.setSize(this.ruler.getPreferredSize().width,
                        this.height - y - this.getBottom() -
                                       (this.ruler.$minGap &gt;= h2s ? 0 : (h2s - this.ruler.$minGap)));

                    if (this.gauge !== null &amp;&amp; this.gauge.isVisible) {
                        this.gauge.setBounds(this.getLeft() + Math.floor((hs.width - gaugePs.width) / 2),
                                             this.getTop(),
                                             gaugePs.width,
                                             this.height - this.getTop() - this.getBottom());
                    }

                } else {
                    var x = this.getLeft() + (this.ruler.$minGap &gt;= h2s ? 0 : h2s - this.ruler.$minGap);

                    this.ruler.setLocation(x, this.getTop() + hs.height + this.gap);
                    this.ruler.setSize(this.width - x - this.getRight() -
                                       (this.ruler.$maxGap &gt;= h2s ? 0 : (h2s - this.ruler.$maxGap)),
                                        this.ruler.getPreferredSize().height);



                    if (this.gauge !== null &amp;&amp; this.gauge.isVisible) {
                        this.gauge.setBounds(this.getLeft(),
                                             this.getTop() + Math.floor((hs.height - gaugePs.height) / 2),
                                             this.width - this.getLeft() - this.getRight(),
                                             gaugePs.height);
                    }
                }
            };

            this.calcPreferredSize = function(l) {
                var ps = this.getHandlePreferredSize();

                if (this.ruler.isVisible === true) {
                    var rps = this.ruler.getPreferredSize();
                    if (this.orient === &quot;horizontal&quot;) {
                        var h2s = Math.round(ps.width / 2);
                        ps.height += (this.gap + rps.height);
                        ps.width = 10 * ps.width +
                                   Math.max(h2s, this.ruler.isVisible ? this.ruler.$minGap : 0) +
                                   Math.max(h2s, this.ruler.isVisible ? this.ruler.$maxGap : 0);
                    } else {
                        var h2s = Math.round(ps.height / 2);
                        ps.height = 10 * ps.height +
                                    Math.max(h2s, this.ruler.isVisible ? this.ruler.$minGap : 0) +
                                    Math.max(h2s, this.ruler.isVisible ? this.ruler.$maxGap : 0);

                        ps.width += (this.gap + rps.width);
                    }
                }
                return ps;
            };

            /**
             * Set the slider value that has to be withing the given defined range.
             * If the value is out of the defined range then the value will be
             * adjusted to maximum or minimum possible value.
             * @param {Number} v a value
             * @method setValue
             * @chainable
             */
            this.setValue = function(v) {
                // normalize value
                v = Math.round(v / this.granularity) * this.granularity;

                var max = this.getMax(),
                    min = this.getMin();

                // align value
                if (v &gt; max) {
                    v = max;
                } else if (v &lt; min) {
                    v = min;
                }

                var prev = this.value;
                if (this.value !== v){
                    this.value = v;
                    this._.fired(this, prev);
                    this.repaint();
                }

                return this;
            };

            this.keyPressed = function(e) {
                switch(e.code) {
                    case &quot;ArrowDown&quot;:
                    case &quot;ArrowLeft&quot;:
                        this.setValue(this.value - this.granularity);
                        break;
                    case &quot;ArrowUp&quot;:
                    case &quot;ArrowRight&quot;:
                        this.setValue(this.value + this.granularity);
                        break;
                    case &quot;Home&quot;:
                        this.setValue(this.getMin());
                        break;
                    case &quot;End&quot;:
                        this.setValue(this.getMax());
                        break;
                }
            };

            this.pointerClicked = function (e){
                if (e.isAction()) {
                    var x = e.x,
                        y = e.y,
                        handle = this.getHandleBounds();

                    if (x &lt; handle.x ||
                        y &lt; handle.y ||
                        x &gt;= handle.x + handle.width ||
                        y &gt;= handle.y + handle.height   )
                    {
                        var l = ((this.orient === &quot;horizontal&quot;) ? x - this.ruler.x
                                                                : y - this.ruler.y);

                        this.setValue(this.ruler.toValue(l));
                    }
                }
            };

            this.pointerDragStarted = function(e){
                var r = this.getHandleBounds();
                if (e.x &gt;= r.x           &amp;&amp;
                    e.y &gt;= r.y           &amp;&amp;
                    e.x &lt; r.x + r.width  &amp;&amp;
                    e.y &lt; r.y + r.height   )
                {
                    this.$dragged = true;
                    this.$sxy     = this.orient === &quot;horizontal&quot; ? e.x : e.y;
                    this.$val     = this.value;
                }
            };

            this.pointerDragEnded = function(e) {
                this.$dragged = false;
            };

            /**
             * Set the granularity. Granularity defines a delta to a slider value
             * can be decreased or increased.
             * @param {Number} g a granularity.
             * @method setGranularity
             * @chainable
             */
            this.setGranularity = function(g) {
                if (g &gt;= (this.getMax() - this.getMin())) {
                    throw new Error(&quot;Invalid granularity &quot; + g);
                }

                if (this.granularity !== g) {
                    this.granularity = g;
                    this.setValue(this.value);
                }
                return this;
            };

            /**
             * Set the range the slider value can be changed.
             * @param {Number} min a minimal possible value
             * @param {Number} max a maximal possible value
             * @param {Number} [granularity] a granularity
             * @method setRange
             * @chainable
             */
            this.setRange = function(min, max, granularity) {
                if (this.getMin() !== min || this.getMax() !== max || granularity !== this.granularity) {
                    this.ruler.setRange(min, max);
                    this.setGranularity(arguments.length &gt; 2 ? granularity : this.granularity); // validate granularity
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the gap between the slider handle and the ruler.
             * @param {Integer} g a gap
             * @method setRulerGap
             * @chainable
             */
            this.setRulerGap = function(g) {
                if (g !== this.gap) {
                    this.gap = g;
                    this.vrp();
                }
                return this;
            };
        },

        function focused() {
            this.$super();
            this.repaint();
        }
    ]);


    /**
     * Tabs UI panel. The component is used to organize switching between number of pages where every
     * page is an UI component.
     *
     * Filling tabs component with pages is the same to how you add an UI component to a panel. For
     * instance in the example below three pages with &quot;Titl1&quot;, &quot;Title2&quot;, &quot;Title3&quot; are added:
     *
     *     var tabs = new zebkit.ui.Tabs();
     *     tabs.add(&quot;Title1&quot;, new zebkit.ui.Label(&quot;Label as a page&quot;));
     *     tabs.add(&quot;Title2&quot;, new zebkit.ui.Button(&quot;Button as a page&quot;));
     *     tabs.add(&quot;Title3&quot;, new zebkit.ui.TextArea(&quot;Text area as a page&quot;));
     *
     *  You can access tabs pages UI component the same way like you access a panel children components
     *
     *     ...
     *     tabs.kids[0] // access the first page
     *
     *  And you can remove it with standard panel inherited API:
     *
     *     ...
     *     tabs.removeAt(0); // remove first tab page
     *
     *
     *  To customize tab page caption and icon you should access tab object and do it with API it provides:
     *
     *
     *      // update a tab caption
     *      tabs.getTab(0).setCaption(&quot;Test&quot;);
     *
     *      // update a tab icon
     *      tabs.getTab(0).setIcon(&quot;my.gif&quot;);
     *
     *      // set a particular font and color for the tab in selected state
     *      tabs.getTab(0).setColor(true, &quot;blue&quot;);
     *      tabs.getTab(0).setFont(true, new zebkit.Font(&quot;Arial&quot;, &quot;bold&quot;, 16));
     *
     *      // set other caption for the tab in not selected state
     *      tabs.getTab(0).setCaption(false, &quot;Test&quot;);
     *
     * @param {String} [o] the tab panel orientation:
     *
     *     &quot;top&quot;
     *     &quot;bottom&quot;
     *     &quot;left&quot;
     *     &quot;right&quot;
     *
     * @class zebkit.ui.Tabs
     * @uses  zebkit.ui.DecorationViews
     * @constructor
     * @extends zebkit.ui.Panel
     */

    /**
     * Fired when a new tab page has been selected
     *
     *     tabs.on(function(src, selectedIndex) {
     *        ...
     *     });
     *
     * @event selected
     * @param {zebkit.ui.Tabs} src a tabs component that triggers the event
     * @param {Integer} selectedIndex a tab page index that has been selected
     */
    pkg.Tabs = Class(pkg.Panel, pkg.DecorationViews, [
        function(o) {
            /**
             * Selected tab page index
             * @attribute selectedIndex
             * @type {Integer}
             * @readOnly
             */
            this.vgap = this.hgap = this.tabAreaX = 0;
            this.repaintWidth = this.repaintHeight = this.repaintX = this.repaintY = 0;

            this.tabAreaY = this.tabAreaWidth = this.tabAreaHeight = 0;
            this.overTab = this.selectedIndex = -1;

            this._ = new zebkit.util.Listeners();
            this.pages = [];
            this.views = {};

            if (typeof pkg.Tabs.font      !== &#x27;undefined&#x27;) {
                this.render.setFont(pkg.Tabs.font);
            }

            if (typeof pkg.Tabs.fontColor !== &#x27;undefined&#x27;) {
                this.render.setColor(pkg.Tabs.fontColor);
            }

            this.$super();

            // since alignment pass as the constructor argument the setter has to be called after $super
            // because $super can re-set title alignment

            if (arguments.length &gt; 0) {
                this.setAlignment(o);
            }
        },

        function $clazz() {
            /**
             * Tab view class that defines the tab page title and icon
             * @param {String|Image} [icon]  an path to an image or image object
             * @param {String} [caption] a tab caption
             * @class zebkit.ui.Tabs.TabView
             * @extends zebkit.ui.CompRender
             * @constructor
             */
            this.TabView = Class(pkg.CompRender, [
                function(icon, caption) {
                    if (arguments.length === 0) {
                        caption = &quot;&quot;;
                    } else if (arguments.length === 1) {
                        caption = icon;
                        icon = null;
                    }

                    var tp = new this.clazz.TabPan();
                    this.$super(tp);

                    var $this = this;
                    tp.getImagePan().imageLoaded = function(img) {
                        $this.vrp();

                        // if the icon has zero width and height the repaint
                        // doesn&#x27;t trigger validation. So let&#x27;s do it on
                        // parent level
                        if ($this.owner !== null &amp;&amp; $this.owner.parent !== null) {
                            $this.owner.repaint();
                        }
                    };

                    var r1 = new this.clazz.captionRender(caption),
                        r2 = new this.clazz.captionRender(caption);

                    r2.setColor(this.clazz.fontColor);
                    r1.setColor(this.clazz.selectedFontColor);
                    r2.setFont (this.clazz.font);
                    r1.setFont (this.clazz.selectedFont);

                    this.getCaptionPan().setView(
                        new zebkit.draw.ViewSet(
                            {
                                &quot;selected&quot;: r1,
                                &quot;*&quot;       : r2
                            },
                            [
                                function setFont(id, f) {
                                    var v = this.views[id];
                                    if (v) {
                                        v.setFont(f);
                                        this.recalc();
                                    }
                                    return this;
                                },

                                function setCaption(id, s) {
                                    var v = this.views[id];
                                    if (v) {
                                        v.setValue(s);
                                        this.recalc();
                                    }
                                    return this;
                                },

                                function getCaption(id) {
                                    var v = this.views[id];
                                    return v == null ? null : v.getValue();
                                }
                            ]
                        )
                    );

                    this.setIcon(icon);
                },

                function $clazz() {
                    this.captionRender = zebkit.draw.StringRender;
                    this.font = new zebkit.Font(&quot;Arial&quot;, 14);

                    this.TabPan = Class(pkg.Panel, [
                        function() {
                            this.$super();
                            this.add(new pkg.ImagePan(null));
                            this.add(new pkg.ViewPan());
                        },

                        function getImagePan() {
                            return this.kids[0];
                        },

                        function getViewPan() {
                            return this.kids[1];
                        }
                    ]);
                },

                function $prototype() {
                    this.owner = null;

                    this.ownerChanged = function(v) {
                        this.owner = v;
                    };

                    this.vrp = function() {
                        if (this.owner !== null) {
                            this.owner.vrp();
                        }
                    };

                    /**
                     * Set the given tab caption for the specified tab or both - selected and not selected - states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {String} s the tab caption
                     * @method setCaption
                     * @chainable
                     */
                    this.setCaption = function(b, s) {
                        if (arguments.length === 1) {
                            this.setCaption(true, b);
                            this.setCaption(false, b);
                        } else {
                            this.getCaptionPan().view.setCaption(this.$toId(b), s);
                            this.vrp();
                        }
                        return this;
                    };

                    /**
                     * Get the tab caption for the specified tab state
                     * @param {Boolean} b the tab state. true means selected state.
                     * @return {String} the tab caption
                     * @method getCaption
                     */
                    this.getCaption = function (b) {
                        return this.getCaptionPan().view.getCaption(this.$toId(b));
                    };

                    /**
                     * Set the given tab caption text color for the specified tab or both
                     * selected and not selected states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {String} c the tab caption
                     * @method setColor
                     * @chainable
                     */
                    this.setColor = function(b, c) {
                        if (arguments.length === 1) {
                            this.setColor(true, b);
                            this.setColor(false, b);
                        } else {
                            var v = this.getCaptionPan().view.views[this.$toId(b)];
                            if (v) {
                                v.setColor(c);
                                this.vrp();
                            }
                        }
                        return this;
                    };

                    /**
                     * Set the given tab caption text font for the specified or both
                     * selected not slected states.
                     * @param {Boolean} [b] the tab state. true means selected state.
                     * @param {zebkit.Font} f the tab text font
                     * @method setFont
                     * @chainable
                     */
                    this.setFont = function(b, f) {
                        if (arguments.length === 1) {
                            this.setFont(true, b);
                            this.setFont(false, b);
                        } else {
                            this.getCaptionPan().view.setFont(this.$toId(b), f);
                            this.vrp();
                        }
                        return this;
                    };

                    this.getCaptionPan = function () {
                        return this.target.getViewPan();
                    };

                    /**
                     * Set the tab icon.
                     * @param {String|Image} c an icon path or image object
                     * @method setIcon
                     * @chainable
                     */
                    this.setIcon = function (c) {
                        this.target.getImagePan().setImage(c);
                        this.target.getImagePan().setVisible(c !== null);
                        return this;
                    };

                    /**
                     * The method is invoked every time the tab selection state has been updated
                     * @param {zebkit.ui.Tabs} tabs the tabs component the tab belongs
                     * @param {Integer} i an index of the tab
                     * @param {Boolean} b a new state of the tab
                     * @method selected
                     */
                    this.selected = function(tabs, i, b) {
                        this.getCaptionPan().view.activate(this.$toId(b), this);
                    };

                    this.$toId = function(b) {
                        return b ? &quot;selected&quot; : &quot;*&quot;;
                    };
                }
            ]);
        },

        /**
         * @for zebkit.ui.Tabs
         */
        function $prototype() {
            /**
             * Tab orientation
             * @attribute orient
             * @type {String}
             * @readOnly
             */
            this.orient = &quot;top&quot;;

            /**
             * Sides gap
             * @attribute sideSpace
             * @type {Integer}
             * @readOnly
             * @default 1
             */
            this.sideSpace = 1;

            /**
             * Declare can have focus attribute to make the component focusable
             * @type {Boolean}
             * @attribute canHaveFocus
             * @readOnly
             */
            this.canHaveFocus = true;

            /**
             * Define pointer moved event handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                var i = this.getTabAt(e.x, e.y);
                if (this.overTab !== i) {
                    this.overTab = i;
                    if (this.views.overTab) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Define pointer drag ended event handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function(e) {
                var i = this.getTabAt(e.x, e.y);
                if (this.overTab !== i) {
                    this.overTab = i;
                    if (this.views.overTab) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Define pointer exited event handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerExited
             */
            this.pointerExited = function(e) {
                if (this.overTab &gt;= 0) {
                    this.overTab = -1;
                    if (this.views.overTab) {
                        this.repaint(this.repaintX, this.repaintY,
                                     this.repaintWidth, this.repaintHeight);
                    }
                }
            };

            /**
             * Navigate to a next tab page following the given direction starting
             * from the given page
             * @param  {Integer} page a starting page index
             * @param  {Integer} d a navigation direction. 1 means forward and -1 means backward
             * navigation.
             * @return {Integer} a new tab page index
             * @method next
             */
            this.next = function (page, d){
                for(; page &gt;= 0 &amp;&amp; page &lt; Math.floor(this.pages.length / 2); page += d) {
                    if (this.isTabEnabled(page) === true) {
                        return page;
                    }
                }
                return -1;
            };

            this.getTitleInfo = function(){
                var b   = (this.orient === &quot;left&quot; || this.orient === &quot;right&quot;),
                    res = b ? { x      : this.tabAreaX,
                                y      : 0,
                                width  : this.tabAreaWidth,
                                height : 0,
                                orient : this.orient }
                            : { x      : 0,
                                y      : this.tabAreaY,
                                width  : 0,
                                height : this.tabAreaHeight,
                                orient : this.orient };

                if (this.selectedIndex &gt;= 0){
                    var r = this.getTabBounds(this.selectedIndex);
                    if (b) {
                        res.y = r.y;
                        res.height = r.height;
                    } else {
                        res.x = r.x;
                        res.width = r.width;
                    }
                }
                return res;
            };

            /**
             * Test if the given tab page is in enabled state
             * @param  {Integer} index a tab page index
             * @return {Boolean} a tab page state
             * @method isTabEnabled
             */
            this.isTabEnabled = function (index){
                return this.kids[index].isEnabled;
            };

            this.paintOnTop = function(g){
                var ts = g.$states[g.$curState];
                // stop painting if the tab area is outside of clip area
                if (zebkit.util.isIntersect(this.repaintX, this.repaintY,
                                            this.repaintWidth, this.repaintHeight,
                                            ts.x, ts.y, ts.width, ts.height))
                {
                    var i = 0;
                    for(i = 0; i &lt; this.selectedIndex; i++) {
                        this.paintTab(g, i);
                    }

                    for(i = this.selectedIndex + 1;i &lt; Math.floor(this.pages.length / 2); i++) {
                        this.paintTab(g, i);
                    }

                    if (this.selectedIndex &gt;= 0){
                        this.paintTab(g, this.selectedIndex);
                        if (this.hasFocus()) {
                            this.drawMarker(g, this.getTabBounds(this.selectedIndex));
                        }
                    }
                }
            };

            /**
             * Draw currently activate tab page marker.
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {Object} r a tab page title rectangular area
             * @method drawMarker
             */
            this.drawMarker = function(g,r){
                var marker = this.views.marker;
                if (marker) {
                    //TODO: why only &quot;out&quot; is checked ?
                    var bv   = this.views.outTab,
                        left = bv ? bv.getLeft() : 0,
                        top  = bv ? bv.getTop()  : 0;
                    marker.paint(g, r.x + left, r.y + top,
                                    r.width  - left - (bv == null ? 0 : bv.getRight()),
                                    r.height - top  - (bv == null ? 0 : bv.getBottom()), this);
                }
            };

            /**
             * Paint the given tab page title
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {Integer} pageIndex a tab page index
             * @method paintTab
             */
            this.paintTab = function (g, pageIndex){
                var b       = this.getTabBounds(pageIndex),
                    page    = this.kids[pageIndex],
                    tab     = this.views.outTab,
                    tabover = this.views.overTab,
                    tabon   = this.views.selectedTab,
                    v       = this.pages[pageIndex * 2],
                    ps      = v.getPreferredSize();

                if (this.selectedIndex === pageIndex &amp;&amp; tabon) {
                    tabon.paint(g, b.x, b.y, b.width, b.height, page);
                } else if (tab) {
                    tab.paint(g, b.x, b.y, b.width, b.height, page);
                }

                if (this.overTab &gt;= 0 &amp;&amp; this.overTab === pageIndex &amp;&amp; tabover) {
                    tabover.paint(g, b.x, b.y, b.width, b.height, page);
                }

                v.paint(g, b.x + Math.floor((b.width  - ps.width ) / 2),
                           b.y + Math.floor((b.height - ps.height) / 2),
                           ps.width, ps.height, page);
            };

            /**
             * Get the given tab page title rectangular bounds
             * @param  {Integer} i a tab page index
             * @return {Object} a tab page rectangular bounds
             *
             *    {x:{Integer}, y:{Integer}, width:{Integer}, height:{Integer}}
             *
             * @protected
             * @method getTabBounds
             */
            this.getTabBounds = function(i){
                return this.pages[2 * i + 1];
            };

            this.calcPreferredSize = function(target){
                var max = zebkit.layout.getMaxPreferredSize(target);
                if (this.orient === &quot;bottom&quot; || this.orient === &quot;top&quot;){
                    max.width = Math.max(max.width, 2 * this.sideSpace + this.tabAreaWidth);
                    max.height += this.tabAreaHeight + this.sideSpace;
                } else {
                    max.width += this.tabAreaWidth + this.sideSpace;
                    max.height = Math.max(max.height, 2 * this.sideSpace + this.tabAreaHeight);
                }
                return max;
            };

            this.doLayout = function(target) {
                var right  = this.orient === &quot;right&quot;  ? this.right  : this.getRight(),
                    top    = this.orient === &quot;top&quot;    ? this.top    : this.getTop(),
                    bottom = this.orient === &quot;bottom&quot; ? this.bottom : this.getBottom(),
                    left   = this.orient === &quot;left&quot;   ? this.left   : this.getLeft(),
                    b      = (this.orient === &quot;top&quot; || this.orient === &quot;bottom&quot;);

                if (b) {
                    this.repaintX = this.tabAreaX = left ;
                    this.repaintY = this.tabAreaY = (this.orient === &quot;top&quot;) ? top
                                                                            : this.height - bottom - this.tabAreaHeight;
                    if (this.orient === &quot;bottom&quot;) {
                        this.repaintY -= (this.border !== null ? this.border.getBottom() : 0);
                    }
                } else {
                    this.repaintX = this.tabAreaX = (this.orient === &quot;left&quot; ? left
                                                                            : this.width - right - this.tabAreaWidth);
                    this.repaintY = this.tabAreaY = top ;
                    if (this.orient === &quot;right&quot;) {
                        this.repaintX -= (this.border !== null ? this.border.getRight() : 0);
                    }
                }

                var count = this.kids.length,
                    sp    = 2 * this.sideSpace,
                    xx    = (this.orient === &quot;right&quot;  ? this.tabAreaX : this.tabAreaX + this.sideSpace),
                    yy    = (this.orient === &quot;bottom&quot; ? this.tabAreaY : this.tabAreaY + this.sideSpace),
                    r     = null,
                    i     = 0;

                for(i = 0; i &lt; count; i++ ){
                    r = this.getTabBounds(i);

                    r.x = xx;
                    r.y = yy;

                    if (b) {
                        xx += r.width;
                        if (i === this.selectedIndex) {
                            xx -= sp;
                            if (this.orient === &quot;bottom&quot;) {
                                r.y -= (this.border !== null ? this.border.getBottom() : 0);
                            }
                        }
                    } else {
                        yy += r.height;
                        if (i === this.selectedIndex) {
                            yy -= sp;
                            if (this.orient === &quot;right&quot;) {
                                r.x -= (this.border !== null ? this.border.getRight() : 0);
                            }
                        }
                    }
                }

                // make visible tab title
                if (this.selectedIndex &gt;= 0){
                    var dt = 0;

                    r = this.getTabBounds(this.selectedIndex);
                    if (b) {
                        r.x -= this.sideSpace;
                        r.y -= ((this.orient === &quot;top&quot;) ? this.sideSpace : 0);
                        dt = (r.x &lt; left) ? left - r.x
                                          : (r.x + r.width &gt; this.width - right) ? this.width - right - r.x - r.width : 0;
                    } else {
                        r.x -= (this.orient === &quot;left&quot;) ? this.sideSpace : 0;
                        r.y -= this.sideSpace;
                        dt = (r.y &lt; top) ? top - r.y
                                         : (r.y + r.height &gt; this.height - bottom) ? this.height - bottom - r.y - r.height : 0;
                    }

                    for(i = 0;i &lt; count; i ++ ){
                        var br = this.getTabBounds(i);
                        if (b) {
                            br.x += dt;
                        } else {
                            br.y += dt;
                        }
                    }
                }

                for(i = 0;i &lt; count; i++){
                    var l = this.kids[i];
                    if (i === this.selectedIndex) {
                        if (b) {
                            l.setBounds(left + this.hgap,
                                        ((this.orient === &quot;top&quot;) ? top + this.repaintHeight : top) + this.vgap,
                                        this.width - left - right - 2 * this.hgap,
                                        this.height - this.repaintHeight - top - bottom - 2 * this.vgap);
                        } else {
                            l.setBounds(((this.orient === &quot;left&quot;) ? left + this.repaintWidth : left) + this.hgap,
                                        top + this.vgap,
                                        this.width - this.repaintWidth - left - right - 2 * this.hgap,
                                        this.height - top - bottom - 2 * this.vgap);
                        }
                    } else {
                        l.setSize(0, 0);
                    }
                }
            };

            /**
             * Define recalc method to compute the component metrical characteristics
             * @method recalc
             */
            this.recalc = function(){
                var count = Math.floor(this.pages.length / 2);
                if (count &gt; 0) {
                    this.tabAreaHeight = this.tabAreaWidth = 0;

                    var bv   = this.views.outTab ? this.views.outTab : null,
                        b    = (this.orient === &quot;left&quot; || this.orient === &quot;right&quot;),
                        max  = 0,
                        i    = 0,
                        r    = null,
                        hadd = bv === null ? 0 : bv.getLeft() + bv.getRight(),
                        vadd = bv === null ? 0 : bv.getTop()  + bv.getBottom();

                    for(i = 0; i &lt; count; i++){
                        var ps =  this.pages[i * 2] != null ? this.pages[i * 2].getPreferredSize()
                                                            : { width:0, height:0};

                        r = this.getTabBounds(i);
                        if (b) {
                            r.height = ps.height + vadd;
                            if (ps.width + hadd &gt; max) {
                                max = ps.width + hadd;
                            }
                            this.tabAreaHeight += r.height;
                        } else {
                            r.width = ps.width + hadd;
                            if (ps.height + vadd &gt; max) {
                                max = ps.height + vadd;
                            }
                            this.tabAreaWidth += r.width;
                        }
                    }

                    // align tabs widths or heights to have the same size
                    for(i = 0; i &lt; count; i++ ){
                        r = this.getTabBounds(i);
                        if (b) {
                            r.width  = max;
                        } else {
                            r.height = max;
                        }
                    }

                    if (b) {
                        this.tabAreaWidth   = max + this.sideSpace;
                        this.tabAreaHeight += (2 * this.sideSpace);
                        this.repaintHeight  = this.tabAreaHeight;
                        this.repaintWidth   = this.tabAreaWidth + (this.border !== null ? (this.orient === &quot;left&quot; ? this.border.getLeft()
                                                                                                                  : this.border.getRight())
                                                                                        : 0);
                    } else {
                        this.tabAreaWidth += (2 * this.sideSpace);
                        this.tabAreaHeight = this.sideSpace + max;
                        this.repaintWidth  = this.tabAreaWidth;
                        this.repaintHeight = this.tabAreaHeight + (this.border !== null ? (this.orient === &quot;top&quot; ? this.border.getTop()
                                                                                                                 : this.border.getBottom())
                                                                                        : 0);
                    }

                    // make selected tab page title bigger
                    if (this.selectedIndex &gt;= 0) {
                        r = this.getTabBounds(this.selectedIndex);
                        if (b) {
                            r.height += 2 * this.sideSpace;
                            r.width += this.sideSpace +  (this.border !== null ? (this.orient === &quot;left&quot; ? this.border.getLeft()
                                                                                                         : this.border.getRight())
                                                                               : 0);
                        } else {
                            r.height += this.sideSpace + (this.border !== null ? (this.orient === &quot;top&quot; ? this.border.getTop()
                                                                                                        : this.border.getBottom())
                                                                               : 0);
                            r.width += 2 * this.sideSpace;
                        }
                    }
                }
            };

            /**
             * Get tab index located at the given location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {Integer} an index of the tab that is
             * detected at the given location. -1 if no any
             * tab can be found
             * @method getTabAt
             */
            this.getTabAt = function(x,y){
                this.validate();
                if (x &gt;= this.tabAreaX &amp;&amp; y &gt;= this.tabAreaY &amp;&amp;
                    x &lt; this.tabAreaX + this.tabAreaWidth    &amp;&amp;
                    y &lt; this.tabAreaY + this.tabAreaHeight     )
                {
                    var tb = null;

                    // handle selected as a special case since it can overlap neighborhood titles
                    if (this.selectedIndex &gt;= 0) {
                        tb = this.getTabBounds(this.selectedIndex);
                        if (x &gt;= tb.x &amp;&amp; y &gt;= tb.y &amp;&amp; x &lt; tb.x + tb.width &amp;&amp; y &lt; tb.y + tb.height) {
                            return this.selectedIndex;
                        }
                    }

                    for(var i = 0; i &lt; Math.floor(this.pages.length / 2); i++) {
                        if (this.selectedIndex !== i) {
                            tb = this.getTabBounds(i);
                            if (x &gt;= tb.x &amp;&amp; y &gt;= tb.y &amp;&amp; x &lt; tb.x + tb.width &amp;&amp; y &lt; tb.y + tb.height) {
                                return i;
                            }
                        }
                    }
                }
                return -1;
            };

            /**
             * Define key pressed event handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e){
                if (this.selectedIndex !== -1 &amp;&amp; this.pages.length &gt; 0){
                    var nxt = 0;
                    switch(e.code) {
                        case &quot;ArrowUp&quot;:
                        case &quot;ArrowLeft&quot;:
                            nxt = this.next(this.selectedIndex - 1,  -1);
                            if (nxt &gt;= 0) {
                                this.select(nxt);
                            }
                            break;
                        case &quot;ArrowDown&quot;:
                        case &quot;ArrowRight&quot;:
                            nxt = this.next(this.selectedIndex + 1, 1);
                            if (nxt &gt;= 0) {
                                this.select(nxt);
                            }
                            break;
                    }
                }
            };

            /**
             * Define pointer clicked  event handler
             * @param  {zebkit.ui.event.PointerEvent} e a key event
             * @method pointerClicked
             */
            this.pointerClicked = function(e){
                if (e.isAction()){
                    var index = this.getTabAt(e.x, e.y);
                    if (index &gt;= 0 &amp;&amp; this.isTabEnabled(index)) {
                        this.select(index);
                    }
                }
            };

            /**
             * Switch to the given tab page
             * @param  {Integer} index a tab page index to be navigated
             * @method select
             * @chainable
             */
            this.select = function(index){
                if (this.selectedIndex !== index){
                    var prev = this.selectedIndex;
                    this.selectedIndex = index;

                    if (prev &gt;= 0) {
                        this.pages[prev * 2].selected(this, prev, false);
                    }

                    if (index &gt;= 0) {
                        this.pages[index * 2].selected(this, index, true);
                    }

                    this._.fired(this, this.selectedIndex);
                    this.vrp();
                }

                return this;
            };

            /**
             * Get the given tab. Using the tab you can control tab caption,
             * icon.
             * @param {Integer} pageIndex a tab page index
             * @return  {zebkit.ui.Tabs.TabView}
             * @method getTab
             */
            this.getTab = function(pageIndex){
                return this.pages[pageIndex * 2];
            };

            /**
             * Set tab side spaces.
             * @param {Integer} sideSpace  [description]
             * @method setSideSpace
             * @chainable
             */
            this.setSideSpace = function(sideSpace){
                if (sideSpace !== this.sideSpace) {
                    this.sideSpace = sideSpace;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set tab page vertical and horizontal gaps
             * @param {Integer} vg a vertical gaps
             * @param {Integer} hg a horizontal gaps
             * @method setPageGaps
             * @chainable
             */
            this.setPageGaps = function (vg, hg){
                if (this.vgap !== vg || hg !== this.hgap){
                    this.vgap = vg;
                    this.hgap = hg;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the tab page element alignments
             * @param {String} o an alignment. The valid value is one of the following:
             * &quot;left&quot;, &quot;right&quot;, &quot;top&quot;, &quot;bottom&quot;
             * @method  setAlignment
             * @chainable
             */
            this.setAlignment = function(o){
                if (this.orient !== o) {
                    this.orient = zebkit.util.$validateValue(o, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;);
                    this.vrp();
                }
                return this;
            };

            /**
             * Set enabled state for the given tab page
             * @param  {Integer} i a tab page index
             * @param  {Boolean} b a tab page enabled state
             * @method enableTab
             * @chainable
             */
            this.enableTab = function(i,b){
                var c = this.kids[i];
                if (c.isEnabled !== b){
                    c.setEnabled(b);
                    if (b === false &amp;&amp; this.selectedIndex === i) {
                        this.select(-1);
                    }
                    this.repaint();
                }
                return this;
            };

            /**
             *  Set number of views to render different Tab component elements
             *  @param {Object} a set of views as dictionary where key is a view
             *  name and the value is a view instance, string(for color), or render
             *  function. The following view elements can be passed:
             *
             *
             *      {
             *         &quot;out&quot;       : &lt;view to render not selected tab page&gt;,
             *         &quot;over&quot;      : &lt;view to render a tab page when pointer is over&gt;
             *         &quot;selected&quot;  : &lt;a view to render selected tab page&gt;
             *         &quot;marker&quot;    : &lt;a marker view to be rendered around tab page title&gt;
             *      }
             *
             *
             *  @method  setViews
             */
        },

        function focused(){
            this.$super();
            if (this.selectedIndex &gt;= 0){
                var r = this.getTabBounds(this.selectedIndex);
                this.repaint(r.x, r.y, r.width, r.height);
            } else if (this.hasFocus() === false) {
                this.select(this.next(0, 1));
            }
        },

        function kidAdded(index,constr,c) {
            // correct wrong selection if inserted tab index is less or equals
            if (this.selectedIndex &gt;= 0 &amp;&amp; index &lt;= this.selectedIndex) {
                this.selectedIndex++;
            }

            if (this.selectedIndex &lt; 0) {
                this.select(this.next(0, 1));
            }

            return this.$super(index, constr, c);
        },

        function insert(index, constr, c) {
            var render = null;
            if (zebkit.instanceOf(constr, this.clazz.TabView)) {
                render = constr;
            } else {
                render = new this.clazz.TabView((constr === null ? &quot;Page &quot; + index
                                                                 : constr ));
                render.ownerChanged(this); // TODO: a little bit ugly but setting an owner is required to
                                           // keep tabs component informed when an icon has been updated
            }

            this.pages.splice(index * 2, 0, render, { x:0, y:0, width:0, height:0 });

            var r = this.$super(index, constr, c);
            // since we have added new page the repainting area is wider than
            // the added component (tab elements), so repaint the whole tab
            // component
            this.repaint();
            return r;
        },

        function removeAt(i){
            if (this.selectedIndex &gt;= 0 &amp;&amp; i &lt;= this.selectedIndex) {
                if (i === this.selectedIndex) {
                    this.select(-1);
                } else {
                    this.selectedIndex--;
                    this.repaint();
                }
            }
            this.pages.splice(i * 2, 2);
            return this.$super(i);
        },

        function removeAll(){
            this.select(-1);
            this.pages.splice(0, this.pages.length);
            this.pages.length = 0;
            this.$super();
        },

        function setSize(w,h){
            if (this.width !== w || this.height !== h) {
                if (this.orient === &quot;right&quot; || this.orient === &quot;bottom&quot;) {
                    this.tabAreaX = -1;
                }
                this.$super(w, h);
            }
            return this;
        }
    ]);


    /**
     * Text field UI component. The component is designed to enter single line, multi lines or password text.
     * The component implement text field functionality from the scratch. It supports the following features
     *
     *   - Text selection
     *   - Redu/Undo actions
     *   - Native WEB clipboard
     *   - Basic text navigation
     *   - Read-only mode
     *   - Left or right text alignment
     *
     * @constructor
     * @param {String|zebkit.data.TextModel|zebkit.draw.TextRender} [txt] a text the text field component
     * has to be filled. The parameter can be a simple string, text model or text render class instance.
     * @param {Integer} [maxCol] a maximal size of entered text. -1 means the size of the edited text
     * has no length limit.
     * @class zebkit.ui.TextField
     * @extends zebkit.ui.Label
     */
    pkg.TextField = Class(pkg.Label, [
        function (render, maxCol){
            this.$history = Array(100);

            this.scrollManager = new pkg.ScrollManager(this);

            var renderDefined = false;
            if (arguments.length === 0) {
                maxCol = -1;
                render = new zebkit.draw.TextRender(new zebkit.data.SingleLineTxt());
                renderDefined = true;
            } else {
                if (arguments.length === 1) {
                    if (zebkit.isNumber(render)) {
                        maxCol = render;
                        render = new zebkit.draw.TextRender(new zebkit.data.SingleLineTxt());
                        renderDefined = true;
                    } else {
                        maxCol = -1;
                    }
                }
            }

            if (renderDefined === false) {
                if (zebkit.isString(render)) {
                    render = new zebkit.draw.TextRender(new zebkit.data.SingleLineTxt(render));
                } else if (zebkit.instanceOf(render, zebkit.data.TextModel)) {
                    render = new zebkit.draw.TextRender(render);
                }
            }

            this.$super(render);
            if (maxCol &gt; 0) {
                this.setPSByRowsCols(-1, maxCol);
            }
        },

        function $clazz() {
            /**
             * Text field hint text render
             * @constructor
             * @class zebkit.ui.TextField.HintRender
             * @extends zebkit.draw.StringRender
             */
            this.HintRender = Class(zebkit.draw.StringRender, []);
        },

        /**
         * @for zebkit.ui.TextField
         */
        function $prototype() {
            this.$historyPos  = -1;
            this.$lineHeight  = 0;
            this.$redoCounter = 0;
            this.$undoCounter = 0;
            this.$blinkTask   = null;

            /**
             * Cursor x loacation
             * @attribute cursorX
             * @type {Integer}
             * @readOnly
             */
            this.cursorX = 0;

            /**
             * Cursor y loacation
             * @attribute cursorY
             * @type {Integer}
             * @readOnly
             */
            this.cursorY = 0;

            /**
             * Cursor width
             * @attribute cursorWidth
             * @type {Integer}
             * @readOnly
             */
            this.cursorWidth = 0;

            /**
             * Cursor height
             * @attribute cursorHeight
             * @type {Integer}
             * @readOnly
             */
            this.cursorHeight = 0;

            /**
             * Selection view.
             * @attribute selectView
             * @type {zebkit.draw.View|String}
             * @readOnly
             */
            this.selectView = null;

            /**
             * Hint view
             * @attribute hint
             * @type {zebkit.draw.View}
             * @readOnly
             */
            this.hint = null;


            // TODO: check the place the property is required
            this.vkMode = &quot;indirect&quot;;

            this.startLine = this.startCol = this.endLine = this.endCol = 0;
            this.startOff  = this.endOff = -1;

            /**
             * Cursor position manager
             * @attribute  position
             * @type {zebkit.util.Position}
             * @readOnly
             */
            this.position = null;

            /**
             * Specify the text field cursor blinking period in milliseconds.
             * -1 means no blinkable cursor
             * @type {Number}
             * @default -1
             * @readOnly
             * @attribute blinkigPeriod
             */
            this.blinkingPeriod = -1;
            this.$blinkMe        = true;
            this.$blinkMeCounter = 0;

            /**
             * Cursor type
             * @attribute cursorType
             * @type {String}
             * @default zebkit.ui.Cursor.TEXT;
             */
            this.cursorType = pkg.Cursor.TEXT;

            /**
             * Text alignment
             * @attribute textAlign
             * @type {String}
             * @default &quot;left&quot;
             * @readOnly
             */
            this.textAlign = &quot;left&quot;;

            /**
             * Cursor view
             * @attribute cursorView
             * @type {zebkit.draw.View}
             * @readOnly
             */
            this.cursorView = null;

            /**
             * Indicate if the text field is editable
             * @attribute  isEditable
             * @type {Boolean}
             * @default true
             * @readOnly
             */
            this.canHaveFocus = this.isEditable = true;

            /**
             * Set the specified blinking period of the text field cursor
             * @param {Integer} [period] a text field cursor blinking period (in milliseconds),
             * use -1 to disable cursor blinking. If the argument is not passed the default (500ms)
             * blinking period will be applied.
             * @method setBlinking
             * @chainable
             */
            this.setBlinking = function(period) {
                if (arguments.length === 0) {
                    period = 500;
                }

                if (period !== this.blinkingPeriod) {
                    this.blinkingPeriod = period;
                    this.repaintCursor();
                }
                return this;
            };

            /**
             * Set the text algnment.
             * @method setTextAlignment
             * @param {String} a a text alignment. Use &quot;left&quot; or &quot;right&quot; as the parameter value
             * @chainable
             */
            this.setTextAlignment = function(a) {
                if (this.textAlign !== a) {
                    this.textAlign = a;
                    this.vrp();
                }
                return this;
            };

            this.textUpdated = function(src, b, off, size, startLine, lines) {
                if (this.position !== null) {
                    if (b === true) {
                        // Check if a selection presents
                        // and clear it.  We do it here because it is important
                        // to remove any selected text after update since:
                        //   -- not every update brings to real text update, so we have remove selected text
                        //      only if real text update has happened
                        //   -- update can make selection start and end location invalid, so we have to take in
                        //      account before we remove it
                        if (this.startOff !== this.endOff) {
                            var start = this.startOff &lt; this.endOff ? this.startOff : this.endOff,
                                end   = this.startOff &gt; this.endOff ? this.startOff : this.endOff;

                            // if start of selection is less or equals
                            // to inserted text offset than we have to correct
                            // insertion area start and end offsets
                            if (off &lt;= start) {
                                start += size;
                                end += size;
                            } else {
                                // if offset of an inserted text if greater than start of
                                // a selection but less or equals to end of the selection
                                // we have to correct insertion offset to start (since the
                                // selected text is going to be removed)
                                if (off &lt;= end) {
                                    if (off &lt; end) {
                                        end += size;
                                    }
                                    off = start;
                                }
                            }

                            //this.endOff = this.startOff = -1; // clear selection
                            this.remove(start, end - start);
                        }

                        this.endOff = this.startOff = -1; // clear selection
                        this.position.inserted(off, size);
                    } else {
                        this.position.removed(off, size);
                    }
                }
            };

            /**
             * Compute a text column and row by the given location.
             * @param  {Integer} x  a x coordinate
             * @param  {Integer} y  a y coordinate
             * @return {Object} a text row and column as an object { row:, col }.
             * @method  getTextRowColAt
             */
            this.getTextRowColAt = function(x, y) {
                var lines = this.getLines();

                // normalize text location to virtual (zero, zero)
                y -= (this.scrollManager.getSY() + this.getTop());
                x -= this.scrollManager.getSX();
                if (this.textAlign === &quot;left&quot;) {
                    x -= this.getLeft();
                } else {
                    x -= (this.width - this.view.getPreferredSize().width - this.getRight());
                }

                if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; lines &gt; 0) {
                    var lh = this.view.getLineHeight(),
                        li = this.view.lineIndent,
                        row = (y &lt; 0) ? 0 : Math.floor((y + li) / (lh + li)) + ((y + li) % (lh + li) &gt; li ? 1 : 0) -1;

                    if (row &lt; lines &amp;&amp; row &gt;= 0) {
                        var s    = this.view.getLine(row),
                            pdt  = 1000000,
                            pcol = -1;

                        for(var col = Math.floor((x / this.view.calcLineWidth(row)) * s.length); col &gt;= 0 &amp;&amp; col &lt;= s.length;) {
                            var l  = this.view.font.charsWidth(s, 0, col),
                                dt = Math.abs(l - x);

                            if (dt &gt;= pdt) {
                                return { row : row, col : pcol };
                            }

                            pdt  = dt;
                            pcol = col;
                            col += (l &gt; x ? -1: 1);
                        }

                        return { row : row, col : s.length };
                    }
                }
                return null;
            };

            /**
             * Find the next or previous word in the given text model starting from the given
             * line and column.
             * @param  {zebkit.data.TextModel} t a text model
             * @param  {Integer} line a starting line
             * @param  {Integer} col a starting column
             * @param  {Integer} d   a direction. 1 means looking for a next word and -1 means
             * search for a previous word.
             * @return {Object} a structure with the next or previous word location:
             *
             *        { row: {Integer}, col: {Integer} }
             *
             *
             * The method returns null if the next or previous word cannot be found.
             * @method  findNextWord
             * @protected
             */
            this.findNextWord = function(t, line, col, d){
                if (line &lt; 0 || line &gt;= t.getLines()) {
                    return null;
                }

                var ln = t.getLine(line);
                col += d;
                if (col &lt; 0 &amp;&amp; line &gt; 0) {
                    return { row: line - 1, col : t.getLine(line - 1).length };
                } else if (col &gt; ln.length &amp;&amp; line &lt; t.getLines() - 1) {
                    return { row : line + 1, col : 0 };
                }

                var b = false;
                for(; col &gt;= 0 &amp;&amp; col &lt; ln.length; col += d){
                    if (b) {
                        if (d &gt; 0) {
                            if (zebkit.util.isLetter(ln[col])) {
                                return { row:line, col:col };
                            }
                        } else {
                            if (!zebkit.util.isLetter(ln[col])) {
                                return { row : line, col: col + 1 };
                            }
                        }
                    } else  {
                        b = d &gt; 0 ? !zebkit.util.isLetter(ln[col]) : zebkit.util.isLetter(ln[col]);
                    }
                }
                return (d &gt; 0 ? { row: line, col : ln.length }: { row : line, col : 0 } );
            };

            // collect text model lines into string by the given start and end offsets
            // r     - text view
            // start - start offset
            // end   - end offset
            this.getSubString = function(r, start, end){
                var res = [],
                    sr = start.row,
                    er = end.row;

                for(var i = sr; i &lt; er + 1; i++){
                    var ln = r.getLine(i);
                    if (i !== sr) {
                        res.push(&#x27;\n&#x27;);
                    } else {
                        ln = ln.substring(start.col);
                    }

                    if (i === er) {
                        ln = ln.substring(0, end.col - ((sr === er) ? start.col : 0));
                    }
                    res.push(ln);
                }
                return res.join(&#x27;&#x27;);
            };

            /**
             * Remove selected text
             * @method removeSelected
             * @chainable
             */
            this.removeSelected = function(){
                if (this.hasSelection()){
                    var start = this.startOff &lt; this.endOff ? this.startOff : this.endOff;
                    this.remove(start, (this.startOff &gt; this.endOff ? this.startOff : this.endOff) - start);
                    this.clearSelection();
                }
                return this;
            };

            /**
             * Start selection.
             * @protected
             * @method  startSelection
             * @chainable
             */
            this.startSelection = function() {
                if (this.startOff &lt; 0 &amp;&amp; this.position !== null){
                    var pos = this.position;
                    this.endLine = this.startLine = pos.currentLine;
                    this.endCol = this.startCol = pos.currentCol;
                    this.endOff = this.startOff = pos.offset;
                }
                return this;
            };

            this.keyTyped = function(e) {
                if (this.isEditable === true &amp;&amp;
                    e.ctrlKey === false &amp;&amp;
                    e.metaKey === false &amp;&amp;
                    e.key !== &#x27;\t&#x27;)
                {
                    this.write(this.position.offset, e.key);
                }
            };

            /**
             * Select all text.
             * @method  selectAll
             * @chainable
             */
            this.selectAll = function() {
                this.select(0, this.getMaxOffset());
                return this;
            };

            /**
             * Shortcut event handler
             * @param  {java.ui.event.ShortcutEvent} e a shortcut event
             * @method shortcutFired
             */
            this.shortcutFired = function(e) {
                if (e.shortcut === &quot;SELECTALL&quot;) {
                    this.selectAll();
                } else {
                    var d  = (e.shortcut === &quot;PREVWORDSELECT&quot; || e.shortcut === &quot;PREVWORD&quot;) ? -1 : 1;

                    if (e.shortcut === &quot;PREVWORDSELECT&quot; ||
                        e.shortcut === &quot;NEXTWORDSELECT&quot; ||
                        e.shortcut === &quot;NEXTPAGESELECT&quot; ||
                        e.shortcut === &quot;PREVPAGESELECT&quot;   )
                    {
                        this.startSelection();
                    }

                    switch (e.shortcut) {
                        case &quot;UNDO&quot;          : this.undo(); break;
                        case &quot;REDO&quot;          : this.redo(); break;
                        case &quot;NEXTPAGESELECT&quot;:
                        case &quot;NEXTPAGE&quot;      :  this.position.seekLineTo(&quot;down&quot;, this.pageSize()); break;
                        case &quot;PREVPAGESELECT&quot;:
                        case &quot;PREVPAGE&quot;      :  this.position.seekLineTo(&quot;up&quot;, this.pageSize()); break;
                        case &quot;NEXTWORDSELECT&quot;:
                        case &quot;PREVWORDSELECT&quot;:
                        case &quot;PREVWORD&quot;:
                        case &quot;NEXTWORD&quot; : {
                            var p = this.findNextWord(this.view.target, this.position.currentLine,
                                                                        this.position.currentCol, d);
                            if (p !== null) {
                                this.position.setRowCol(p.row, p.col);
                            }
                        } break;
                    }
                }
            };

            this.keyPressed = function(e) {
                if (this.isFiltered(e) === false)  {
                    var position    = this.position;

                    if (e.shiftKey) {
                        this.startSelection();
                    }

                    switch(e.code) {
                        case &quot;ArrowDown&quot; : position.seekLineTo(&quot;down&quot;); break;
                        case &quot;ArrowUp&quot;   : position.seekLineTo(&quot;up&quot;); break;
                        case &quot;ArrowLeft&quot; :
                            if (e.ctrlKey === false &amp;&amp; e.metaKey === false) {
                                position.seek(-1);
                            }
                            break;
                        case &quot;ArrowRight&quot;:
                            if (e.ctrlKey === false &amp;&amp; e.metaKey === false) {
                                position.seek(1);
                            }
                            break;
                        case &quot;End&quot;:
                            if (e.ctrlKey) {
                                position.seekLineTo(&quot;down&quot;, this.getLines() - position.currentLine - 1);
                            } else {
                                position.seekLineTo(&quot;end&quot;);
                            }
                            break;
                        case &quot;Home&quot;:
                            if (e.ctrlKey) {
                                position.seekLineTo(&quot;up&quot;, position.currentLine);
                            } else {
                                position.seekLineTo(&quot;begin&quot;);
                            }
                            break;
                        case &quot;PageDown&quot; :
                            position.seekLineTo(&quot;down&quot;, this.pageSize());
                            break;
                        case &quot;PageUp&quot; :
                            position.seekLineTo(&quot;up&quot;, this.pageSize());
                            break;
                        case &quot;Delete&quot;:
                            if (this.hasSelection() &amp;&amp; this.isEditable === true) {
                                this.removeSelected();
                            } else {
                                if (this.isEditable === true) {
                                    this.remove(position.offset, 1);
                                }
                            } break;
                        case &quot;Backspace&quot;:
                            if (this.isEditable === true) {
                                if (this.hasSelection()) {
                                    this.removeSelected();
                                } else {
                                    if (this.isEditable === true &amp;&amp; position.offset &gt; 0){
                                        position.seek(-1);
                                        this.remove(position.offset, 1);
                                    }
                                }
                            } break;
                        default: return ;
                    }

                    if (e.shiftKey === false) {
                        this.clearSelection();
                    }
                }
            };

            /**
             * Test if the given key pressed event has to be processed
             * @protected
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @return {Boolean} true if the given key pressed event doesn&#x27;t
             * have be processed
             * @method isFiltered
             */
            this.isFiltered = function(e){
                var code = e.code;
                return code === &quot;Shift&quot; || code === &quot;Control&quot; ||
                       code === &quot;Tab&quot;   || code === &quot;Alt&quot;     ||
                       e.altKey;
            };

            /**
             * Remove the specified part of edited text
             * @param  {Integer} pos a start position of a removed text
             * @param  {Integer} size a size of removed text
             * @method remove
             */
            this.remove = function (pos,size){
                if (this.isEditable === true) {
                    if (pos &gt;= 0 &amp;&amp; (pos + size) &lt;= this.getMaxOffset()) {
                        if (size &lt; 10000) {
                            this.$historyPos = (this.$historyPos + 1) % this.$history.length;
                            this.$history[this.$historyPos] = [-1, pos, this.getValue().substring(pos, pos+size)];
                            if (this.$undoCounter &lt; this.$history.length) {
                                this.$undoCounter++;
                            }
                        }

                        if (this.view.target.remove(pos, size)) {
                            this.repaint();
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
             * Insert the specified text into the edited text at the given position
             * @param  {Integer} pos a start position of a removed text
             * @param  {String} s a text to be inserted
             * @return {Boolean} true if repaint has been requested
             * @method write
             */
            this.write = function (pos,s) {
                if (this.isEditable === true) {
                    // TODO: remove hard coded undo/redo deepness value
                    if (s.length &lt; 10000) {
                        this.$historyPos = (this.$historyPos + 1) % this.$history.length;
                        this.$history[this.$historyPos] = [1, pos, s.length];
                        if (this.$undoCounter &lt; this.$history.length) {
                            this.$undoCounter++;
                        }
                    }

                    if (this.view.target.write(s, pos)) {
                        this.repaint();
                        return true;
                    }
                }
                return false;
            };

            this.recalc = function() {
                var r = this.view;
                if (this.position.offset &gt;= 0) {
                    var l = r.getLine(this.position.currentLine);
                    if (this.textAlign === &quot;left&quot;) {
                        this.curX = r.font.charsWidth(l, 0, this.position.currentCol) + this.getLeft();
                    } else {
                        this.curX = this.width - this.getRight() - this.view.getPreferredSize().width +
                                    r.font.charsWidth(l, 0, this.position.currentCol);
                    }

                    this.curY = this.position.currentLine * (r.getLineHeight() + r.lineIndent) +
                                this.getTop();
                }

                this.$lineHeight = r.getLineHeight() - 1;
            };

            this.catchScrolled = function(psx, psy) {
                this.repaint();
            };

            /**
             * Draw the text field cursor.
             * @protected
             * @param  {CanvasRenderingContext2D} g a 2D context
             * @method drawCursor
             */
            this.drawCursor = function (g) {
                if (this.position.offset &gt;= 0 &amp;&amp;
                    this.cursorView !== null  &amp;&amp;
                    this.$blinkMe             &amp;&amp;
                    this.hasFocus()              )
                {
                    if (this.textAlign === &quot;left&quot;) {
                        this.cursorView.paint(g, this.curX, this.curY,
                                              this.cursorWidth,
                                              (this.cursorHeight === 0 ? this.$lineHeight : this.cursorHeight),
                                              this);
                    } else {
                        this.cursorView.paint(g, this.curX - this.cursorWidth, this.curY,
                                              this.cursorWidth,
                                              (this.cursorHeight === 0 ? this.$lineHeight : this.cursorHeight),
                                              this);
                    }
                }
            };

            this.pointerDragStarted = function (e){
                if (e.isAction() &amp;&amp; this.getMaxOffset() &gt; 0) {
                    this.startSelection();
                }
            };

            this.pointerDragEnded =function (e){
                if (e.isAction() &amp;&amp; this.hasSelection() === false) {
                    this.clearSelection();
                }
            };

            this.pointerDragged = function (e){
                if (e.isAction()){
                    var p = this.getTextRowColAt(e.x, e.y);
                    if (p !== null) {
                        this.position.setRowCol(p.row, p.col);
                    }
                }
            };

            /**
             * Select the specified part of the edited text
             * @param  {Integer} startOffset a start position of a selected text
             * @param  {Integer} endOffset  an end position of a selected text
             * @method select
             * @chainable
             */
            this.select = function (startOffset, endOffset){
                if (endOffset &lt; startOffset ||
                    startOffset &lt; 0 ||
                    endOffset &gt; this.getMaxOffset())
                {
                    throw new Error(&quot;Invalid selection offsets&quot;);
                }

                if (this.startOff !== startOffset || endOffset !== this.endOff) {
                    if (startOffset === endOffset) {
                        this.clearSelection();
                    } else {
                        this.startOff = startOffset;
                        var p = this.position.getPointByOffset(startOffset);
                        this.startLine = p[0];
                        this.startCol  = p[1];
                        this.endOff    = endOffset;
                        p = this.position.getPointByOffset(endOffset);
                        this.endLine = p[0];
                        this.endCol = p[1];
                        this.repaint();
                    }
                }

                return this;
            };

            /**
             * Tests if the text field has a selected text
             * @return {Boolean} true if the text field has a selected text
             * @method hasSelection
             */
            this.hasSelection = function () {
                return this.startOff !== this.endOff;
            };

            this.posChanged = function (target, po, pl, pc){
                this.recalc();
                var position = this.position;
                if (position.offset &gt;= 0) {

                    this.$blinkMeCounter = 0;
                    this.$blinkMe = true;

                    var lineHeight = this.view.getLineHeight(),
                        top        = this.getTop();

                    this.scrollManager.makeVisible(this.textAlign === &quot;left&quot; ? this.curX
                                                                             : this.curX - this.cursorWidth,
                                                    this.curY, this.cursorWidth, lineHeight);

                    if (pl &gt;= 0) {
                        // means selected text exists, than we have to correct selection
                        // according to the new position
                        if (this.startOff &gt;= 0){
                            this.endLine = position.currentLine;
                            this.endCol  = position.currentCol;
                            this.endOff  = position.offset;
                        }

                        var minUpdatedLine = pl &lt; position.currentLine ? pl : position.currentLine,
                            li             = this.view.lineIndent,
                            bottom         = this.getBottom(),
                            left           = this.getLeft(),
                            y1             = lineHeight * minUpdatedLine + minUpdatedLine * li +
                                             top + this.scrollManager.getSY();

                        if (y1 &lt; top) {
                            y1 = top;
                        }

                        if (y1 &lt; this.height - bottom){
                            var h = ((pl &gt; position.currentLine ? pl
                                                                : position.currentLine) - minUpdatedLine + 1) * (lineHeight + li);
                            if (y1 + h &gt; this.height - bottom) {
                                h = this.height - bottom - y1;
                            }
                            this.repaint(left, y1, this.width - left - this.getRight(), h);
                        }
                    } else {
                        this.repaint();
                    }
                }
            };

            this.paintOnTop = function(g) {
                if (this.hint !== null &amp;&amp; this.getMaxOffset() === 0) {
                    var ps = this.hint.getPreferredSize(),
                        yy = Math.floor((this.height - ps.height)/2),
                        xx = (&quot;left&quot; === this.textAlign) ? this.getLeft() + this.cursorWidth
                                                         : this.width - ps.width - this.getRight() - this.cursorWidth;

                    this.hint.paint(g, xx, yy, this.width, this.height, this);
                }
            };

            /**
             * Set the specified hint text to be drawn with the given font and color.
             * The hint is not-editable text that is shown in empty text field to help
             * a user to understand which input the text field expects.
             * @param {String|zebkit.draw.View|Function} hint a hint text, view or view render method
             * @method setHint
             * @chainable
             */
            this.setHint = function(hint) {
                if (this.hint !== hint) {
                    this.hint = zebkit.isString(hint) ? new this.clazz.HintRender(hint)
                                                      : zebkit.draw.$view(hint);
                    this.repaint();
                }
                return this;
            };

            /**
             * Performs undo operation
             * @method undo
             * @chainable
             */
            this.undo = function() {
                if (this.$undoCounter &gt; 0) {
                    var h = this.$history[this.$historyPos];

                    this.$historyPos--;
                    if (h[0] === 1) {
                        this.remove(h[1], h[2]);
                    }
                    else {
                        this.write (h[1], h[2]);
                    }

                    this.$undoCounter -= 2;
                    this.$redoCounter++;

                    this.$historyPos--;
                    if (this.$historyPos &lt; 0) {
                        this.$historyPos = this.$history.length - 1;
                    }

                    this.repaint();
                }
                return this;
            };

            /**
             * Performs redo operation
             * @method redo
             * @chainable
             */
            this.redo = function() {
                if (this.$redoCounter &gt; 0) {
                    var h = this.$history[(this.$historyPos + 1) % this.$history.length];
                    if (h[0] === 1) {
                        this.remove(h[1], h[2]);
                    } else {
                        this.write (h[1], h[2]);
                    }
                    this.$redoCounter--;
                    this.repaint();
                }
                return this;
            };

            /**
             * Get a starting position (row and column) of a selected text
             * @return {Array} a position of a selected text. First element
             * of is a row and second column of selected text. null if
             * there is no any selected text
             * @method getStartSelection
             */
            this.getStartSelection = function(){
                return this.startOff !== this.endOff ? ((this.startOff &lt; this.endOff) ? { row: this.startLine, col: this.startCol }
                                                                                      : { row: this.endLine, col: this.endCol } )
                                                     : null;
            };

            /**
             * Get an ending position (row and column) of a selected text
             * @return {Array} a position of a selected text. First element
             * of is a row and second column of selected text. null if
             * there is no any selected text
             * @method getEndSelection
             */
            this.getEndSelection = function(){
                return this.startOff !== this.endOff ? ((this.startOff &lt; this.endOff) ? { row : this.endLine,   col : this.endCol   }
                                                                                      : { row : this.startLine, col : this.startCol })
                                                     : null;
            };

            /**
             * Get a selected text
             * @return {String} a selected text
             * @method getSelectedText
             */
            this.getSelectedText = function(){
                return this.startOff !== this.endOff ? this.getSubString(this.view,
                                                                         this.getStartSelection(),
                                                                         this.getEndSelection())
                                                     : null;
            };

            this.getLines = function() {
                return this.position === null ? -1 : this.position.metrics.getLines();
            };

            this.getMaxOffset = function() {
                return this.position === null ? -1 : this.position.metrics.getMaxOffset();
            };

            this.focusGained = function (e){
                if (this.position.offset &lt; 0) {
                    this.position.setOffset(this.textAlign === &quot;left&quot; || this.getLines() &gt; 1 ? 0
                                                                                             : this.getMaxOffset());
                } else if (this.hint !== null) {
                    this.repaint();
                } else {
                    this.repaintCursor();
                }

                if (this.isEditable === true &amp;&amp; this.blinkingPeriod &gt; 0) {
                    this.$blinkMeCounter = 0;
                    this.$blinkMe = true;

                    var $this = this;
                    this.$blinkTask = zebkit.util.tasksSet.run(function() {
                            $this.$blinkMeCounter = ($this.$blinkMeCounter + 1) % 3;
                            if ($this.$blinkMeCounter === 0) {
                                $this.$blinkMe = !$this.$blinkMe;
                                $this.repaintCursor();
                            }
                        },
                        Math.floor(this.blinkingPeriod / 3),
                        Math.floor(this.blinkingPeriod / 3)
                    );
                }
            };

            this.focusLost = function(e) {
                this.repaintCursor();
                if (this.isEditable === true) {
                    if (this.hint !== null) {
                        this.repaint();
                    }

                    if (this.blinkingPeriod &gt; 0) {
                        if (this.$blinkTask !== null) {
                            this.$blinkTask.shutdown();
                            this.$blinkTask = null;
                        }
                        this.$blinkMe = true;
                    }
                }
            };

            /**
             * Force text field cursor repainting.
             * @method repaintCursor
             * @protected
             */
            this.repaintCursor = function() {
                if (this.curX &gt; 0 &amp;&amp; this.cursorWidth &gt; 0 &amp;&amp; (this.cursorHeight &gt; 0 || this.$lineHeight &gt; 0)) {
                    this.repaint(this.curX + this.scrollManager.getSX(),
                                 this.curY + this.scrollManager.getSY(),
                                 this.cursorWidth,
                                 (this.cursorHeight === 0 ? this.$lineHeight : this.cursorHeight));
                }
            };

            /**
             * Clear a text selection.
             * @method clearSelection
             * @chainable
             */
            this.clearSelection = function() {
                if (this.startOff &gt;= 0){
                    var b = this.hasSelection();
                    this.endOff = this.startOff = -1;
                    this.startLine = this.startCol = -1;
                    this.endLine = this.endCol = -1;

                    if (b) {
                        this.repaint();
                    }
                }
                return this;
            };

            this.pageSize = function (){
                var height = this.height - this.getTop() - this.getBottom(),
                    indent = this.view.lineIndent,
                    textHeight = this.view.getLineHeight();

                return Math.round((height + indent) / (textHeight + indent)) +
                       (((height + indent) % (textHeight + indent) &gt; indent) ? 1 : 0);
            };

            this.clipPaste = function(txt){
                if (txt !== null) {
                    this.removeSelected();
                    this.write(this.position.offset, txt);
                }
            };

            this.clipCopy = function() {
                return this.getSelectedText();
            };

            /**
             * Cut selected text
             * @return {String} a text that has been selected and cut
             * @method  cut
             */
            this.cut = function() {
                var t = this.getSelectedText();
                if (this.isEditable === true) {
                    this.removeSelected();
                }
                return t;
            };

            /**
             * Set the specified cursor position controller
             * @param {zebkit.util.Position} p a position controller
             * @method setPosition
             * @chainable
             */
            this.setPosition = function (p){
                if (this.position !== p) {
                    if (this.position !== null) {
                        this.position.off(this);
                    }
                    this.position = p;
                    if (this.position !== null) {
                        this.position.on(this);
                    }
                    this.invalidate();
                }

                return this;
            };

            /**
             * Set the cursor view. The view defines rendering of the text field
             * cursor.
             * @param {zebkit.draw.View} v a cursor view
             * @method setCursorView
             * @chainable
             */
            this.setCursorView = function (v){
                if (v !== this.cursorView) {
                    this.cursorWidth = 1;
                    this.cursorView = zebkit.draw.$view(v);
                    if (this.cursorView !== null &amp;&amp; this.cursorWidth === 0) {
                        this.cursorWidth = this.cursorView.getPreferredSize().width;
                    }
                    this.vrp();
                }

                return this;
            };

            /**
             * Set cursor width.
             * @param {Integer} w a cursor width
             * @method setCursorWidth
             * @chainable
             */
            this.setCursorWidth = function(w) {
                if (w !== this.cursorWidth) {
                    this.cursorWidth = w;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set cursor size.
             * @param {Integer} w a cursor width
             * @param {Integer} h a cursor height
             * @method setCursorSize
             * @chainable
             */
            this.setCursorSize = function(w, h) {
                if (w !== this.cursorWidth || h !== this.cursorHeight) {
                    this.cursorWidth  = w;
                    this.cursorHeight = h;
                    this.vrp();
                }
                return this;
            };

            /**
             * Adjust the size of the text field component to be enough to place the given
             * number of rows and columns.
             * @param {Integer} r a row of the text the height of the text field has to be adjusted
             * @param {Integer} c a column of the text the width of the text field has to be adjusted
             * @method setPSByRowsCols
             * @chainable
             */
            this.setPSByRowsCols = function (r,c){
                var tr = this.view,
                    w  = (c &gt; 0) ? (tr.font.stringWidth(&quot;W&quot;) * c)
                                 : this.psWidth,
                    h  = (r &gt; 0) ? (r * tr.getLineHeight() + (r - 1) * tr.lineIndent)
                                 : this.psHeight;
                this.setPreferredSize(w, h);
                return this;
            };

            /**
             * Control the text field editable state
             * @param {Boolean} b true to make the text field editable
             * @method setEditable
             * @chainable
             */
            this.setEditable = function (b){
                if (b !== this.isEditable){
                    this.isEditable = b;
                    if (b &amp;&amp; this.blinkingPeriod &gt; 0 &amp;&amp; this.hasFocus()) {
                        if (this.$blinkTask !== null) {
                            this.$blinkTask.shutdown();
                        }
                        this.$blinkMe = true;
                    }
                    this.vrp();
                }
                return this;
            };

            this.pointerDoubleClicked = function(e){
                if (e.isAction()) {
                    this.select(0, this.getMaxOffset());
                }
            };

            this.pointerPressed = function(e){
                if (e.isAction()) {
                    if (e.shiftKey) {
                        this.startSelection();
                    } else {
                        this.clearSelection();
                    }

                    var p = this.getTextRowColAt(e.x, e.y);
                    if (p !== null) {
                        this.position.setRowCol(p.row, p.col);
                    }
                }
            };

            /**
             * Set selection color or view
             * @param {String|zebkit.draw.View} c a selection color or view
             * @method setSelectView
             * @chainable
             */
            this.setSelectView = function(c) {
                if (c != this.selectView) {
                    this.selectView = zebkit.draw.$view(c);

                    if (this.hasSelection()) {
                        this.repaint();
                    }
                }
                return this;
            };

            this.calcPreferredSize = function (t) {
                var ps = this.view.getPreferredSize();
                ps.width += this.cursorWidth;
                return ps;
            };

            //!!! to maximize optimize performance the method duplicates part of ViewPan.paint() code
            this.paint = function(g){
                var sx = this.scrollManager.getSX(),
                    sy = this.scrollManager.getSY(),
                    l  = this.getLeft(),
                    t  = this.getTop(),
                    r  = this.getRight();

                try {
                    g.translate(sx, sy);

                    if (this.textAlign === &quot;left&quot;) {
                        this.view.paint(g, l, t,
                                        this.width  - l - r,
                                        this.height - t - this.getBottom(), this);
                    } else {
                        this.view.paint(g, this.width - r - this.view.getPreferredSize().width, t,
                                           this.width  - l - r,
                                           this.height - t - this.getBottom(), this);
                    }

                    this.drawCursor(g);
                } catch(e) {
                    g.translate(-sx, -sy);
                    throw e;
                }
                g.translate(-sx, -sy);
            };
        },

        function setView(v){
            if (v != this.view) {
                if (this.view !== null &amp;&amp; this.view.target !== null &amp;&amp; typeof this.view.target.on !== &#x27;undefined&#x27;) {
                    this.view.target.off(this);
                }

                this.$super(v);
                if (this.position === null) {
                    this.setPosition(new zebkit.util.Position(this.view));
                } else {
                    this.position.setMetric(this.view);
                }

                if (this.view !== null &amp;&amp; this.view.target !== null &amp;&amp; typeof this.view.target.on !== &#x27;undefined&#x27;) {
                    this.view.target.on(this);
                }
            }
            return this;
        },

        /**
         * Set the text content of the text field component
         * @param {String} s a text the text field component has to be filled
         * @method setValue
         * @chainable
         */
        function setValue(s) {
            var txt = this.getValue();
            if (txt !== s){
                if (this.position !== null) {
                    this.position.setOffset(0);
                }
                this.scrollManager.scrollTo(0, 0);
                this.$super(s);
            }
            return this;
        },

        function setEnabled(b){
            this.clearSelection();
            this.$super(b);
            return this;
        }
    ]);

    /**
     * Text area UI component. The UI component to render multi-lines text.
     * @class zebkit.ui.TextArea
     * @constructor
     * @param {String} [txt] a text
     * @extends zebkit.ui.TextField
     */
    pkg.TextArea = Class(pkg.TextField, [
        function(txt) {
            if (arguments.length === 0) {
                txt = &quot;&quot;;
            }
            this.$super(new zebkit.data.Text(txt));
        }
    ]);

    /**
     * Password text field.
     * @class zebkit.ui.PassTextField
     * @constructor
     * @param {String} txt password text
     * @param {Integer} [maxSize] maximal size
     * @param {Boolean} [showLast] indicates if last typed character should
     * not be disguised with a star character
     * @extends zebkit.ui.TextField
     */
    pkg.PassTextField = Class(pkg.TextField, [
        function(txt, size, showLast) {
            if (arguments.length === 1) {
                showLast = false;
                size     = -1;

                if (zebkit.isBoolean(txt)) {
                    showLast = txt;
                    txt      = &quot;&quot;;
                } else if (zebkit.isNumber(txt)) {
                    size = txt;
                    txt = &quot;&quot;;
                }
            } else if (arguments.length === 0) {
                showLast = false;
                size     = -1;
                txt      = &quot;&quot;;
            } else if (arguments.length === 2) {
                showLast = false;
            }

            var pt = new zebkit.draw.PasswordText(new zebkit.data.SingleLineTxt(txt, size));
            pt.showLast = showLast;
            this.$super(pt);
            if (size &gt; 0) {
                this.setPSByRowsCols(-1, size);
            }
        },

        function $prototype() {
            /**
             * Set flag that indicates if the last password character has to be visible.
             * @param {Boolean} b a boolean flag that says if last password character has
             * to be visible.
             * @method setShowLast
             * @chainable
             */
            this.setShowLast = function(b) {
                if (this.showLast !== b) {
                    this.view.showLast = b;
                    this.repaint();
                }
                return this;
            };
        }
    ]);


    /**
     * Base UI list component class that has to be extended with a
     * concrete list component implementation. The list component
     * visualizes list data model (zebkit.data.ListModel).
     * @class  zebkit.ui.BaseList
     * @constructor
     * @param {zebkit.data.ListModel|Array} [m] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [b] true if the list navigation has to be triggered by
     * pointer cursor moving
     * @extends zebkit.ui.Panel
     * @uses zebkit.util.Position.Metric
     * @uses zebkit.ui.DecorationViews
     */

    /**
     * Fire when a list item has been selected:
     *
     *     list.on(&quot;selected&quot;, function(src, prev) {
     *         ...
     *     });
     *
     * @event selected
     * @param {zebkit.ui.BaseList} src a list that triggers the event
     * @param {Integer|Object} prev a previous selected index, return null if the selected item has been re-selected
     */
    pkg.BaseList = Class(pkg.Panel, zebkit.util.Position.Metric, pkg.DecorationViews, [
        function (m, b) {
            if (arguments.length === 0) {
                m = [];
                b = false;
            } else if (arguments.length === 1) {
                if (zebkit.isBoolean(m))  {
                    b = m;
                    m = [];
                } else {
                    b = false;
                }
            } else if (m === null) {
                m = [];
            }

            /**
             * Currently selected list item index
             * @type {Integer}
             * @attribute selectedIndex
             * @default -1
             * @readOnly
             */
            this.selectedIndex = -1;

            this._ = new this.clazz.Listeners();

            /**
             * Indicate the current mode the list items selection has to work
             * @readOnly
             * @default false
             * @attribute isComboMode
             * @type {Boolean}
             */
            this.isComboMode = b;

            /**
             * Scroll manager
             * @attribute scrollManager
             * @readOnly
             * @protected
             * @type {zebkit.ui.ScrollManager}
             */
            this.scrollManager = new pkg.ScrollManager(this);

            this.$super();

            // position manager should be set before model initialization
            this.setPosition(new zebkit.util.Position(this));

            /**
             * List model
             * @readOnly
             * @attribute model
             */
            this.setModel(m);
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;selected&quot;);
        },

        function $prototype() {
            this.scrollManager = null;


            this.canHaveFocus = true;

            /**
             * List model the component visualizes
             * @attribute model
             * @type {zebkit.data.ListModel}
             * @readOnly
             */
            this.model = null;

            /**
             * Position manager.
             * @attribute position
             * @type {zebkit.util.Position}
             * @readOnly
             */
            this.position = null;

            /**
             * Select the specified list item.
             * @param {Object} v a list item to be selected. Use null as
             * the parameter value to clean an item selection
             * @return {Integer} an index of a selected item
             * @method setValue
             */
            this.setValue = function(v) {
                if (v === null) {
                    this.select(-1);
                } else if (this.model !== null) {
                    for(var i = 0; i &lt; this.model.count(); i++) {
                        if (this.model.get(i) === v &amp;&amp; this.isItemSelectable(i)) {
                            this.select(i);
                            return i;
                        }
                    }
                }
                return -1;
            };

            /**
             * Get the list component selected item
             * @return {Object} a selected item
             * @method getValue
             */
            this.getValue = function() {
                return this.getSelected();
            };

            /**
             * Test if the given item is selectable.
             * @param  {Integer}  i an item index
             * @return {Boolean}  true if the given item is selectable
             * @method isItemSelectable
             */
            this.isItemSelectable = function(i) {
                return true;
            };

            /**
             * Get selected list item
             * @return {Object} an item
             * @method getSelected
             */
            this.getSelected = function() {
                return this.selectedIndex &lt; 0 ? null
                                              : this.model.get(this.selectedIndex);
            };

            /**
             * Lookup a list item buy the given first character
             * @param  {String} ch a first character to lookup
             * @return {Integer} a position of found list item in the list or -1 if no item is found.
             * @method lookupItem
             * @protected
             */
            this.lookupItem = function(ch){
                var count = this.model === null ? 0 : this.model.count();
                if (zebkit.util.isLetter(ch) &amp;&amp; count &gt; 0){
                    var index = this.selectedIndex &lt; 0 ? 0 : this.selectedIndex + 1;
                    ch = ch.toLowerCase();
                    for(var i = 0;i &lt; count - 1; i++){
                        var idx  = (index + i) % count,
                            item = this.model.get(idx).toString();

                        if (this.isItemSelectable(idx) &amp;&amp; item.length &gt; 0 &amp;&amp; item[0].toLowerCase() === ch) {
                            return idx;
                        }
                    }
                }
                return -1;
            };

            /**
             * Test if the given list item is selected
             * @param  {Integer}  i an item index
             * @return {Boolean}  true if the item with the given index is selected
             * @method isSelected
             */
            this.isSelected = function(i) {
                return i === this.selectedIndex;
            };

            /**
             * Called when a pointer (pointer or finger on touch screen) is moved
             * to a new location
             * @param  {Integer} x a pointer x coordinate
             * @param  {Integer} y a pointer y coordinate
             * @method $pointerMoved
             * @protected
             */
            this.$pointerMoved = function(x, y){
                if (this.isComboMode === true &amp;&amp; this.model !== null) {
                    var index = this.getItemIdxAt(x, y);
                    if (index !== this.position.offset &amp;&amp; (index &lt; 0 || this.isItemSelectable(index) === true)) {
                        this.$triggeredByPointer = true;

                        if (index &lt; 0) {
                            this.position.setOffset(null);
                        } else {
                            this.position.setOffset(index);
                        }
                        this.notifyScrollMan(index);
                        this.$triggeredByPointer = false;
                    }
                }
            };

            /**
             * Return the given list item location.
             * @param  {Integer} i a list item index
             * @return {Object}  a location of the list item. The result is object that
             * has the following structure:
                    { x:{Integer}, y:{Integer} }
             * @method getItemLocation
             */
            this.getItemLocation = function(index) {
                this.validate();

                var y = this.getTop() + this.scrollManager.getSY();
                for(var i = 0; i &lt; index; i++) {
                    y += this.getItemSize(i).height;
                }

                return { x:this.getLeft(), y:y };
            };

            /**
             * Return the given list item size.
             * @param  {Integer} i a list item index
             * @return {Object}  a size of the list item. The result is object that
             * has the following structure:
                    { width:{Integer}, height:{Integer} }
             * @method getItemSize
             */
            this.getItemSize = function (i){
                throw new Error(&quot;Not implemented&quot;);
            };

            this.getLines = function() {
                return this.model === null ? 0 : this.model.count();
            };

            this.getLineSize = function(l) {
                return 1;
            };

            this.getMaxOffset = function() {
                return this.getLines() - 1;
            };

            this.catchScrolled = function(psx, psy) {
                this.repaint();
            };

            /**
             * Detect an item by the specified location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {Integer} a list item that is located at the given position.
             * -1 if no any list item can be found.
             * @method getItemIdxAt
             */
            this.getItemIdxAt = function(x,y) {
                return -1;
            };

            /**
             * Calculate maximal width and maximal height the items in the list have
             * @protected
             * @return {Integer} a max items size
             * @method calcMaxItemSize
             */
            this.calcMaxItemSize = function (){
                var maxH = 0,
                    maxW = 0;

                this.validate();
                if (this.model !== null) {
                    for(var i = 0;i &lt; this.model.count(); i++){
                        var is = this.getItemSize(i);
                        if (is.height &gt; maxH) {
                            maxH = is.height;
                        }

                        if (is.width  &gt; maxW) {
                            maxW = is.width;
                        }
                    }
                }
                return { width:maxW, height:maxH };
            };

            /**
             * Force repainting of the given list items
             * @protected
             * @param  {Integer} p an index of the first list item to be repainted
             * @param  {Integer} n an index of the second list item to be repainted
             * @method repaintByOffsets
             */
            this.repaintByOffsets = function(p, n) {
                this.validate();
                var xx    = this.width - this.getRight(),
                    l     = 0,
                    count = this.model === null ? 0
                                                : this.model.count();

                if (p &gt;= 0 &amp;&amp; p &lt; count){
                    l = this.getItemLocation(p);
                    this.repaint(l.x, l.y, xx - l.x, this.getItemSize(p).height);
                }

                if (n &gt;= 0 &amp;&amp; n &lt; count){
                    l = this.getItemLocation(n);
                    this.repaint(l.x, l.y, xx - l.x, this.getItemSize(n).height);
                }
            };

            /**
             * Draw the given list view element identified by the given id
             * on the given list item.
             * @param  {CanvasRenderingContext2D} g     a graphical context
             * @param  {String}     id    a view id
             * @param  {Integer}    index a list item index
             * @protected
             * @method drawViewAt
             */
            this.drawViewAt = function(g, id, index) {
                if (index &gt;= 0 &amp;&amp; this.views.hasOwnProperty(id) &amp;&amp; this.views[id] !== null &amp;&amp; this.isItemSelectable(index)) {
                    var is  = this.getItemSize(index),
                        l   = this.getItemLocation(index);

                    this.drawView(g, id, this.views[id],
                                  l.x, l.y,
                                  is.width ,
                                  is.height);
                }
            };

            /**
             * Draw the given list view element identified by the given id
             * at the specified location.
             * @param  {CanvasRenderingContext2D} g     a graphical context
             * @param  {String}     id    a view id
             * @param  {Integer}    x a x coordinate the view has to be drawn
             * @param  {Integer}    y a y coordinate the view has to be drawn
             * @param  {Integer}    w a view width
             * @param  {Integer}    h a view height
             * @protected
             * @method drawView
             */
            this.drawView = function(g, id, v, x, y, w ,h) {
                this.views[id].paint(g, x, y, w, h, this);
            };

            this.update = function(g) {
                if (this.isComboMode === true || this.hasFocus() === true)  {
                    this.drawViewAt(g, &quot;marker&quot;, this.position.offset);
                }
                this.drawViewAt(g, &quot;select&quot;, this.selectedIndex);
            };

            this.paintOnTop = function(g) {
                if (this.isComboMode === true || this.hasFocus())  {
                    this.drawViewAt(g, &quot;topMarker&quot;, this.position.offset);
                }
            };

            /**
             * Select the given list item
             * @param  {Integer} index an item index to be selected
             * @method select
             */
            this.select = function(index){
                if (index === null || typeof index === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Null index&quot;);
                }

                if (this.model !== null &amp;&amp; index &gt;= this.model.count()){
                    throw new RangeError(index);
                }

                if (this.selectedIndex !== index) {
                    if (index &lt; 0 || this.isItemSelectable(index)) {
                        var prev = this.selectedIndex;
                        this.selectedIndex = index;
                        this.notifyScrollMan(index);
                        this.repaintByOffsets(prev, this.selectedIndex);
                        this.fireSelected(prev);
                    }
                } else {
                    this.fireSelected(null);
                }
            };

            /**
             * Fire selected event
             * @param  {Integer|null} prev a previous selected item index. null if the
             * same item has been re-selected
             * @method fireSelected
             * @protected
             */
            this.fireSelected = function(prev) {
                this._.selected(this, prev);
            };

            this.pointerClicked = function(e) {
                if (this.model !== null &amp;&amp; e.isAction() &amp;&amp; this.model.count() &gt; 0) {
                    this.$select(this.position.offset &lt; 0 ? 0 : this.position.offset);
                }
            };

            this.pointerReleased = function(e){
                if (this.model !== null    &amp;&amp;
                    this.model.count() &gt; 0 &amp;&amp;
                    e.isAction()           &amp;&amp;
                    this.position.offset !== this.selectedIndex)
                {
                    this.position.setOffset(this.selectedIndex);
                }
            };

            this.pointerPressed = function(e){
                if (e.isAction() &amp;&amp; this.model !== null &amp;&amp; this.model.count() &gt; 0) {
                    var index = this.getItemIdxAt(e.x, e.y);
                    if (index &gt;= 0 &amp;&amp; this.position.offset !== index &amp;&amp; this.isItemSelectable(index)) {
                        this.position.setOffset(index);
                    }
                }
            };

            this.pointerDragged = this.pointerMoved = this.pointerEntered = function(e){
                this.$pointerMoved(e.x, e.y);
            };

            this.pointerExited = function(e){
                this.$pointerMoved(-10, -10);
            };

            this.pointerDragEnded = function(e){
                if (this.model !== null &amp;&amp; this.model.count() &gt; 0 &amp;&amp; this.position.offset &gt;= 0) {
                    this.select(this.position.offset &lt; 0 ? 0 : this.position.offset);
                }
            };

            this.keyPressed = function(e){
                if (this.model !== null &amp;&amp; this.model.count() &gt; 0){
                    switch(e.code) {
                        case &quot;End&quot;:
                            if (e.ctrlKey) {
                                this.position.setOffset(this.position.metrics.getMaxOffset());
                            } else {
                                this.position.seekLineTo(&quot;end&quot;);
                            }
                            break;
                        case &quot;Home&quot;:
                            if (e.ctrlKey) {
                                this.position.setOffset(0);
                            } else {
                                this.position.seekLineTo(&quot;begin&quot;);
                            }
                            break;
                        case &quot;ArrowRight&quot;: this.position.seek(1); break;
                        case &quot;ArrowDown&quot; : this.position.seekLineTo(&quot;down&quot;); break;
                        case &quot;ArrowLeft&quot; : this.position.seek(-1);break;
                        case &quot;ArrowUp&quot;   : this.position.seekLineTo(&quot;up&quot;);break;
                        case &quot;PageUp&quot;    : this.position.seek(this.pageSize(-1));break;
                        case &quot;PageDown&quot;  : this.position.seek(this.pageSize(1));break;
                        case &quot;Space&quot;     :
                        case &quot;Enter&quot;     : this.$select(this.position.offset); break;
                    }
                }
            };

            /**
             * Select the given list item. The method is called when an item
             * selection is triggered by a user interaction: key board, or pointer
             * @param  {Integer} o an item index
             * @method $select
             * @protected
             */
            this.$select = function(o) {
                this.select(o);
            };

            /**
             * Define key typed events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyTyped
             */
            this.keyTyped = function (e){
                var i = this.lookupItem(e.key);
                if (i &gt;= 0) {
                    this.$select(i);
                }
            };

            this.elementInserted = function(target, e,index){
                this.invalidate();
                if (this.selectedIndex &gt;= 0 &amp;&amp; this.selectedIndex &gt;= index) {
                    this.selectedIndex++;
                }
                this.position.inserted(index, 1);
                this.repaint();
            };

            this.elementRemoved = function(target, e,index){
                this.invalidate();
                if (this.selectedIndex === index || this.model.count() === 0) {
                    this.select(-1);
                } else {
                    if (this.selectedIndex &gt; index) {
                        this.selectedIndex--;
                    }
                }
                this.position.removed(index, 1);
                this.repaint();
            };

            this.elementSet = function (target, e, pe,index){
                if (this.selectedIndex === index) {
                    this.select(-1);
                }
                this.vrp();
            };

            /**
             * Find a next selectable list item starting from the given offset
             * with the specified direction
             * @param  {Integer} off a start item index to perform search
             * @param  {Integer} d   a direction increment. Cam be -1 or 1
             * @return {Integer} a next selectable item index
             * @method findSelectable
             * @protected
             */
            this.findSelectable = function(off, d) {
                var c = this.model.count(), i = 0, dd = Math.abs(d);
                while (this.isItemSelectable(off) === false &amp;&amp; i &lt; c) {
                    off = (c + off + d) % c;
                    i += dd;
                }
                return i &lt; c ? off : -1;
            };

            this.posChanged = function (target, prevOffset, prevLine, prevCol) {
                var off = this.position.offset;
                if (off &gt;= 0) {
                    off = this.findSelectable(off, prevOffset &lt; off ? 1 : -1);

                    if (off !== this.position.offset) {
                        this.position.setOffset(off);
                        this.repaintByOffsets(prevOffset, off);
                        return;
                    }
                }

                if (this.isComboMode === true) {
                    this.notifyScrollMan(off);
                } else {
                    this.select(off);
                }

                // this.notifyScrollMan(off);
                this.repaintByOffsets(prevOffset, off);
            };


            /**
             * Set the list model to be rendered with the list component
             * @param {zebkit.data.ListModel} m a list model
             * @method setModel
             * @chainable
             */
            this.setModel = function (m){
                if (m !== this.model){
                    if (m !== null &amp;&amp; Array.isArray(m)) {
                        m = new zebkit.data.ListModel(m);
                    }

                    if (this.model !== null &amp;&amp; typeof this.model._ !== &#x27;undefined&#x27;) {
                        this.model.off(this);
                    }

                    this.model = m;

                    if (this.model !== null &amp;&amp; typeof this.model._ !== &#x27;undefined&#x27;) {
                        this.model.on(this);
                    }

                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given position controller. List component uses position to
             * track virtual cursor.
             * @param {zebkit.util.Position} c a position
             * @method setPosition
             * @chainable
             */
            this.setPosition = function(c) {
                if (c !== this.position) {
                    if (this.position !== null) {
                        this.position.off(this);
                    }
                    this.position = c;
                    this.position.on(this);
                    this.position.setMetric(this);
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the list items view provider. Defining a view provider allows developers
             * to customize list item rendering.
             * @param {Object|Function} v a view provider class instance or a function that
             * says which view has to be used for the given list model data. The function
             * has to satisfy the following method signature: &quot;function(list, modelItem, index)&quot;
             * @method setViewProvider
             * @chainable
             */
            this.setViewProvider = function (v){
                if (this.provider !== v){
                    if (typeof v === &quot;function&quot;) {
                        var o = new zebkit.Dummy();
                        o.getView = v;
                        v = o;
                    }

                    this.provider = v;
                    this.vrp();
                }
                return this;
            };

            this.notifyScrollMan = function (index){
                if (index &gt;= 0 &amp;&amp; this.scrollManager !== null) {
                    this.validate();
                    var is = this.getItemSize(index);

                    if (is.width &gt; 0 &amp;&amp; is.height &gt; 0) {
                        var l = this.getItemLocation(index);
                        this.scrollManager.makeVisible(l.x - this.scrollManager.getSX(),
                                                       l.y - this.scrollManager.getSY(),
                                                       is.width, is.height);
                    }
                }
            };

            /**
             * The method returns the page size that has to be scroll up or down
             * @param  {Integer} d a scrolling direction. -1 means scroll up, 1 means scroll down
             * @return {Integer} a number of list items to be scrolled
             * @method pageSize
             * @protected
             */
            this.pageSize = function(d){
                var offset = this.position.offset;
                if (offset &gt;= 0) {
                    var vp = pkg.$cvp(this, {});
                    if (vp !== null) {
                        var sum = 0, i = offset;
                        for(;i &gt;= 0 &amp;&amp; i &lt;= this.position.metrics.getMaxOffset() &amp;&amp; sum &lt; vp.height; i += d){
                            sum += (this.getItemSize(i).height);
                        }
                        return i - offset - d;
                    }
                }
                return 0;
            };
        },

        /**
         * Sets the views for the list visual elements. The following elements are
         * supported:
         *
         *   - &quot;select&quot; -  a selection view element
         *   - &quot;topMarker&quot; - a position marker view element that is rendered  on top of list item
         *   - &quot;marker&quot; - a position marker view element
         *
         * @param {Object} views view elements
         * @method setViews
         */
        function focused(){
            this.$super();
            this.repaint();
        }
    ]);

    /**
     * The class is list component implementation that visualizes zebkit.data.ListModel.
     * It is supposed the model can have any type of items. Visualization of the items
     * is customized by defining a view provider.
     *
     * The general use case:

            // create list component that contains three item
            var list = new zebkit.ui.List([
                &quot;Item 1&quot;,
                &quot;Item 2&quot;,
                &quot;Item 3&quot;
            ]);

            ...
            // add new item
            list.model.add(&quot;Item 4&quot;);

            ...
            // remove first item
            list.model.removeAt(0);


     * To customize list items views you can redefine item view provider as following:

            // suppose every model item is an array that contains two elements,
            // first element points to the item icon and the second element defines
            // the list item text
            var list = new zebkit.ui.List([
                [ &quot;icon1.gif&quot;, &quot;Caption 1&quot; ],
                [ &quot;icon2.gif&quot;, &quot;Caption 1&quot; ],
                [ &quot;icon3.gif&quot;, &quot;Caption 1&quot; ]
            ]);

            // define new list item views provider that represents every
            // list model item as icon with a caption
            list.setViewProvider(new zebkit.ui.List.ViewProvider([
                function getView(target, i, value) {
                    var caption = value[1];
                    var icon    = value[0];
                    return new zebkit.ui.CompRender(new zebkit.ui.ImageLabel(caption, icon));
                }
            ]));

     * @class  zebkit.ui.List
     * @extends zebkit.ui.BaseList
     * @constructor
     * @param {zebkit.data.ListModel|Array} [model] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [isComboMode] true if the list navigation has to be triggered by
     * pointer cursor moving
     */
    pkg.List = Class(pkg.BaseList, [
        function (m, b){
            /**
             * Index of the first visible list item
             * @readOnly
             * @attribute firstVisible
             * @type {Integer}
             * @private
             */
            this.firstVisible = -1;

            /**
             * Y coordinate of the first visible list item
             * @readOnly
             * @attribute firstVisibleY
             * @type {Integer}
             * @private
             */
            this.firstVisibleY = this.psWidth_ = this.psHeight_ = 0;

            /**
             * Internal flag to track list items visibility status. It is set
             * to false to trigger list items metrics and visibility recalculation
             * @attribute visValid
             * @type {Boolean}
             * @private
             */
            this.visValid = false;
            this.setViewProvider(new this.clazz.ViewProvider());
            this.$supera(arguments);
        },

        function $clazz() {
            /**
             * List view provider class. This implementation renders list item using string
             * render. If a list item is an instance of &quot;zebkit.draw.View&quot; class than it will
             * be rendered as the view.
             * @class zebkit.ui.List.ViewProvider
             * @extends zebkit.draw.BaseViewProvider
             * @constructor
             */
            this.ViewProvider = Class(zebkit.draw.BaseViewProvider, []);

            /**
             * @for zebkit.ui.List
             */
        },

        function $prototype() {
            this.heights = this.widths = this.vArea = null;

            /**
             * Extra list item side gaps
             * @type {Integer}
             * @attribute gap
             * @default 2
             * @readOnly
             */
            this.gap = 2;

            /**
             * Set the left, right, top and bottom a list item paddings
             * @param {Integer} g a left, right, top and bottom a list item paddings
             * @method setItemGap
             * @chainable
             */
            this.setItemGap = function(g){
                if (this.gap !== g){
                    this.gap = g;
                    this.vrp();
                }
                return this;
            };

            this.paint = function(g){
                this.vVisibility();
                if (this.firstVisible &gt;= 0){
                    var sx = this.scrollManager.getSX(),
                        sy = this.scrollManager.getSY();

                    try {
                        g.translate(sx, sy);
                        var y        = this.firstVisibleY,
                            x        = this.getLeft(),
                            yy       = this.vArea.y + this.vArea.height - sy,
                            count    = this.model.count(),
                            dg       = this.gap * 2;

                        for (var i = this.firstVisible; i &lt; count; i++){
                            if (i !== this.selectedIndex &amp;&amp; typeof this.provider.getCellColor === &#x27;function&#x27;) {
                                var bc = this.provider.getCellColor(this, i);
                                if (bc !== null) {
                                    g.setColor(bc);
                                    g.fillRect(x, y, this.width, this.heights[i]);
                                }
                            }

                            this.provider.getView(this, i, this.model.get(i))
                                         .paint(g, x + this.gap, y + this.gap,
                                                   this.widths[i] - dg,
                                                   this.heights[i]- dg, this);

                            y += this.heights[i];
                            if (y &gt; yy) {
                                break;
                            }
                        }

                        g.translate(-sx,  -sy);
                    } catch(e) {
                        g.translate(-sx,  -sy);
                        throw e;
                    }
                }
            };

            this.recalc = function(){
                this.psWidth_ = this.psHeight_ = 0;
                if (this.model !== null) {
                    var count = this.model.count();
                    if (this.heights === null || this.heights.length !== count) {
                        this.heights = Array(count);
                    }

                    if (this.widths  === null || this.widths.length  !== count) {
                        this.widths = Array(count);
                    }

                    var provider = this.provider;
                    if (provider !== null) {
                        var dg = 2*this.gap;
                        for(var i = 0;i &lt; count; i++){
                            var ps = provider.getView(this, i, this.model.get(i)).getPreferredSize();
                            this.heights[i] = ps.height + dg;
                            this.widths [i] = ps.width  + dg;

                            if (this.widths[i] &gt; this.psWidth_) {
                                this.psWidth_ = this.widths[i];
                            }
                            this.psHeight_ += this.heights[i];
                        }
                    }
                }
            };

            this.calcPreferredSize = function(l){
                return { width : this.psWidth_,
                         height: this.psHeight_ };
            };

            this.vVisibility = function(){
                this.validate();
                var prev = this.vArea;
                this.vArea = pkg.$cvp(this, {});

                if (this.vArea === null) {
                    this.firstVisible = -1;
                } else  {
                    if (this.visValid === false ||
                        (prev === null || prev.x !== this.vArea.x ||
                         prev.y !== this.vArea.y || prev.width !== this.vArea.width ||
                         prev.height !== this.vArea.height))
                    {
                        var top = this.getTop();
                        if (this.firstVisible &gt;= 0){
                            var dy = this.scrollManager.getSY();
                            while (this.firstVisibleY + dy &gt;= top &amp;&amp; this.firstVisible &gt; 0){
                                this.firstVisible--;
                                this.firstVisibleY -= this.heights[this.firstVisible];
                            }
                        } else {
                            this.firstVisible  = 0;
                            this.firstVisibleY = top;
                        }

                        if (this.firstVisible &gt;= 0) {
                            var count = this.model === null ? 0 : this.model.count(),
                                hh    = this.height - this.getBottom();

                            for(; this.firstVisible &lt; count; this.firstVisible++) {
                                var y1 = this.firstVisibleY + this.scrollManager.getSY(),
                                    y2 = y1 + this.heights[this.firstVisible] - 1;

                                if ((y1 &gt;= top &amp;&amp; y1 &lt; hh) || (y2 &gt;= top &amp;&amp; y2 &lt; hh) || (y1 &lt; top &amp;&amp; y2 &gt;= hh)) {
                                    break;
                                }

                                this.firstVisibleY += (this.heights[this.firstVisible]);
                            }

                            if (this.firstVisible &gt;= count) {
                                this.firstVisible =  -1;
                            }
                        }
                        this.visValid = true;
                    }
                }
            };

            this.getItemLocation = function(index){
                this.validate();
                var y = this.getTop() + this.scrollManager.getSY();
                for(var i = 0; i &lt; index; i++) {
                    y += this.heights[i];
                }
                return { x:this.getLeft(), y : y };
            };

            this.getItemSize = function(i){
                this.validate();
                return { width:this.widths[i], height:this.heights[i] };
            };

            this.getItemIdxAt = function(x,y){
                this.vVisibility();
                if (this.vArea !== null &amp;&amp; this.firstVisible &gt;= 0) {
                    var yy    = this.firstVisibleY + this.scrollManager.getSY(),
                        hh    = this.height - this.getBottom(),
                        count = this.model.count();

                    for (var i = this.firstVisible; i &lt; count; i++) {
                        if (y &gt;= yy &amp;&amp; y &lt; yy + this.heights[i]) {
                            return i;
                        }

                        yy += (this.heights[i]);
                        if (yy &gt; hh) {
                            break;
                        }
                    }
                }
                return  -1;
            };
        },

        function invalidate(){
            this.visValid = false;
            this.firstVisible = -1;
            this.$super();
        },

        function drawView(g,id,v,x,y,w,h) {
            this.$super(g, id, v, x, y, this.width - this.getRight() - x, h);
        },

        function catchScrolled(psx,psy){
            this.firstVisible = -1;
            this.visValid = false;
            this.$super(psx, psy);
        }
    ]);

    /**
     * List component consider its children UI components as a list model items. Every added to the component
     * UI children component becomes a list model element. The implementation allows developers to use
     * other UI components as its elements what makes list item view customization very easy and powerful:
     *
     *     // use image label as the component list items
     *     var list = new zebkit.ui.CompList();
     *     list.add(new zebkit.ui.ImageLabel(&quot;Caption 1&quot;, &quot;icon1.gif&quot;));
     *     list.add(new zebkit.ui.ImageLabel(&quot;Caption 2&quot;, &quot;icon2.gif&quot;));
     *     list.add(new zebkit.ui.ImageLabel(&quot;Caption 3&quot;, &quot;icon3.gif&quot;));
     *
     *
     * @class zebkit.ui.CompList
     * @constructor
     * @extends zebkit.ui.BaseList
     * @param {zebkit.data.ListModel|Array} [model] a list model that should be passed as an instance
     * of zebkit.data.ListModel or as an array.
     * @param {Boolean} [isComboMode] true if the list navigation has to be triggered by
     * pointer cursor moving
     */
    pkg.CompList = Class(pkg.BaseList, [
        function (m, b) {
            this.model = this;

            this.setViewProvider(new zebkit.Dummy([
                function $prototype() {
                    this.render = new pkg.CompRender();
                    this.getView = function (target,i, obj) {
                        this.render.setValue(obj);
                        return this.render;
                    };
                }
            ]));

            this.$supera(arguments);
        },

        function $clazz() {
            this.Label      = Class(pkg.Label, []);
            this.ImageLabel = Class(pkg.ImageLabel, []);
            this.Listeners  = this.$parent.Listeners.ListenersClass(&quot;elementInserted&quot;, &quot;elementRemoved&quot;, &quot;elementSet&quot;);
        },

        function $prototype() {
            this.max = null;

            this.get = function(i) {
                if (i &lt; 0 || i &gt;= this.kids.length) {
                    throw new RangeError(i);
                }
                return this.kids[i];
            };

            this.contains = function (c) {
                return this.indexOf(c) &gt;= 0;
            };

            this.count = function () {
                return this.kids.length;
            };

            this.catchScrolled = function(px, py) {};

            this.getItemLocation = function(i) {
                return { x:this.kids[i].x, y:this.kids[i].y };
            };

            this.getItemSize = function(i) {
                return this.kids[i].isVisible === false ? { width:0, height: 0 }
                                                        : { width:this.kids[i].width, height:this.kids[i].height};
            };

            this.recalc = function (){
                this.max = zebkit.layout.getMaxPreferredSize(this);
            };

            this.calcMaxItemSize = function() {
                this.validate();
                return { width:this.max.width, height:this.max.height };
            };

            this.getItemIdxAt = function(x, y) {
                return zebkit.layout.getDirectAt(x, y, this);
            };

            this.isItemSelectable = function(i) {
                return this.model.get(i).isVisible === true &amp;&amp;
                       this.model.get(i).isEnabled === true;
            };

            this.catchInput = function (child){
                if (this.isComboMode !== true) {
                    var p = child;
                    while (p !== this) {
                        if (p.stopCatchInput === true) {
                            return false;
                        }
                        p = p.parent;
                    }
                }
                return true;
            };

            this.setModel = function(m){
                if (Array.isArray(m)) {
                    for(var i = 0; i &lt; m.length; i++) {
                        this.add(m[i]);
                    }
                } else {
                    throw new Error(&quot;Invalid comp list model&quot;);
                }

                return this;
            };
        },

        function setPosition(c){
            if (c !== this.position){
                if (zebkit.instanceOf(this.layout, zebkit.util.Position.Metric)) {
                    c.setMetric(this.layout);
                }
                this.$super(c);
            }
            return this;
        },

        function setLayout(layout){
            if (layout !== this.layout){
                this.scrollManager = new pkg.ScrollManager(this, [
                    function $prototype() {
                        this.calcPreferredSize = function(t) {
                            return layout.calcPreferredSize(t);
                        };

                        this.doLayout = function(t){
                            layout.doLayout(t);
                            for(var i = 0; i &lt; t.kids.length; i++){
                                var kid = t.kids[i];
                                if (kid.isVisible === true) {
                                    kid.setLocation(kid.x + this.getSX(),
                                                    kid.y + this.getSY());
                                }
                            }
                        };

                        this.scrollStateUpdated = function(sx,sy,px,py){
                            this.target.vrp();
                        };
                    }
                ]);

                this.$super(this.scrollManager);
                if (this.position !== null) {
                    this.position.setMetric(zebkit.instanceOf(layout, zebkit.util.Position.Metric) ? layout : this);
                }
            }

            return this;
        },

        function setAt(i, item) {
            if (i &lt; 0 || i &gt;= this.kids.length) {
                throw new RangeError(i);
            }
            return this.$super(i, item);
        },

        function insert(i, constr, e) {
            if (arguments.length === 2) {
                e = constr;
                constr = null;
            }

            if (i &lt; 0 || i &gt; this.kids.length) {
                throw new RangeError(i);
            }
            return this.$super(i, constr, zebkit.instanceOf(e, pkg.Panel) ? e : new this.clazz.Label(&quot;&quot; + e));
        },

        function kidAdded(index,constr,e){
            this.$super(index,constr,e);
            this.model._.elementInserted(this, e, index);
        },

        function kidRemoved(index,e) {
            this.$super(index,e);
            this.model._.elementRemoved(this, e, index);
        }
    ]);


    /**
     * Combo box UI component class. Combo uses a list component to show in drop down window.
     * You can use any available list component implementation:

            // use simple list as combo box drop down window
            var combo = new zebkit.ui.Combo(new zebkit.ui.List([
                &quot;Item 1&quot;,
                &quot;Item 2&quot;,
                &quot;Item 3&quot;
            ]));


            // use component list as combo box drop down window
            var combo = new zebkit.ui.Combo(new zebkit.ui.CompList([
                &quot;Item 1&quot;,
                &quot;Item 2&quot;,
                &quot;Item 3&quot;
            ]));


            // let combo box decides which list component has to be used
            var combo = new zebkit.ui.Combo([
                &quot;Item 1&quot;,
                &quot;Item 2&quot;,
                &quot;Item 3&quot;
            ]);

     * @class zebkit.ui.Combo
     * @extends zebkit.ui.Panel
     * @constructor
     * @param {Array|zebkit.ui.BaseList} data an combo items array or a list component
     */

    /**
     * Fired when a new value in a combo box component has been selected

         combo.on(&quot;selected&quot;, function(combo, value) {
             ...
         });

     * @event selected
     * @param {zebkit.ui.Combo} combo a combo box component where a new value
     * has been selected
     * @param {Object} value a previously selected index
     */

    /**
     * Implement the event handler method to detect when a combo pad window
     * is shown or hidden

         var p = new zebkit.ui.Combo();
         p.padShown = function(src, b) { ... }; // add event handler

     * @event padShown
     * @param {zebkit.ui.Combo} src a combo box component that triggers the event
     * @param {Boolean} b a flag that indicates if the combo pad window has been
     * shown (true) or hidden (false)
    */
    pkg.Combo = Class(pkg.Panel, [
        function(list, editable) {
            if (arguments.length === 1 &amp;&amp; zebkit.isBoolean(list)) {
                editable = list;
                list = null;
            }

            if (arguments.length === 0) {
                editable = false;
            }

            if (arguments.length === 0 || list === null) {
                list = new this.clazz.List(true);
            }

            /**
             * Reference to combo box list component
             * @attribute list
             * @readOnly
             * @type {zebkit.ui.BaseList}
             */
            if (zebkit.instanceOf(list, pkg.BaseList) === false) {
                list = list.length &gt; 0 &amp;&amp; zebkit.instanceOf(list[0], pkg.Panel) ? new this.clazz.CompList(list, true)
                                                                                : new this.clazz.List(list, true);
            }

            /**
             * Maximal size the combo box height can have
             * @attribute maxPadHeight
             * @readOnly
             * @type {Integer}
             */
            this.maxPadHeight = 0;

            this.$lockListSelEvent = false;
            this._ = new this.clazz.Listeners();
            this.setList(list);

            this.$super();

            this.add(&quot;center&quot;, editable ? new this.clazz.EditableContentPan()
                                        : new this.clazz.ReadonlyContentPan());
            this.add(&quot;right&quot;, new this.clazz.Button());
        },


        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;selected&quot;);

            /**
             * UI panel class that is used to implement combo box content area
             * @class  zebkit.ui.Combo.ContentPan
             * @extends zebkit.ui.Panel
             * @constructor
             */
            this.ContentPan = Class(pkg.Panel, [
                function $prototype() {
                    /**
                     * Called whenever the given combo box value has been updated with the specified
                     * value. Implement the method to synchronize content panel with updated combo
                     * box value
                     * @method comboValueUpdated
                     * @param {zebkit.ui.Combo} combo a combo box component that has been updated
                     * @param {Object} value a value with which the combo box has been updated
                     */
                    this.comboValueUpdated = function(combo, value) {};

                    /**
                     * Indicates if the content panel is editable. Set the property to true
                     * to indicate the content panel implementation is editable. Editable
                     * means the combo box content can be editable by a user
                     * @attribute isEditable
                     * @type {Boolean}
                     * @readOnly
                     * @default undefined
                     */

                    /**
                     * Get a combo box the content panel belongs
                     * @method getCombo
                     * @return {zebkit.ui.Combo} a combo the content panel belongs
                     */
                    this.getCombo = function() {
                        for (var p = this.parent; p !== null &amp;&amp; zebkit.instanceOf(p, pkg.Combo) === false; p = p.parent) {}
                        return p;
                    };
                }
            ]);

            /**
             * Combo box list pad component class
             * @extends zebkit.ui.ScrollPan
             * @class  zebkit.ui.Combo.ComboPadPan
             * @constructor
             * @param {zebkit.ui.Panel} c a target component
             */
            this.ComboPadPan = Class(pkg.ScrollPan, [
                function $prototype() {
                    this.$closeTime = 0;

                    this.adjustToComboSize = true;

                    this.owner = null;

                    /**
                     * A reference to combo that uses the list pad component
                     * @attribute owner
                     * @type {zebkit.ui.Combo}
                     * @readOnly
                     */
                    this.childKeyPressed = function(e){
                        if (e.code === &quot;Escape&quot; &amp;&amp; this.parent !== null) {
                            this.removeMe();
                            if (this.owner !== null) {
                                this.owner.requestFocus();
                            }
                        }
                    };
                },

                function setParent(l) {
                    this.$super(l);
                    if (l === null &amp;&amp; this.owner !== null) {
                        this.owner.requestFocus();
                    }

                    this.$closeTime = l === null ? new Date().getTime() : 0;
                }
            ]);

            /**
             * Read-only content area combo box component panel class
             * @extends zebkit.ui.Combo.ContentPan
             * @constructor
             * @class  zebkit.ui.Combo.ReadonlyContentPan
             */
            this.ReadonlyContentPan = Class(this.ContentPan, [
                function $prototype() {
                    this.calcPsByContent = false;

                    this.getCurrentView = function() {
                        var list = this.getCombo().list,
                            selected = list.getSelected();

                        return selected !== null ? list.provider.getView(list, list.selectedIndex, selected)
                                                 : null;
                    };

                    this.paintOnTop = function(g){
                        var v = this.getCurrentView();
                        if (v !== null) {
                            var ps = v.getPreferredSize();
                            v.paint(g, this.getLeft(),
                                       this.getTop() + Math.floor((this.height - this.getTop() - this.getBottom() - ps.height) / 2),
                                       this.width, ps.height, this);
                        }
                    };

                    this.setCalcPsByContent = function(b) {
                        if (this.calcPsByContent !== b) {
                            this.calcPsByContent = b;
                            this.vrp();
                        }
                        return this;
                    };

                    this.calcPreferredSize = function(l) {
                        var p = this.getCombo();
                        if (p !== null &amp;&amp; this.calcPsByContent !== true) {
                            return p.list.calcMaxItemSize();
                        }
                        var cv = this.getCurrentView();
                        return cv === null ? { width: 0, height: 0} : cv.getPreferredSize();
                    };

                    this.comboValueUpdated = function(combo, value) {
                        if (this.calcPsByContent === true) {
                            this.invalidate();
                        }
                    };
                }
            ]);

            /**
             * Editable content area combo box component panel class
             * @class zebkit.ui.Combo.EditableContentPan
             * @constructor
             * @extends zebkit.ui.Combo.ContentPan
             */

            /**
             * Fired when a content value has been updated.

            content.on(function(contentPan, newValue) {
                ...
            });

             * @param {zebkit.ui.Combo.ContentPan} contentPan a content panel that
             * updated its value
             * @param {Object} newValue a new value the content panel has been set
             * with
             * @event  contentUpdated
             */
            this.EditableContentPan = Class(this.ContentPan, [
                function $clazz() {
                    this.TextField = Class(pkg.TextField, []);
                    this.Listeners = zebkit.util.ListenersClass(&quot;contentUpdated&quot;);
                },

                function $prototype() {
                    this.canHaveFocus = true;

                    this.textUpdated = function(src,b,off,size,startLine,lines){
                        if (this.dontGenerateUpdateEvent === false) {
                            this._.contentUpdated(this, this.textField.getValue());
                        }
                    };

                    /**
                     * Called when the combo box content has been updated
                     * @param {zebkit.ui.Combo} combo a combo where the new value has been set
                     * @param {Object} v a new combo box value
                     * @method comboValueUpdated
                     */
                    this.comboValueUpdated = function(combo, v){
                        this.dontGenerateUpdateEvent = true;
                        try {
                            var txt = (v === null ? &quot;&quot; : v.toString());
                            this.textField.setValue(txt);
                            this.textField.select(0, txt.length);
                        } finally {
                            this.dontGenerateUpdateEvent = false;
                        }
                    };
                },

                function focused(){
                    this.$super();
                    this.textField.requestFocus();
                },

                function() {
                    this.$super();
                    this._ = new this.clazz.Listeners();

                    this.isEditable = true;

                    this.dontGenerateUpdateEvent = false;

                    /**
                     * A reference to a text field component the content panel uses as a
                     * value editor
                     * @attribute textField
                     * @readOnly
                     * @private
                     * @type {zebkit.ui.TextField}
                     */
                    this.textField = new this.clazz.TextField(&quot;&quot;,  -1);
                    this.textField.view.target.on(this);
                    this.add(&quot;center&quot;, this.textField);
                }
            ]);

            this.Button = Class(pkg.Button, [
                function() {
                    this.setFireParams(true,  -1);
                    this.$super();
                }
            ]);

            this.List = Class(pkg.List, []);
            this.CompList = Class(pkg.CompList, []);
        },

        /**
         * @for zebkit.ui.Combo
         */
        function $prototype() {
            this.list = null;

            /**
             * Reference to combo box button component
             * @attribute button
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to combo box content component
             * @attribute content
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to combo box pad component
             * @attribute winpad
             * @readOnly
             * @type {zebkit.ui.Panel}
             */

            /**
             * Reference to selection view
             * @attribute selectView
             * @readOnly
             * @type {zebkit.draw.View}
             */

            this.selectView = this.button = this.content = this.winpad = null;


            this.paint = function(g){
                if (this.content       !== null &amp;&amp;
                    this.selectView !== null &amp;&amp;
                    this.hasFocus())
                {
                    this.selectView.paint(g, this.content.x,
                                                this.content.y,
                                                this.content.width,
                                                this.content.height,
                                                this);
                }
            };

            this.catchInput = function (child) {
                return child !== this.button &amp;&amp; (this.content === null || this.content.isEditable !== true);
            };

            this.canHaveFocus = function() {
                return this.winpad.parent === null &amp;&amp; (this.content !== null &amp;&amp; this.content.isEditable !== true);
            };

            this.contentUpdated = function(src, text){
                if (src === this.content) {
                    try {
                        this.$lockListSelEvent = true;
                        if (text === null) {
                            this.list.select(-1);
                        } else {
                            var m = this.list.model;
                            for(var i = 0;i &lt; m.count(); i++){
                                var mv = m.get(i);
                                if (mv !== text) {
                                    this.list.select(i);
                                    break;
                                }
                            }
                        }
                    } finally {
                        this.$lockListSelEvent = false;
                    }
                    this._.selected(this, text);
                }
            };

            /**
             * Select the given value from the list as the combo box value
             * @param  {Integer} i an index of a list element to be selected
             * as the combo box value
             * @method select
             * @chainable
             */
            this.select = function(i) {
                this.list.select(i);
                return this;
            };

            // This method has been added to support selectedIndex property setter
            this.setSelectedIndex = function(i) {
                this.select(i);
                return this;
            };

            /**
             * Set combo box value selected value.
             * @param {Object} v a value
             * @method  setValue
             */
            this.setValue = function(v) {
                return this.list.setValue(v);
            };

            /**
             * Get the current combo box selected value
             * @return {Object} a value
             * @method getValue
             */
            this.getValue = function() {
                return this.list.getValue();
            };

            /**
             * Define pointer pressed events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function (e) {
                if (e.isAction() &amp;&amp; this.content !== null                 &amp;&amp;
                    (new Date().getTime() - this.winpad.$closeTime) &gt; 100 &amp;&amp;
                    e.x &gt; this.content.x &amp;&amp; e.y &gt; this.content.y          &amp;&amp;
                    e.x &lt; this.content.x + this.content.width             &amp;&amp;
                    e.y &lt; this.content.y + this.content.height              )
                {
                    this.showPad();
                }
            };

            /**
             * Test if the combo window pad is shown
             * @return {Boolean} true if the combo window pad is shown
             * @method isPadShown
             */
            this.isPadShown = function() {
                return this.winpad !== null &amp;&amp; this.winpad.parent !== null &amp;&amp; this.winpad.isVisible === true;
            };

            /**
             * Hide combo drop down list
             * @method hidePad
             * @chainable
             */
            this.hidePad = function() {
                var d = this.getCanvas();
                if (d !== null &amp;&amp; this.winpad.parent !== null) {
                    this.winpad.removeMe();
                    this.requestFocus();
                }
                return this;
            };

            /**
             * Show combo drop down list
             * @method showPad
             * @chainable
             */
            this.showPad = function(){
                var canvas = this.getCanvas();
                if (canvas !== null) {
                    var ps  = this.winpad.getPreferredSize(),
                        p   = zebkit.layout.toParentOrigin(0, 0, this.winpad.adjustTo == null ? this : this.winpad.adjustTo),
                        py  = p.y;

                    // if (this.winpad.hbar &amp;&amp; ps.width &gt; this.width) {
                    //     ps.height += this.winpad.hbar.getPreferredSize().height;
                    // }

                    if (this.maxPadHeight &gt; 0 &amp;&amp; ps.height &gt; this.maxPadHeight) {
                        ps.height = this.maxPadHeight;
                    }

                    if (py + this.height + ps.height &gt; canvas.height) {
                        if (py - ps.height &gt;= 0) {
                            py -= (ps.height + this.height);
                        } else {
                            var hAbove = canvas.height - py - this.height;
                            if (py &gt; hAbove) {
                                ps.height = py;
                                py -= (ps.height + this.height);
                            } else {
                                ps.height = hAbove;
                            }
                        }
                    }

                    this.winpad.setBounds(p.x,
                                          py + (this.winpad.adjustTo == null ? this.height
                                                                             : this.winpad.adjustTo.height),
                                          this.winpad.adjustTo == null ? (this.winpad.adjustToComboSize === true ? this.width
                                                                                                                 : ps.width)
                                                                       : this.winpad.adjustTo.width,
                                          ps.height);

                    this.list.notifyScrollMan(this.list.selectedIndex);
                    canvas.getLayer(pkg.PopupLayerMix.id).add(this, this.winpad);
                    this.list.requestFocus();
                    if (typeof this.padShown !== &#x27;undefined&#x27;) {
                        this.padShown(true);
                    }

                    return this;
                }
            };

            /**
             * Bind the given list component to the combo box component.
             * @param {zebkit.ui.BaseList} l a list component
             * @method setList
             * @chainable
             */
            this.setList = function(l){
                if (this.list !== l) {
                    this.hidePad();

                    if (this.list !== null) {
                        this.list.off(this);
                    }
                    this.list = l;
                    if (typeof this.list._ !== &#x27;undefined&#x27;) {
                        this.list.on(this);
                    }
                    var $this = this;
                    this.winpad = new this.clazz.ComboPadPan(this.list, [
                        function setParent(p) {
                            this.$super(p);
                            if (typeof $this.padShown !== &#x27;undefined&#x27;) {
                                $this.padShown($this, p !== null);
                            }
                        }
                    ]);

                    this.winpad.owner = this;
                    if (this.content !== null) {
                        this.content.comboValueUpdated(this, this.list.getSelected());
                    }
                    this.vrp();
                }
                return this;
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function (e) {
                if (this.list !== null &amp;&amp; this.list.model !== null) {
                    var index = this.list.selectedIndex;
                    switch(e.code) {
                        case &quot;Enter&quot;     : this.showPad(); break;
                        case &quot;ArrowLeft&quot; :
                        case &quot;ArrowUp&quot;   : if (index &gt; 0) {
                            this.list.select(index - 1);
                        } break;
                        case &quot;ArrowDown&quot; :
                        case &quot;ArrowRight&quot;: if (this.list.model.count() - 1 &gt; index) {
                            this.list.select(index + 1);
                        } break;
                    }
                }
            };

            /**
             * Define key typed  events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyTyped
             */
            this.keyTyped = function(e) {
                this.list.keyTyped(e);
            };

            /**
             * Set the given combo box selection view
             * @param {zebkit.draw.View} c a view
             * @method setSelectView
             * @chainable
             */
            this.setSelectView = function (c){
                if (c !== this.selectView) {
                    this.selectView = zebkit.graphics.$view(c);
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the maximal height of the combo box pad element.
             * @param {Integer} h a maximal combo box pad size
             * @method setMaxPadHeight
             * @chainable
             */
            this.setMaxPadHeight = function(h){
                if (this.maxPadHeight !== h) {
                    this.hidePad();
                    this.maxPadHeight = h;
                }
                return this;
            };

            /**
             * Make the commbo editable
             * @param {Boolean} b  true to make the combo ediatable
             * @chainable
             * @method setEditable
             */
            this.setEditable = function(b) {
                if (this.content === null || this.content.isEditable !== b) {
                    var ctr = &quot;center&quot;;
                    if (this.content !== null) {
                        ctr = this.content.constraints;
                        this.content.removeMe();
                    }
                    this.add(ctr, b ? new this.clazz.EditableContentPan()
                                    : new this.clazz.ReadonlyContentPan());
                }
                return this;
            };

            /**
             * Combo box button listener method. The method triggers showing
             * combo box pad window when the combo button has been pressed
             * @param  {zebkit.ui.Button} src a button that has been pressed
             * @method fired
             */
            this.fired = function(src) {
                if ((new Date().getTime() - this.winpad.$closeTime) &gt; 100) {
                    this.showPad();
                }
            };

            /**
             * Combo pad list listener method. Called every time an item in
             * combo pad list has been selected.
             * @param  {zebkit.ui.BaseList} src a list
             * @param  {Integer} data a selected index
             * @method selected
             * @protected
             */
            this.selected = function(src, data) {
                if (this.$lockListSelEvent === false) {
                    this.hidePad();
                    if (this.content !== null) {
                        this.content.comboValueUpdated(this, this.list.getSelected());
                        if (this.content.isEditable === true) {
                            this.content.requestFocus();
                        }
                        this.repaint();
                    }
                    this._.selected(this, data);
                }
            };
        },

        function focused(){
            this.$super();
            this.repaint();
        },

        function kidAdded(index, s, c){
            if (zebkit.instanceOf(c, pkg.Combo.ContentPan)) {
                if (this.content !== null) {
                    throw new Error(&quot;Content panel is set&quot;);
                }

                this.content = c;

                if (this.list !== null) {
                    c.comboValueUpdated(this, this.list.getSelected());
                }
            } else if (this.button === null) {
                this.button = c;
            }

            if (zebkit.instanceOf(c, zebkit.util.Fireable)) {
                c.on(this);
            }

            this.$super(index, s, c);
        },

        function kidRemoved(index,l) {
            if (zebkit.instanceOf(l, zebkit.util.Fireable)) {
                l.off(this);
            }

            if (this.content === l) {
                this.content = null;
            } else if (this.button === l) {
                this.button = null;
            }

            this.$super(index, l);
        },

        function setVisible(b) {
            if (b === false) {
                this.hidePad();
            }
            this.$super(b);
            return this;
        },

        function setParent(p) {
            if (p === null) {
                this.hidePad();
            }
            this.$super(p);
        }
    ]);


    pkg.events.regEvents(&quot;menuItemSelected&quot;);

    /**
     * Menu event class
     * @constructor
     * @class zebkit.ui.event.MenuEvent
     * @extends zebkit.util.Event
     */
    pkg.event.MenuEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Index of selected menu item
             * @type {Integer}
             * @attribute index
             * @readOnly
             */
            this.index = -1;

            /**
             * Selected menu item component
             * @type {zebkit.ui.Panel}
             * @attribute item
             * @readOnly
             */
            this.item = null;

            /**
             * Fill menu event with specified parameters
             * @param  {zebkit.ui.Menu} src a source of the menu event
             * @param  {Integer} index an index of selected menu item
             * @param  {zebkit.ui.Panel} item a selected menu item
             * @protected
             * @chainable
             * @method $fillWith
             */
            this.$fillWith = function(src, index, item) {
                this.source = src;
                this.index  = index;
                this.item   = item;
                return this;
            };
        }
    ]);

    var MENU_EVENT = new pkg.event.MenuEvent();

    /**
     * Show the given popup menu.
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {zebkit.ui.Menu}  menu a menu to be shown
     * @for  zebkit.ui
     * @method showPopupMenu
     */
    pkg.showPopupMenu = function(context, menu) {
        context.getCanvas().getLayer(pkg.PopupLayerMix.id).add(menu);
    };

    /**
     * Menu item panel class. The component holds menu item content like caption, icon, sub-menu
     * sign elements. The area of the component is split into three parts: left, right and center.
     * Central part keeps content, left side keeps checked sign element and the right side keeps
     * sub-menu sign element.
     * @param  {String|zebkit.ui.Panel} content a menu item content string or component. Caption
     * string can encode the item id, item icon and item checked state. For instance:
     *
     *         {
     *             content:  &quot;Test&quot; | {zebkit.ui.Panel}
     *             checked:  {Boolean},                   // optional
     *             group  :  {zebkit.ui.Group},           // optional
     *             icon   :  &quot;path/to/image&quot; | {Image},   // optional
     *             handler:  {Function}                   // optional
     *             id     :  {String}                     // optional
     *         }
     *
     * @example
     *
     *
     *     // create menu item with icon and &quot;Item 1&quot; title
     *     var mi = new zebkit.ui.MenuItem({
     *         content: &quot;Menu item label&quot;
     *     });
     *
     *
     * @class zebkit.ui.MenuItem
     * @extends zebkit.ui.Panel
     * @constructor
     *
     */
    pkg.MenuItem = Class(pkg.Panel, [
        function(c) {
            this.$super();

            if (zebkit.isString(c)) {
                this.add(new this.clazz.Checkbox()).setVisible(false);
                c = new this.clazz.ImageLabel(c, null);
            } else if (zebkit.instanceOf(c, pkg.Panel) === false) {
                var ch = null;

                if (c.checked === true || c.checked === false || c.group) {
                    ch = (typeof c.group !== &#x27;undefined&#x27;) ? new this.clazz.Radiobox()
                                                          : new this.clazz.Checkbox();

                    ch.setValue(typeof c.checked === &#x27;undefined&#x27; ? false : c.checked);
                    if (typeof c.group !== &#x27;undefined&#x27;) {
                        ch.setGroup(c.group);
                    }
                } else {
                    ch = new this.clazz.Checkbox();
                    ch.setVisible(false);
                }

                this.add(ch);

                if (typeof c.id !== &#x27;undefined&#x27;) {
                    this.setId(c.id);
                }

                if (typeof c.handler !== &#x27;undefined&#x27;) {
                    this.$handler = c.handler;
                }

                if (zebkit.instanceOf(c.content, zebkit.ui.Panel)) {
                    c = c.content;
                } else if (typeof c.icon !== &#x27;undefined&#x27;) {
                    c = new this.clazz.ImageLabel(c.content, c.icon);
                } else {
                    c = new this.clazz.ImageLabel(c.content, null);
                }
            } else {
                this.add(new this.clazz.Checkbox()).setVisible(false);
            }

            this.add(c);
            this.add(new this.clazz.SubImage());

            this.setEnabled(c.isEnabled);
            this.setVisible(c.isVisible);
        },

        function $clazz() {
            this.SubImage  = Class(pkg.StatePan, []);
            this.Label     = Class(pkg.Label,    []);
            this.Checkbox  = Class(pkg.Checkbox, []);
            this.Radiobox  = Class(pkg.Radiobox, []);
            this.ImageLabel  = Class(pkg.ImageLabel, []);
        },

        function $prototype() {
            this.$handler = null;

            /**
             * Gap between checked, content and sub menu arrow components
             * @attribute gap
             * @type {Integer}
             * @readOnly
             * @default 8
             */
            this.gap = 8;

            /**
             * Callback method that is called every time the menu item has
             * been selected.
             * @method  itemSelected
             */
            this.itemSelected = function() {
                var content = this.getContent();
                if (zebkit.instanceOf(content, pkg.Checkbox)) {
                    content.setValue(!content.getValue());
                }

                if (this.getCheck().isVisible) {
                    this.getCheck().toggle();
                }

                if (this.$handler !== null) {
                    this.$handler.call(this);
                }
            };

            /**
             * Set the menu item icon.
             * @param {String|Image} img a path to an image or image object
             * @method setIcon
             * @chainable
             */
            this.setIcon = function(img) {
                this.getContent().setImage(img);
                return this;
            };

            /**
             * Get check state component
             * @return {zebkit.ui.Panel} a check state component
             * @method getCheck
             */
            this.getCheck = function() {
                return this.kids[0];
            };

            /**
             * Get checked state of the item
             * @return {Boolean} a checked state
             * @method isChecked
             */
            this.isChecked = function() {
                return this.getCheck().isVisible &amp;&amp; this.getCheck().getValue();
            };

            /**
             * Set group
             * @param {zebkit.ui.Group} g a group
             * @param {Boolean} [v] a value
             * @method setGroup
             */
            this.setGroup = function(g, v) {
                this.getCheck().setGroup(g);
                this.getCheck().setVisible(true);
                if (arguments.length &gt; 1) {
                    this.getCheck().setValue(v);
                }
            };

            /**
             * Get content component
             * @return {zebkit.ui.Panel} a content component
             * @method getContent
             */
            this.getContent = function() {
                return this.kids.length &gt; 0 ? this.kids[1] : null;
            };

            /**
             * Get menu item child component to render sub item arrow element
             * @return {zebkit.ui.Panel} a sub item arrow component
             * @method getSub
             * @protected
             */
            this.getSub = function() {
                return this.kids.length &gt; 1 ? this.kids[2] : null;
            };

            this.activateSub = function(b) {
                var kid = this.getSub();
                kid.setState(b ? &quot;pressed&quot; : &quot;*&quot;);
                if (this.parent !== null &amp;&amp; this.parent.noSubIfEmpty === true) {
                    kid.setVisible(b);
                }
            };

            this.$getCheckSize = function() {
                var ch = this.getCheck();
                return ch === null ? { width: 0, height: 0 } : ch.getPreferredSize() ;
            };

            this.$getContentSize = function() {
                var content = this.getContent();
                return (content !== null &amp;&amp; content.isVisible === true) ? content.getPreferredSize()
                                                                        : { width : 0, height : 0 };
            };

            this.$getSubSize = function() {
                var sub = this.getSub();
                return (sub !== null &amp;&amp; sub.isVisible === true) ? sub.getPreferredSize()
                                                                : { width : 0, height : 0 };
            };

            this.calcPreferredSize = function (target){
                var p1 = this.$getCheckSize(),
                    p2 = this.$getContentSize(),
                    p3 = this.$getSubSize(),
                    h  = Math.max(p1.height, p2.height, p3.height),
                    w  = p1.width + p2.width + p3.width,
                    i  = -1;

                if (p1.width &gt; 0) {
                    i++;
                }

                if (p2.width &gt; 0) {
                    i++;
                }

                if (p3.width &gt; 0) {
                    i++;
                }

                return { width: w + (i &gt; 0 ? this.gap * i : 0), height: h };
            };

            this.doLayout = function(target) {
                var left    = this.getCheck(),
                    right   = this.getSub(),
                    content = this.getContent(),
                    p1      = this.$getCheckSize(),
                    p3      = this.$getSubSize(),
                    t       = target.getTop(),
                    l       = target.getLeft(),
                    eh      = target.height - t - target.getBottom(),
                    ew      = target.width  - l - target.getRight();

                if (left !== null &amp;&amp; left.isVisible === true) {
                    left.toPreferredSize();
                    left.setLocation(l, t + Math.floor((eh - left.height)/2));
                }

                var add = (p1.width &gt; 0 ? this.gap : 0) + p1.width;
                l  += add;
                ew -= add;

                if (right !== null &amp;&amp; right.isVisible === true) {
                    right.toPreferredSize();
                    right.setLocation(target.width - target.getRight() - right.width,
                                      t + Math.floor((eh - right.height)/2));
                }
                ew -= ((p3.width &gt; 0 ? this.gap : 0) + p3.width);

                if (content !== null &amp;&amp; content.isVisible === true) {
                    content.toPreferredSize();
                    if (content.width &gt; ew) {
                        content.setSize(ew, content.height);
                    }
                    content.setLocation(l, t + Math.floor((eh - content.height)/2));
                }
            };
        },

        /**
         * Override setParent method to catch the moment when the
         * item is inserted to a menu
         * @param {zebkit.ui.Panel} p a parent
         * @method setParent
         */
        function setParent(p) {
            this.$super(p);
            if (p !== null &amp;&amp; p.noSubIfEmpty === true) {
                this.getSub().setVisible(false);
            }
        }
    ]).hashable();

    /**
     * Menu UI component class. The class implements popup menu UI component.
     *
     *     var m = new Menu([
     *         {
     *             content: &quot;Menu Item 1&quot;,
     *             sub    : [
     *                 {
     *                     content: &quot;SubMenu Checked Item 1&quot;,
     *                     checked: true
     *                 },
     *                 {
     *                     content: &quot;SubMenu Checked Item 2&quot;,
     *                     checked: false
     *                 },
     *                 &quot;-&quot;, // line
     *                 {
     *                     content: &quot;SubMenu Checked Item 3&quot;,
     *                     checked: false
     *                 }
     *         },
     *         &quot;Menu Item 2&quot;,
     *         &quot;Menu Item 3&quot;
     *      ]);
     *
     * @class zebkit.ui.Menu
     * @constructor
     * @param {Object} [list] menu items description
     * @extends zebkit.ui.CompList
     */
    pkg.Menu = Class(pkg.CompList, [
        function (d) {
            this.menus = {};

            this.$super([], zebkit.isBoolean(d) ? d : true);

            if (arguments.length &gt; 0) {
                for(var i = 0; i &lt; d.length; i++) {
                    var item = d[i];
                    this.add(item);
                    if (zebkit.isString(item) === false &amp;&amp; typeof item.sub !== &#x27;undefined&#x27;) {
                        var sub = item.sub;
                        this.setMenuAt(this.kids.length - 1, zebkit.instanceOf(sub, pkg.Menu) ? sub
                                                                                              : new pkg.Menu(sub));
                    }
                }
            }
        },

        function $clazz() {
            this.MenuItem = Class(pkg.MenuItem, [
                function $clazz() {
                    this.Label = Class(pkg.MenuItem.Label, []);
                }
            ]);

            this.Line = Class(pkg.Line, []);
            this.Line.prototype.$isDecorative = true;
        },

        function $prototype() {
            this.$parentMenu = null;

            this.canHaveFocus = true;
            this.noSubIfEmpty = false;

            /**
             * Test if the given menu item is a decorative (not selectable) menu item.
             * Menu item is considered as decorative if it has been added with addDecorative(...)
             * method or has &quot;$isDecorative&quot; property set to &quot;true&quot;
             * @param  {Integer}  i a menu item index
             * @return {Boolean}  true if the given menu item is decorative
             * @method isDecorative
             */
            this.isDecorative = function(i){
                return this.kids[i].$isDecorative === true || this.kids[i].$$isDecorative === true;
            };

            /**
             * Define component events handler.
             * @param  {zebkit.ui.event.CompEvent} e  a component event
             * @method  childCompEnabled
             */
            this.childCompEnabled = this.childCompShown = function(e) {
                var src = e.source;
                for(var i = 0;i &lt; this.kids.length; i++){
                    if (this.kids[i] === src) {
                        // clear selection if an item becomes not selectable
                        if (this.isItemSelectable(i) === false &amp;&amp; (i === this.selectedIndex)) {
                            this.select(-1);
                        }
                        break;
                    }
                }
            };

            /**
             * Get a menu item by the given index
             * @param  {Integer} i a menu item index
             * @return {zebkit.ui.Panel} a menu item component
             * @method getMenuItem
             */
            this.getMenuItem = function(i) {
                if (zebkit.isString(i) === true) {
                    var item = this.byPath(i);
                    if (item !== null) {
                        return item;
                    }

                    for (var k in this.menus) {
                        item = this.menus[k].getMenuItem(i);
                        if (item !== null) {
                            return item;
                        }
                    }
                }
                return this.kids[i];
            };

            /**
             * Test if the menu has a selectable item
             * @return {Boolean} true if the menu has at least one selectable item
             * @method hasSelectableItems
             */
            this.hasSelectableItems = function(){
                for(var i = 0; i &lt; this.kids.length; i++) {
                    if (this.isItemSelectable(i)) {
                        return true;
                    }
                }
                return false;
            };

            /**
             * Define pointer exited events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited = function(e){
                this.position.setOffset(null);
            };

            /**
             * Get a sub menu for the given menu item
             * @param  {Integer} index a menu item index
             * @return {zebkit.ui.Menu} a sub menu or null if no sub menu
             * is defined for the given menu item
             * @method getMenuAt
             */
            this.getMenuAt = function(index) {
                if (index &lt; this.kids.length) {
                    var hash = this.kids[index].$hash$;
                    return this.menus.hasOwnProperty(hash) ? this.menus[hash] : null;
                } else {
                    return null;
                }
            };

            // TODO: not stable API
            this.menuById = function(id) {
                if (this.id === id) {
                    return this;
                } else {
                    for (var i = 0; i &lt; this.kids.length; i++)  {
                        var m = this.getMenuAt(i);
                        if (m !== null) {
                            var res = m.menuById(id);
                            if (res !== null) {
                                return res;
                            }
                        }
                    }
                    return null;
                }
            };

            // TODO: not stable API
            this.menuItemById = function(id) {
                for (var i = 0; i &lt; this.kids.length; i++)  {
                    var mi = this.kids[i];
                    if (mi !== null &amp;&amp; mi.id === id) {
                        return mi;
                    } else {
                        var m = this.getMenuAt(i);
                        if (m !== null) {
                            var res = m.menuItemById(id);
                            if (res !== null) {
                                return res;
                            }
                        }
                    }
                }
                return null;
            };

            /**
             * Set the given menu as a sub-menu for the specified menu item
             * @param {Integer} i an index of a menu item for that a sub menu
             * has to be attached
             * @param {zebkit.ui.Menu} m a sub menu to be attached
             * @method setMenuAt
             * @chainable
             */
            this.setMenuAt = function (i, m) {
                if (m === this) {
                    throw new Error(&quot;Menu cannot be sub-menu of its own&quot;);
                }

                if (this.isDecorative(i)) {
                    throw new Error(&quot;Decorative element cannot have a sub-menu&quot;);
                }

                var p = this.kids[i];
                if (typeof p.activateSub !== &#x27;undefined&#x27;) {
                    var sub = this.menus[p];
                    if (m !== null) {
                        if (sub == null) {
                            p.activateSub(true);
                        }
                    } else if (sub != null) {
                        p.activateSub(false);
                    }
                }

                // if the menu is shown and the menu item is selected
                if (this.parent !== null &amp;&amp; i === this.selectedIndex) {
                    this.select(-1);
                }

                if (typeof p.$hash$ === &#x27;undefined&#x27;) {
                    throw new Error(&quot;Invalid key&quot;);
                }

                this.menus[p] = m;
                return this;
            };

            /**
             * Get the specified sub-menu index
             * @param  {zebkit.ui.Menu} menu a sub menu
             * @return {Integer} a sub menu index. -1 if the menu is
             * not a sub menu of the given menu
             * @method indexMenuOf
             */
            this.indexMenuOf = function(menu) {
                for(var i = 0; i &lt; this.kids.length; i++) {
                    if (this.menus[this.kids[i]] === menu) {
                        return i;
                    }
                }
                return -1;
            };

            /**
             * Called when the menu or a sub-menu has been canceled (key ESCAPE has been pressed).
             * @param  {zebkit.ui.Menu} m a menu (or sub menu) that has been canceled
             * @method $canceled
             * @protected
             */
            this.$canceled = function(m) {
                if (this.$parentMenu !== null &amp;&amp; typeof this.$canceled !== &#x27;undefined&#x27;) {
                    this.$parentMenu.$canceled(m);
                }
            };

            /**
             * Get the top menu in the given shown popup menu hierarchy
             * @return {zebkit.ui.Menu} a top menu
             * @method $topMenu
             * @protected
             */
            this.$topMenu = function() {
                if (this.parent !== null) {
                    var t = this,
                        p = null;

                    while ((p = t.$parentMenu) !== null) {
                        t = p;
                    }
                    return t;
                }
                return null;
            };

            this.doScroll = function(dx, dy, source) {
                var sy = this.scrollManager.getSY(),
                    ps = this.layout.calcPreferredSize(this),
                    eh = this.height - this.getTop() - this.getBottom();

                if (this.height &lt; ps.height &amp;&amp; sy + ps.height &gt;= eh &amp;&amp; sy - dy &lt;= 0) {
                    var nsy = sy - dy;
                    if (nsy + ps.height &lt; eh) {
                        nsy = eh - ps.height;
                    }
                    if (sy !== nsy) {
                        this.scrollManager.scrollYTo(nsy);
                    }
                }
            };

            /**
             * Hide the menu and all visible sub-menus
             * @method $hideMenu
             * @protected
             */
            this.$hideMenu = function() {
                if (this.parent !== null) {
                    var ch = this.$childMenu();
                    if (ch !== null) {
                        ch.$hideMenu();
                    }

                    this.removeMe();
                    this.select(-1);
                }
            };

            /**
             * Get a sub menu that is shown at the given moment.
             * @return {zebkit.ui.Menu} a child sub menu. null if no child sub-menu
             * has been shown
             * @method $childMenu
             * @protected
             */
            this.$childMenu = function() {
                if (this.parent !== null) {
                    for(var k in this.menus) {
                        var m = this.menus[k];
                        if (m.$parentMenu === this) {
                            return m;
                        }
                    }
                }
                return null;
            };

            /**
             * Show the given sub menu
             * @param  {zebkit.ui.Menu} sub a sub menu to be shown
             * @method $showSubMenu
             * @protected
             */
            this.$showSubMenu = function(sub) {
                sub.setLocation(this.x + this.width - 10,
                                this.y + this.kids[this.selectedIndex].y);
                sub.toPreferredSize();
                this.parent.add(sub);
                sub.requestFocus();
            };

            this.triggerSelectionByPos = function(i) {
                return this.getMenuAt(i) !== null &amp;&amp; this.$triggeredByPointer === true;
            };
        },

        /**
         * Override key pressed events handler to handle key events according to
         * context menu component requirements
         * @param  {zebkit.ui.event.KeyEvent} e a key event
         * @method keyPressed
         */
        function keyPressed(e){
            if (e.code === &quot;Escape&quot;) {
                if (this.parent !== null) {
                    var p = this.$parentMenu;
                    this.$canceled(this);
                    this.$hideMenu();
                    if (p !== null) {
                        p.requestFocus();
                    }
                }
            } else {
                this.$super(e);
            }
        },

        function insert(i, ctr, c) {
            if (zebkit.isString(c)) {
                return this.$super(i, ctr, (c.match(/^\-+$/) !== null) ? new this.clazz.Line()
                                                                       : new this.clazz.MenuItem(c));
            } else if (zebkit.instanceOf(c, pkg.Panel)) {
                return this.$super(i, ctr, c);
            } else {
                return this.$super(i, ctr, new this.clazz.MenuItem(c));
            }
        },

        function setParent(p) {
            if (p !== null) {
                this.select(-1);
                this.position.setOffset(null);
            } else {
                this.$parentMenu = null;
            }
            this.$super(p);
        },

        /**
         * Add the specified component as a decorative item of the menu
         * @param {zebkit.ui.Panel} c an UI component
         * @method addDecorative
         */
        function addDecorative(c) {
            if (c.$isDecorative !== true) {
                c.$$isDecorative = true;
            }
            this.$getSuper(&quot;insert&quot;).call(this, this.kids.length, null, c);
        },

        function kidRemoved(i, c) {
            if (typeof c.$$isDecorative !== &#x27;undefined&#x27;) {
                delete c.$$isDecorative;
            }
            this.setMenuAt(i, null);
            this.$super(i, c);
        },

        function isItemSelectable(i) {
            return this.$super(i) &amp;&amp; this.isDecorative(i) === false;
        },

        function posChanged(target,prevOffset,prevLine,prevCol) {
            var off = target.offset;

            if (off &gt;= 0) {
                var rs = null;

                // hide previously shown sub menu if position has been re-newed
                if (this.selectedIndex &gt;= 0  &amp;&amp; off !== this.selectedIndex) {
                    var sub = this.getMenuAt(this.selectedIndex);
                    if (sub !== null) {
                        sub.$hideMenu();
                        rs = -1; // request to clear selection
                        this.requestFocus();
                    }
                }

                // request fire selection if the menu is shown and position has moved to new place
                if (this.parent !== null &amp;&amp; off !== this.selectedIndex &amp;&amp; this.isItemSelectable(off)) {
                    if (this.triggerSelectionByPos(off)) {
                        rs = off;
                    }
                }

                if (rs !== null) {
                    this.select(rs);
                }
            }

            this.$super(target, prevOffset, prevLine, prevCol);
        },

        function fireSelected(prev) {
            if (this.parent !== null) {
                var sub = null;

                if (this.selectedIndex &gt;= 0) {
                    sub = this.getMenuAt(this.selectedIndex);
                    if (sub !== null) { // handle sub menu here
                        if (sub.parent !== null) {
                            // hide menu since it has been already shown
                            sub.$hideMenu();
                        } else {
                            // show menu
                            sub.$parentMenu = this;
                            this.$showSubMenu(sub);
                        }
                    } else {
                        // handle an item menu selection here.
                        // hide the whole menu hierarchy
                        var k = this.kids[this.selectedIndex];
                        if (typeof k.itemSelected !== &#x27;undefined&#x27;) {
                            k.itemSelected();
                        }

                        pkg.events.fire(&quot;menuItemSelected&quot;,
                                        MENU_EVENT.$fillWith(this,
                                                             this.selectedIndex,
                                                             this.kids[this.selectedIndex]));


                        // an atomic menu, what means a menu item has been selected
                        // remove this menu an all parents menus
                        var top = this.$topMenu();
                        if (top !== null) {
                            top.$hideMenu();
                        }
                    }

                } else if (prev &gt;= 0) {
                    // hide child menus if null item has been selected
                    sub = this.getMenuAt(prev);
                    if (sub !== null &amp;&amp; sub.parent !== null) {
                        // hide menu since it has been already shown
                        sub.$hideMenu();
                    }
                }
            }
            this.$super(prev);
        }
    ]);

    /**
     * Menu bar UI component class. Menu bar can be build in any part of UI application.
     * There is no restriction regarding the placement of the component.

            var canvas = new zebkit.ui.zCanvas(300,200);
            canvas.setLayout(new zebkit.layout.BorderLayout());

            var mbar = new zebkit.ui.Menubar({
                &quot;Item 1&quot;: {
                    &quot;Subitem 1.1&quot;:null,
                    &quot;Subitem 1.2&quot;:null,
                    &quot;Subitem 1.3&quot;:null
                },
                &quot;Item 2&quot;: {
                    &quot;Subitem 2.1&quot;:null,
                    &quot;Subitem 2.2&quot;:null,
                    &quot;Subitem 2.3&quot;:null
                },
                &quot;Item 3&quot;: null
            });

            canvas.root.add(&quot;bottom&quot;, mbar);

     * @class zebkit.ui.Menubar
     * @constructor
     * @extends zebkit.ui.Menu
     */
    pkg.Menubar = Class(pkg.Menu, [
        function $clazz() {
            this.MenuItem = Class(pkg.MenuItem, [
                function(c) {
                    this.$super(c);
                    this.getSub().setVisible(false);
                    this.getCheck().setVisible(false);
                },

                function $prototype() {
                    this.$getCheckSize = function() {
                        return pkg.$getPS(this.getCheck());
                    };
                },

                function $clazz() {
                    this.Label = Class(pkg.MenuItem.Label, []);
                }
            ]);
        },

        function $prototype() {
            this.canHaveFocus = false;

            this.triggerSelectionByPos = function (i) {
                return this.isItemSelectable(i) &amp;&amp; this.selectedIndex &gt;= 0;
            };

            // making menu bar not removable from its layer by overriding the method
            this.$hideMenu = function() {
                var child = this.$childMenu();
                if (child !== null) {
                    child.$hideMenu();
                }

                this.select(-1);
            };

            this.$showSubMenu = function(menu) {
                var d   = this.getCanvas(),
                    k   = this.kids[this.selectedIndex],
                    pop = d.getLayer(pkg.PopupLayer.id);

                if (menu.hasSelectableItems()) {
                    var abs = zebkit.layout.toParentOrigin(0, 0, k);
                    menu.setLocation(abs.x, abs.y + k.height + 1);
                    menu.toPreferredSize();
                    pop.add(menu);
                    menu.requestFocus();
                }
            };

            this.$canceled = function(m) {
                this.select(-1);
            };
        },

        // called when an item is selected by user with pointer click or key
        function $select(i) {
            // if a user again pressed the same item consider it as
            // de-selection
            if (this.selectedIndex &gt;= 0 &amp;&amp; this.selectedIndex === i) {
                i = -1;
            }
            this.$super(i);
        }
    ]);

    pkg.PopupLayerLayout = Class(zebkit.layout.Layout, [
        function $prototype() {
            this.calcPreferredSize = function (target){
                return { width:0, height:0 };
            };

            this.doLayout = function(target) {
                for(var i = 0; i &lt; target.kids.length; i++){
                    var m = target.kids[i];
                    if (zebkit.instanceOf(m, pkg.Menu)) {
                        var ps = m.getPreferredSize(),
                            xx = (m.x + ps.width  &gt; target.width ) ? target.width  - ps.width  : m.x,
                            yy = (m.y + ps.height &gt; target.height) ? target.height - ps.height : m.y;

                        m.setSize(ps.width, ps.height);
                        if (xx &lt; 0) {
                            xx = 0;
                        }
                        if (yy &lt; 0) {
                            yy = 0;
                        }
                        m.setLocation(xx, yy);
                    }
                }
            };
        }
    ]);

    /**
     * UI popup layer interface that defines common part of popup layer
     * implementation.
     * @class zebkit.ui.PopupLayerMix
     * @interface zebkit.ui.PopupLayerMix
     */
    pkg.PopupLayerMix = zebkit.Interface([
        function $clazz() {
            this.id = &quot;popup&quot;;
        },

        function $prototype() {
            this.$prevFocusOwner = null;

            this.getFocusRoot = function() {
                return this;
            };

            this.childFocusGained = function(e) {
                if (zebkit.instanceOf(e.source, pkg.Menu)) {
                    if (e.related !== null &amp;&amp; zebkit.layout.isAncestorOf(this, e.related) === false ) {
                        this.$prevFocusOwner = e.related;
                    }
                } else {
                    // means other than menu type of component grabs the focus
                    // in this case we should not restore focus when the popup
                    // component will be removed
                    this.$prevFocusOwner = null;
                }

                // save the focus owner whose owner was not a pop up layer
                if (e.related !== null &amp;&amp; zebkit.layout.isAncestorOf(this, e.related) === false &amp;&amp; zebkit.instanceOf(e.source, pkg.Menu)) {
                    this.$prevFocusOwner = e.related;
                }
            };

            this.isTriggeredWith = function(e) {
                return e.isAction() === false &amp;&amp; (e.identifier === &quot;rmouse&quot; || e.touchCounter === 2);
            };

            /**
             * Define children components input events handler.
             * @param  {zebkit.ui.event.KeyEvent} e an input event
             * @method childKeyPressed
             */
            this.childKeyPressed = function(e){
                var p = e.source.$parentMenu;
                if (typeof p !== &#x27;undefined&#x27; &amp;&amp; p !== null) {
                    switch (e.code) {
                        case &quot;ArrowRight&quot; :
                            if (p.selectedIndex &lt; p.model.count() - 1) {
                                p.requestFocus();
                                p.position.seekLineTo(&quot;down&quot;);
                            }
                            break;
                        case &quot;ArrowLeft&quot; :
                            if (p.selectedIndex &gt; 0) {
                                p.requestFocus();
                                p.position.seekLineTo(&quot;up&quot;);
                            }
                            break;
                    }
                }
            };

            this.$topMenu = function() {
                if (this.kids.length &gt; 0) {
                    for (var i = this.kids.length - 1; i &gt;= 0; i--) {
                        if (zebkit.instanceOf(this.kids[i], pkg.Menu)) {
                            return this.kids[i].$topMenu();
                        }
                    }
                }
                return null;
            };

            this.compRemoved = function(e) {
                // if last component has been removed and the component is a menu
                // than try to restore focus owner
                if (this.$prevFocusOwner !== null &amp;&amp; this.kids.length === 0 &amp;&amp; zebkit.instanceOf(e.kid, pkg.Menu)) {
                    this.$prevFocusOwner.requestFocus();
                    this.$prevFocusOwner = null;
                }
            };

            this.layerPointerClicked = function (e) {
                if (this.kids.length === 0 &amp;&amp; this.isTriggeredWith(e)) {
                    var popup = null;
                    if (typeof e.source.popup !== &#x27;undefined&#x27; &amp;&amp; e.source.popup !== null) {
                        popup = e.source.popup;
                    } else if (typeof e.source.getPopup !== &#x27;undefined&#x27;) {
                        popup = e.source.getPopup(e.source, e.x, e.y);
                    }

                    if (popup !== null) {
                        popup.setLocation(e.absX, e.absY);
                        this.add(popup);
                        popup.requestFocus();
                    }

                    return true;
                }
                return false;
            };
        },

        function layerPointerPressed(e) {
            // if a shown menu exists
            if (this.kids.length &gt; 0) {
                // if pressed has happened over a popup layer no a menu
                if (this.$getSuper(&quot;getComponentAt&quot;).call(this, e.x, e.y) === this) {
                    var top = this.$topMenu();
                    if (top !== null) {
                        // if top menu is menu bar. menu bar is located in other layer
                        // we need check if the pressed has happened not over the
                        // menu bar
                        if (zebkit.instanceOf(top, pkg.Menubar)) {
                            var origin = zebkit.layout.toParentOrigin(top);
                            if (e.x &gt;= origin.x &amp;&amp; e.y &gt;= origin.y &amp;&amp; e.x &lt; origin.x + top.width &amp;&amp; e.y &lt; origin.y + top.height) {
                                return;
                            }
                        }

                        // hide all shown menu
                        top.$hideMenu();
                    }

                    // still have a pop up components, than remove it
                    if (this.kids.length &gt; 0) {
                        this.removeAll();
                    }
                }
            }
        },

        function getComponentAt(x, y) {
            // if there is a component on popup layer and the component is
            // not the popup layer itself than return the component otherwise
            // return null what delegates getComponentAt() to other layer
            if (this.kids.length &gt; 0) {
                var comp = this.$super(x, y);
                if (comp !== this) {
                    return comp;
                }
            }
            return null;
        }
    ]);

    /**
     * Simple popup layer implementation basing on &quot;zebkit.ui.Panel&quot; component.
     * @class zebkit.ui.PopupLayer
     * @extends zebkit.ui.Panel
     * @constructor
     * @uses zebkit.ui.PopupLayerMix
     */
    pkg.PopupLayer = Class(pkg.Panel, pkg.PopupLayerMix, []);


    pkg.events.regEvents(&#x27;winOpened&#x27;, &#x27;winActivated&#x27;);

    /**
     * Window component event
     * @constructor
     * @class zebkit.ui.event.WinEvent
     * @extends zebkit.util.Event
     */
    pkg.event.WinEvent = Class(zebkit.util.Event, [
        function $prototype() {
            /**
             * Indicates if the window has been shown
             * @attribute isShown
             * @type {Boolean}
             * @readOnly
             */
            this.isShown = false;

            /**
             * Indicates if the window has been activated
             * @attribute isActive
             * @type {Boolean}
             * @readOnly
             */
             this.isActive = false;

            /**
             * Layer the source window belongs to
             * @type {zebkit.ui.Panel}
             * @attribute layer
             * @readOnly
             */
            this.layer = null;

            /**
             * Fill the event with parameters
             * @param  {zebkit.ui.Panel}  src  a source window
             * @param  {zebkit.ui.Panel}  layer  a layer the window belongs to
             * @param  {Boolean} isActive boolean flag that indicates the window status
             * @param  {Boolean} isShown  boolean flag that indicates the window visibility
             * @chainable
             * @method  $fillWidth
             */
            this.$fillWith = function(src, layer, isActive, isShown) {
                this.source = src;

                this.layer    = layer;
                this.isActive = isActive;
                this.isShown  = isShown;
                return this;
            };
        }
    ]);

    var WIN_EVENT = new pkg.event.WinEvent();

    /**
     * Show the given UI component as a modal window
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {zebkit.ui.Panel} win a component to be shown as the modal window
     * @for  zebkit.ui
     * @method showModalWindow
     */
    pkg.showModalWindow = function(context, win) {
        pkg.showWindow(context, &quot;modal&quot;, win);
    };

    /**
     * Show the given UI component as a window
     * @param  {zebkit.ui.Panel} context  an UI component of zebkit hierarchy
     * @param  {String} [type] a type of the window: &quot;modal&quot;, &quot;mdi&quot;, &quot;info&quot;. The default
     * value is &quot;info&quot;
     * @param  {zebkit.ui.Panel} win a component to be shown as the window
     * @for  zebkit.ui
     * @method showWindow
     */
    pkg.showWindow = function(context, type, win) {
        if (arguments.length &lt; 3) {
            win  = type;
            type = &quot;info&quot;;
        }
        return context.getCanvas().getLayer(&quot;win&quot;).addWin(type, win);
    };

    /**
     * Activate the given window or a window the specified component belongs
     * @param  {zebkit.ui.Panel} win an UI component to be activated
     * @for zebkit.ui
     * @method activateWindow
     */
    pkg.activateWindow = function(win) {
        var l = win.getCanvas().getLayer(&quot;win&quot;);
        l.activate(zebkit.layout.getDirectChild(l, win));
    };

    /**
     * Window layer class. Window layer is supposed to be used for showing
     * modal and none modal internal window. There are special ready to use
     * &quot;zebkit.ui.Window&quot; UI component that can be shown as internal window, but
     * zebkit allows developers to show any UI component as modal or none modal
     * window. Add an UI component to window layer to show it as modal o none
     * modal window:

            // create canvas
            var canvas   = new zebkit.ui.zCanvas();

            // get windows layer
            var winLayer = canvas.getLayer(zebkit.ui.WinLayerMix.id);

            // create standard UI window component
            var win = new zebkit.ui.Window();
            win.setBounds(10,10,200,200);

            // show the created window as modal window
            winLayer.addWin(&quot;modal&quot;, win);

     * Also shortcut method can be used

            // create canvas
            var canvas   = new zebkit.ui.zCanvas();

            // create standard UI window component
            var win = new zebkit.ui.Window();
            win.setBounds(10,10,200,200);

            // show the created window as modal window
            zebkit.ui.showModalWindow(canvas, win);

     * Window layer supports three types of windows:

        - **&quot;modal&quot;** a modal window catches all input till it will be closed
        - **&quot;mdi&quot;** a MDI window can get focus, but it doesn&#x27;t block switching
        focus to other UI elements
        - **&quot;info&quot;** an INFO window cannot get focus. It is supposed to show
        some information like tooltip.

     * @class zebkit.ui.WinLayer
     * @constructor
     * @extends zebkit.ui.HtmlCanvas
     */
    pkg.WinLayerMix = zebkit.Interface([
        function $clazz() {
            this.id = &quot;win&quot;;
        },

        function $prototype() {
            /**
             * Currently activated as a window children component
             * @attribute activeWin
             * @type {zebkit.ui.Panel}
             * @readOnly
             * @protected
             */
            this.activeWin = null;

            this.topModalIndex = -1;

            this.layerPointerPressed = function(e) {
                if (this.kids.length &gt; 0) {

                    // I) check most probable variant - pressed has occurred inside an active window that
                    // is placed on the top of all other windows
                    if (this.activeWin !== null) {
                        if (this.indexOf(this.activeWin) === this.kids.length - 1) {
                            var x1 = this.activeWin.x,
                                y1 = this.activeWin.y,
                                x2 = x1 + this.activeWin.width,
                                y2 = y1 + this.activeWin.height;

                            // pressed has occurred inside the topest active window, so let process
                            // goes normally by calling winLayer.getComponetAt(x,y)
                            if (e.x &gt;= x1 &amp;&amp; e.y &gt;= y1 &amp;&amp; e.x &lt;= x2 &amp;&amp; e.y &lt;= y2) {
                                return false;
                            }
                        }
                    }

                    // II) otherwise looking for a window starting from the topest one where the
                    // pressed event has occurred. Pay attention modal window can open MDI windows
                    for(var i = this.kids.length - 1; i &gt;= 0 &amp;&amp; i &gt;= this.topModalIndex; i--) {
                        var d = this.kids[i];

                        if (d.isVisible === true  &amp;&amp;   // check pressed is inside of a MDI window that
                            d.isEnabled === true  &amp;&amp;   // is shown after currently active modal window
                            d.winType  !== &quot;info&quot; &amp;&amp;
                            e.x &gt;= d.x            &amp;&amp;
                            e.y &gt;= d.y            &amp;&amp;
                            e.x &lt; d.x + d.width   &amp;&amp;
                            e.y &lt; d.y + d.height     )
                        {
                            if (d !== this.activeWin) {
                                this.activate(d);
                                return true;
                            } else {
                                return false;  // we are inside activated modal window
                            }
                        }
                    }

                    // III) Check if have to deactivate active MDI window since on prev. step we could not find
                    // a target window  what means pressed was outside of a window
                    if (this.topModalIndex &lt; 0 &amp;&amp; this.activeWin !== null) { // no a modal window has been shown
                        this.activate(null);
                        return false;
                    }

                    return this.topModalIndex &gt;= 0;
                }

                return false;
            };

            this.layerKeyPressed = function(e){
                if (this.kids.length &gt; 0 &amp;&amp;
                    e.code === &quot;Tab&quot;     &amp;&amp;
                    e.shiftKey === true     )
                {
                    if (this.activeWin === null) {
                        this.activate(this.kids[this.kids.length - 1]);
                    } else {
                        var winIndex = this.kids.indexOf(this.activeWin) - 1;
                        if (winIndex &lt; this.topModalIndex || winIndex &lt; 0) {
                            winIndex = this.kids.length - 1;
                        }
                        this.activate(this.kids[winIndex]);
                    }

                    return true;
                }
                return false;
            };

            /**
             * Define children components input events handler.
             * @param  {zebkit.ui.event.FocusEvent} e a focus event
             * @method childFocusGained
             */
            this.childFocusGained = function (e) {
                this.activate(zebkit.layout.getDirectChild(this, e.source));
            };

            this.getFocusRoot = function() {
                return this.activeWin;
            };

            this.getWinType = function(w) {
                return w.winType;
            };

            /**
             * Activate the given win layer children component window.
             * @param  {zebkit.ui.Panel} c a component to be activated as window
             * @method activate
             */
            this.activate = function(c) {
                if (c !== null &amp;&amp; (this.kids.indexOf(c) &lt; 0 ||
                                   c.winType === &quot;info&quot;))
                {
                    throw new Error(&quot;Window cannot be activated&quot;);
                }

                if (c !== this.activeWin) {
                    var old = this.activeWin;

                    if (c === null) {
                        var type = this.activeWin.winType;
                        if (type === &quot;modal&quot;) {
                            throw new Error(&quot;Modal window cannot be de-activated&quot;);
                        }

                        this.activeWin = null;
                        pkg.events.fire(&quot;winActivated&quot;, WIN_EVENT.$fillWith(old, this, false, false));

                        // TODO: special flag $dontGrabFocus is not very elegant solution
                        if (type === &quot;mdi&quot; &amp;&amp; old.$dontGrabFocus !== true) {
                            pkg.focusManager.requestFocus(null);
                        }
                    } else {
                        if (this.kids.indexOf(c) &lt; this.topModalIndex) {
                            throw new Error();
                        }

                        this.activeWin = c;
                        this.activeWin.toFront();

                        if (old !== null) {
                            pkg.events.fire(&quot;winActivated&quot;, WIN_EVENT.$fillWith(old, this, false, false));
                        }

                        pkg.events.fire(&quot;winActivated&quot;, WIN_EVENT.$fillWith(c, this, true, false));
                        this.activeWin.validate();

                        // TODO: special flag $dontGrabFocus is not very elegant
                        if (this.activeWin.winType === &quot;mdi&quot; &amp;&amp; this.activeWin.$dontGrabFocus !== true) {
                            var newFocusable = pkg.focusManager.findFocusable(this.activeWin);
                            pkg.focusManager.requestFocus(newFocusable);
                        }
                    }
                }
            };

            /**
             * Add the given window with the given type and the listener to the layer.
             * @param {String} [type]   a type of the window: &quot;modal&quot;,
             * &quot;mdi&quot; or &quot;info&quot;
             * @param {zebkit.ui.Panel} win an UI component to be shown as window
             * @method addWin
             */
            this.addWin = function(type, win) {
                // check if window type argument has been passed
                if (arguments.length &gt; 1) {
                    win.winType = type;
                }
                this.add(win);
            };

            this.getComponentAt = function(x, y) {
                return (this.activeWin === null) ? null
                                                 : this.activeWin.getComponentAt(x - this.activeWin.x,
                                                                                 y - this.activeWin.y);
            };
        },

        function kidAdded(index, constr, lw){
            this.$super(index, constr, lw);

            if (typeof lw.winType === &#x27;undefined&#x27;) {
                lw.winType = &quot;mdi&quot;;
            } else {
                zebkit.util.$validateValue(lw.winType, &quot;mdi&quot;, &quot;modal&quot;, &quot;info&quot;);
            }

            if (lw.winType === &quot;modal&quot;) {
                this.topModalIndex = this.kids.length - 1;
                pkg.events.fire(&quot;winOpened&quot;, WIN_EVENT.$fillWith(lw, this, false, true));
                this.activate(lw);
            } else {
                pkg.events.fire(&quot;winOpened&quot;, WIN_EVENT.$fillWith(lw, this, false, true));
            }
        },

        function kidRemoved(index, lw){
            this.$getSuper(&quot;kidRemoved&quot;).call(this, index, lw);

            if (this.activeWin === lw) {
                this.activeWin = null;
                // TODO:  deactivated event can be used as a trigger of a window closing so
                // it is better don&#x27;t fire it here this.fire(&quot;winActivated&quot;, lw, l);
                if (lw.winType === &quot;mdi&quot; &amp;&amp; lw.$dontGrabFocus !== true) {
                    pkg.focusManager.requestFocus(null);
                }
            }

            var ci = this.kids.indexOf(lw);
            if (ci &lt; this.topModalIndex) { // correct top modal window index
                this.topModalIndex--;
            } else if (this.topModalIndex === ci) {
                // looking for a new modal window
                for (this.topModalIndex = this.kids.length - 1; this.topModalIndex &gt;= 0; this.topModalIndex--){
                    if (this.kids[this.topModalIndex].winType === &quot;modal&quot;) {
                        break;
                    }
                }
            }

            pkg.events.fire(&quot;winOpened&quot;, WIN_EVENT.$fillWith(lw, this, false, false));

            if (this.topModalIndex &gt;= 0) {
                var aindex = this.kids.length - 1;
                while (this.kids[aindex].winType === &quot;info&quot;) {
                    aindex--;
                }
                this.activate(this.kids[aindex]);
            }
        }
    ]);

    pkg.WinLayer = Class(pkg.Panel, pkg.WinLayerMix, []);

    /**
     * Window UI component class. Implements window like UI component. The window component has a header,
     * status bar and content areas. The header component is usually placed at the top of window, the
     * status bar component is placed at the bottom and the content component at places the central part
     * of the window. Also the window defines corner UI component that is supposed to be used to resize
     * the window. The window implementation provides the following possibilities:

        - Move window by dragging the window on its header
        - Resize window by dragging the window corner element
        - Place buttons in the header to maximize, minimize, close, etc the window
        - Indicates state of window (active or inactive) by changing
        the widow header style
        - Define a window icon component
        - Define a window status bar component

     * @class zebkit.ui.Window
     *
     * @param {String} [s] a window title
     * @param {zebkit.ui.Panel} [c] a window content
     * @constructor
     * @extends zebkit.ui.Panel
     */
    pkg.Window = Class(pkg.StatePan, [
        function (s, c) {
            //!!! for some reason state has to be set beforehand
            this.state = &quot;inactive&quot;;

            this.prevH = this.prevX = this.prevY = 0;
            this.px = this.py = this.dx = this.dy = 0;
            this.prevW = this.action = -1;

            /**
             * Root window panel. The root panel has to be used to
             * add any UI components
             * @attribute root
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.root = (c === null || arguments.length &lt; 2 ? this.createContentPan() : c);

            /**
             * Window caption panel. The panel contains window
             * icons, button and title label
             * @attribute caption
             * @type {zebkit.ui.Panel}
             * @readOnly
             */
            this.caption = this.createCaptionPan();

            /**
             * Window title component
             * @type {zebkit.ui.Panel}
             * @attribute title
             * @readOnly
             */
            this.title = this.createTitle();
            this.title.setValue((s === null || arguments.length === 0 ? &quot;&quot; : s));

            /**
             * Icons panel. The panel can contain number of icons.
             * @type {zebkit.ui.Panel}
             * @attribute icons
             * @readOnly
             */
            this.icons = new pkg.Panel(new zebkit.layout.FlowLayout(&quot;left&quot;, &quot;center&quot;, &quot;horizontal&quot;, 2));
            this.icons.add(new this.clazz.Icon());

            /**
             * Window buttons panel. The panel can contain number of window buttons
             * @type {zebkit.ui.Panel}
             * @attribute buttons
             * @readOnly
             */
            this.buttons = new pkg.Panel(new zebkit.layout.FlowLayout(&quot;center&quot;, &quot;center&quot;));

            this.caption.add(&quot;center&quot;, this.title);
            this.caption.add(&quot;left&quot;, this.icons);
            this.caption.add(&quot;right&quot;, this.buttons);

            /**
             * Window status panel.
             * @attribute status
             * @readOnly
             * @type {zebkit.ui.Panel}
             */
            this.status = new this.clazz.StatusPan();
            this.sizer  = new this.clazz.SizerPan();
            this.status.add(this.sizer);

            this.setSizeable(true);

            this.$super();
            this.setLayout(new zebkit.layout.BorderLayout(2,2));

            this.add(&quot;center&quot;, this.root);
            this.add(&quot;top&quot;, this.caption);
            this.add(&quot;bottom&quot;, this.status);
        },

        function $clazz() {
            this.CaptionPan = Class(pkg.StatePan, [
                function $prototype() {
                    this.state = &quot;inactive&quot;;
                }
            ]);

            this.TitleLab   = Class(pkg.Label, []);
            this.StatusPan  = Class(pkg.Panel, []);
            this.ContentPan = Class(pkg.Panel, []);
            this.SizerPan   = Class(pkg.ViewPan, []);
            this.Icon       = Class(pkg.ImagePan, []);
            this.Button     = Class(pkg.Button, []);
        },

        function $prototype() {
            var MOVE_ACTION = 1, SIZE_ACTION = 2;

            this.sizer = this.caption = null;

            this.isPopupEditor = true;

            /**
             * Minimal possible size of the window
             * @default 40
             * @attribute minSize
             * @type {Integer}
             */
            this.minSize = 40;

            /**
             * Indicate if the window can be resized by dragging its by corner
             * @attribute isSizeable
             * @type {Boolean}
             * @default true
             * @readOnly
             */
            this.isSizeable = true;

            /**
             * Test if the window is shown as a window and activated
             * @return {Boolean} true is the window is shown as internal window and
             * is active.
             * @method isActive
             */
            this.isActive = function() {
                var c = this.getCanvas();
                return c !== null &amp;&amp; c.getLayer(&quot;win&quot;).activeWin === this.getWinContainer();
            };

            this.pointerDragStarted = function(e){
                this.px = e.absX;
                this.py = e.absY;
                this.action = this.insideCorner(e.x, e.y) ? (this.isSizeable ? SIZE_ACTION : -1)
                                                          : MOVE_ACTION;
                if (this.action &gt; 0) {
                    this.dy = this.dx = 0;
                }
            };

            this.pointerDragged = function(e){
                if (this.action &gt; 0) {
                    var container = null;

                    if (this.action !== MOVE_ACTION){
                        container = this.getWinContainer();

                        var nw = this.dx + container.width,
                            nh = this.dy + container.height;

                        if (nw &gt; this.minSize &amp;&amp; nh &gt; this.minSize) {
                            container.setSize(nw, nh);
                        }
                    }

                    this.dx = (e.absX - this.px);
                    this.dy = (e.absY - this.py);
                    this.px = e.absX;
                    this.py = e.absY;
                    if (this.action === MOVE_ACTION){
                        container = this.getWinContainer();
                        container.setLocation(this.dx + container.x, this.dy + container.y);
                    }
                }
            };

            this.pointerDragEnded = function(e){
                if (this.action &gt; 0){
                    if (this.action === MOVE_ACTION){
                        var container = this.getWinContainer();
                        container.setLocation(this.dx + container.x, this.dy + container.y);
                    }
                    this.action = -1;
                }
            };

            this.getWinContainer = function() {
                return this;
            };

            /**
             * Test if the pointer cursor is inside the window corner component
             * @protected
             * @param  {Integer} px a x coordinate of the pointer cursor
             * @param  {Integer} py a y coordinate of the pointer cursor
             * @return {Boolean}  true if the pointer cursor is inside window
             * corner component
             * @method insideCorner
             */
            this.insideCorner = function(px,py){
                return this.getComponentAt(px, py) === this.sizer;
            };

            this.getCursorType = function(target,x,y){
                return (this.isSizeable &amp;&amp; this.insideCorner(x, y)) ? pkg.Cursor.SE_RESIZE
                                                                    : null;
            };

            this.catchInput = function(c){
                var tp = this.caption;
                return c === tp ||
                      (zebkit.layout.isAncestorOf(tp, c) &amp;&amp; zebkit.instanceOf(c, pkg.Button) === false) ||
                       this.sizer === c;
            };

            this.winOpened = function(e) {
                var state = this.isActive() ? &quot;active&quot; : &quot;inactive&quot;;
                if (this.caption !== null &amp;&amp; typeof this.caption.setState !== &#x27;undefined&#x27;) {
                    this.caption.setState(state);
                }
                this.setState(state);
            };

            this.winActivated = function(e) {
                this.winOpened(e);
            };

            this.pointerDoubleClicked = function (e){
                var x = e.x, y = e.y, cc = this.caption;
                if (this.isSizeable === true &amp;&amp;
                    x &gt; cc.x &amp;&amp;
                    x &lt; cc.y + cc.width &amp;&amp;
                    y &gt; cc.y &amp;&amp;
                    y &lt; cc.y + cc.height)
                {
                    if (this.prevW &lt; 0) {
                        this.maximize();
                    } else {
                        this.restore();
                    }
                }
            };

            /**
             * Test if the window has been maximized to occupy the whole
             * window layer space.
             * @return {Boolean} true if the window has been maximized
             * @method isMaximized
             */
            this.isMaximized = function() {
                return this.prevW !== -1;
            };

            /**
             * Create a caption component
             * @return {zebkit.ui.Panel} a zebkit caption component
             * @method createCaptionPan
             * @protected
             */
            this.createCaptionPan = function() {
                return new this.clazz.CaptionPan();
            };

            /**
             * Create a content component
             * @return {zebkit.ui.Panel} a content component
             * @method createContentPan
             * @protected
             */
            this.createContentPan = function() {
                return new this.clazz.ContentPan();
            };

            /**
             * Create a caption title label
             * @return {zebkit.ui.Label} a caption title label
             * @method createTitle
             * @protected
             */
            this.createTitle = function() {
                return new this.clazz.TitleLab();
            };

            this.setIcon = function(i, icon) {
                if (zebkit.isString(icon) || zebkit.instanceOf(icon, zebkit.draw.Picture)) {
                    icon = new pkg.ImagePan(icon);
                }
                this.icons.setAt(i, icon);
                return this;
            };

            /**
             * Make the window sizable or not sizeable
             * @param {Boolean} b a sizeable state of the window
             * @chainable
             * @method setSizeable
             */
            this.setSizeable = function(b){
                if (this.isSizeable !== b){
                    this.isSizeable = b;
                    if (this.sizer !== null) {
                        this.sizer.setVisible(b);
                    }
                }
                return this;
            };

            /**
             * Maximize the window
             * @method maximize
             * @chainable
             */
            this.maximize = function(){
                if (this.prevW &lt; 0){
                    var d    = this.getCanvas(),
                        cont = this.getWinContainer(),
                        left = d.getLeft(),
                        top  = d.getTop();

                    this.prevX = cont.x;
                    this.prevY = cont.y;
                    this.prevW = cont.width;
                    this.prevH = cont.height;

                    cont.setBounds(left, top,
                                   d.width  - left - d.getRight(),
                                   d.height - top - d.getBottom());
                }
                return this;
            };

            /**
             * Restore the window size
             * @method restore
             * @chainable
             */
            this.restore = function(){
                if (this.prevW &gt;= 0){
                    this.getWinContainer().setBounds(this.prevX, this.prevY,
                                                     this.prevW, this.prevH);
                    this.prevW = -1;
                }
                return this;
            };

            /**
             * Close the window
             * @method close
             * @chainable
             */
            this.close = function() {
                this.getWinContainer().removeMe();
                return this;
            };

            /**
             * Set the window buttons set.
             * @param {Object} buttons dictionary of buttons icons for window buttons.
             * The dictionary key defines a method of the window component to be called
             * when the given button has been pressed. So the method has to be defined
             * in the window component.
             * @method setButtons
             */
            this.setButtons = function(buttons) {
                // remove previously added buttons
                for(var i = 0; i &lt; this.buttons.length; i++) {
                    var kid = this.buttons.kids[i];
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.off();
                    }
                }
                this.buttons.removeAll();

                // add new buttons set
                for(var k in buttons) {
                    if (buttons.hasOwnProperty(k)) {
                        var b = new this.clazz.Button();
                        b.properties(buttons[k]);
                        this.buttons.add(b);

                        (function(t, f) {
                            b.on(function() { f.call(t); });
                        })(this, this[k]);
                    }
                }
                return this;
            };
        },

        function focused(){
            this.$super();
            if (this.caption !== null) {
                this.caption.repaint();
            }
        }
    ]);


    /**
     * Tooltip UI component. The component can be used as a tooltip that shows specified content in
     * figured border.
     * @class  zebkit.ui.Tooltip
     * @param  {zebkit.util.Panel|String} a content component or test label to be shown in tooltip
     * @constructor
     * @extends zebkit.ui.Panel
     */
    pkg.Tooltip = Class(pkg.Panel, [
        function(content) {
            this.$super();
            if (arguments.length &gt; 0) {
                this.add(pkg.$component(content, this));
                this.toPreferredSize();
            }
        },

        function $clazz() {
            this.Label = Class(pkg.Label, []);

            this.ImageLabel = Class(pkg.ImageLabel, []);

            this.TooltipBorder = Class(zebkit.draw.View, [
                function(col, size) {
                    if (arguments.length &gt; 0) {
                        this.color = col;
                    }
                    if (arguments.length &gt; 1) {
                        this.size  = size;
                    }
                    this.gap = 2 * this.size;
                },

                function $prototype() {
                    this.color = &quot;black&quot;;
                    this.size  = 2;

                    this.paint = function (g,x,y,w,h,d) {
                        if (this.color !== null) {
                            this.outline(g,x,y,w,h,d);
                            g.setColor(this.color);
                            g.lineWidth = this.size;
                            g.stroke();
                        }
                    };

                    this.outline = function(g,x,y,w,h,d) {
                        g.beginPath();
                        h -= 2 * this.size;
                        w -= 2 * this.size;
                        x += this.size;
                        y += this.size;

                        var w2   = Math.round(w /2),
                            w3_8 = Math.round((3 * w)/8),
                            h2_3 = Math.round((2 * h)/3),
                            h3   = Math.round(h/3),
                            w4   = Math.round(w/4);

                        g.moveTo(x + w2, y);
                        g.quadraticCurveTo(x, y, x, y + h3);
                        g.quadraticCurveTo(x, y + h2_3, x + w4,  y + h2_3);
                        g.quadraticCurveTo(x + w4, y + h, x, y + h);
                        g.quadraticCurveTo(x + w3_8, y + h, x + w2, y + h2_3);
                        g.quadraticCurveTo(x + w, y + h2_3, x + w, y + h3);
                        g.quadraticCurveTo(x + w, y, x + w2, y);
                        g.closePath();
                        return true;
                    };
                }
            ]);
        },

        function recalc() {
            this.$contentPs = (this.kids.length === 0 ? this.$super()
                                                      : this.kids[0].getPreferredSize());
        },

        function getBottom() {
            return this.$super() + this.$contentPs.height;
        },

        function getTop() {
            return this.$super() + Math.round(this.$contentPs.height / 6);
        },

        function getLeft() {
            return this.$super() + Math.round(this.$contentPs.height / 6);
        },

        function getRight() {
            return this.$super() + Math.round(this.$contentPs.height / 6);
        }
    ]);

    /**
     * Popup window manager class. The manager registering and triggers showing context popup menu
     * and tooltips. Menu appearing is triggered by right pointer click or double fingers touch event.
     * To bind a popup menu to an UI component you can either set &quot;tooltip&quot; property of the component
     * with a popup menu instance:

            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // create menu with three items
            var m = new zebkit.ui.Menu();
            m.add(&quot;Menu Item 1&quot;);
            m.add(&quot;Menu Item 2&quot;);
            m.add(&quot;Menu Item 3&quot;);

            // bind the menu to root panel
            canvas.root.popup = m;

     * Or implement &quot;getPopup(target,x,y)&quot; method that can rule showing popup menu depending on
     * the current cursor location:

            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // visualize 50x50 pixels hot component spot
            // to which the context menu is bound
            canvas.root.paint = function(g) {
                g.setColor(&quot;red&quot;);
                g.fillRect(50,50,50,50);
            }

            // create menu with three items
            var m = new zebkit.ui.Menu();
            m.add(&quot;Menu Item 1&quot;);
            m.add(&quot;Menu Item 2&quot;);
            m.add(&quot;Menu Item 3&quot;);

            // implement &quot;getPopup&quot; method that shows popup menu only
            // if pointer cursor located at red rectangular area of the
            // component
            canvas.root.getPopup = function(target, x, y) {
                // test if pointer cursor position is in red spot area
                // and return context menu if it is true
                if (x &gt; 50 &amp;&amp; y &gt; 50 &amp;&amp; x &lt; 100 &amp;&amp; y &lt;  100)  {
                    return m;
                }
                return null;
            }

     *  Defining a tooltip for an UI component follows the same approach. Other you
     *  define set &quot;tooltip&quot; property of your component with a component that has to
     *  be shown as the tooltip:

             // create canvas
             var canvas = new zebkit.ui.zCanvas();

             // create tooltip
             var t = new zebkit.ui.Label(&quot;Tooltip&quot;);
             t.setBorder(&quot;plain&quot;);
             t.setBackground(&quot;yellow&quot;);
             t.setPadding(6);

             // bind the tooltip to root panel
             canvas.root.popup = t;

    *  Or you can implement &quot;getTooltip(target,x,y)&quot; method if the tooltip showing depends on
    *  the pointer cursor location:


            // create canvas
            var canvas = new zebkit.ui.zCanvas();

            // create tooltip
            var t = new zebkit.ui.Label(&quot;Tooltip&quot;);
            t.setBorder(&quot;plain&quot;);
            t.setBackground(&quot;yellow&quot;);
            t.setPadding(6);

            // bind the tooltip to root panel
            canvas.root.getPopup = function(target, x, y) {
                return x &lt; 10 &amp;&amp; y &lt; 10 ? t : null;
            };

     * @class zebkit.ui.TooltipManager
     * @extends zebkit.ui.event.Manager
     * @constructor
     */

     /**
      * Fired when a menu item has been selected

             zebkit.ui.events.on(&quot;menuItemSelected&quot;, function(menu, index, item) {
                 ...
             });

      *
      * @event menuItemSelected
      * @param {zebkit.ui.Menu} menu a menu component that triggers the event
      * @param {Integer}  index a menu item index that has been selected
      * @param {zebkit.ui.Panel} item a menu item component that has been selected
      */
    pkg.TooltipManager = Class(zebkit.ui.event.Manager, [
        function $prototype() {
            this.$tooltipX = this.$tooltipY = 0;
            this.$toolTask = this.$targetTooltipLayer = this.$tooltip = this.$target = null;

            /**
             * Indicates if a shown tooltip has to disappear by pointer pressed event
             * @attribute hideTooltipByPress
             * @type {Boolean}
             * @default true
             */
            this.hideTooltipByPress = true;

            /**
             * Define interval (in milliseconds) between entering a component and showing
             * a tooltip for the entered component
             * @attribute showTooltipIn
             * @type {Integer}
             * @default 400
             */
            this.showTooltipIn = 400;

            /**
             * Indicates if tool tip position has to be synchronized with pointer position
             * @attribute syncTooltipPosition
             * @type {Boolean}
             * @default true
             */
            this.syncTooltipPosition = true;

            /**
             * Define pointer clicked event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            // this.pointerClicked = function (e){

            //     // Right button
            //     // TODO: check if it is ok and compatible with touch
            //     if (this.isTriggeredWith(e)) {
            //         var popup = null;

            //         if (e.source.popup != null) {
            //             popup = e.source.popup;
            //         } else {
            //             if (e.source.getPopup != null) {
            //                 popup = e.source.getPopup(e.source, e.x, e.y);
            //             }
            //         }

            //         if (popup != null) {
            //             popup.setLocation(e.absX, e.absY);
            //             e.source.getCanvas().getLayer(pkg.PopupLayer.id).add(popup);
            //             popup.requestFocus();
            //         }
            //     }
            // };

            /**
             * Define pointer entered event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerEntered
             */
            this.pointerEntered = function(e) {
                if (this.$target === null &amp;&amp;
                    ((typeof e.source.tooltip !== &#x27;undefined&#x27; &amp;&amp; e.source.tooltip !== null) || typeof e.source.getTooltip !== &#x27;undefined&#x27;))
                {
                    this.$target = e.source;
                    this.$targetTooltipLayer = e.source.getCanvas().getLayer(&quot;win&quot;);
                    this.$tooltipX = e.x;
                    this.$tooltipY = e.y;
                    this.$toolTask = zebkit.util.tasksSet.run(
                        this,
                        this.showTooltipIn,
                        this.showTooltipIn
                    );
                }
            };

            /**
             * Define pointer exited event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited = function(e) {
                // exited triggers tooltip hiding only for &quot;info&quot; tooltips
                if (this.$target !== null &amp;&amp; (this.$tooltip === null || this.$tooltip.winType === &quot;info&quot;)) {
                    this.stopShowingTooltip();
                }
            };

            /**
             * Define pointer moved event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                // to prevent handling pointer moved from component of mdi
                // tooltip we have to check if target equals to source
                // instead of just checking if target is not a null
                if (this.$target === e.source) {
                    // store a new location for a tooltip
                    this.$tooltipX = e.x;
                    this.$tooltipY = e.y;

                    // wake up task try showing a tooltip
                    // at the new location
                    if (this.$toolTask !== null) {
                        this.$toolTask.resume(this.showTooltipIn);
                    }
                }
            };

            /**
             * Task body method
             * @private
             * @param  {Task} t a task context
             * @method run
             */
            this.run = function(t) {
                if (this.$target !== null) {
                    var ntooltip = (typeof this.$target.tooltip !== &#x27;undefined&#x27; &amp;&amp;
                                   this.$target.tooltip !== null) ? this.$target.tooltip
                                                                  : this.$target.getTooltip(this.$target,
                                                                                            this.$tooltipX,
                                                                                            this.$tooltipY),
                        p = null,
                        tx = 0,
                        ty = 0;

                    if (this.$tooltip !== ntooltip) {

                        // hide previously shown tooltip
                        if (this.$tooltip !== null) {
                            this.hideTooltip();
                        }

                        // set new tooltip
                        this.$tooltip = ntooltip;

                        // if new tooltip exists than show it
                        if (ntooltip !== null) {
                            p = zebkit.layout.toParentOrigin(this.$tooltipX, this.$tooltipY, this.$target);

                            this.$tooltip.toPreferredSize();
                            tx = p.x;
                            ty = p.y - this.$tooltip.height;

                            var dw = this.$targetTooltipLayer.width;

                            if (tx + this.$tooltip.width &gt; dw) {
                                tx = dw - this.$tooltip.width - 1;
                            }

                            this.$tooltip.setLocation(tx &lt; 0 ? 0 : tx, ty &lt; 0 ? 0 : ty);

                            if (typeof this.$tooltip.winType === &#x27;undefined&#x27;) {
                                this.$tooltip.winType = &quot;info&quot;;
                            }

                            this.$targetTooltipLayer.add(this.$tooltip);
                            if (this.$tooltip.winType !== &quot;info&quot;) {
                                pkg.activateWindow(this.$tooltip);
                            }
                        }
                    } else {
                        if (this.$tooltip !== null &amp;&amp; this.syncTooltipPosition === true) {
                            p  = zebkit.layout.toParentOrigin(this.$tooltipX,
                                                              this.$tooltipY,
                                                              this.$target);
                            tx = p.x;
                            ty = p.y - this.$tooltip.height;

                            this.$tooltip.setLocation(tx &lt; 0 ? 0 : tx, ty &lt; 0 ? 0 : ty);
                        }
                    }
                }
                t.pause();
            };

            this.winActivated = function(e) {
                // this method is called only for mdi window
                // consider every deactivation of a mdi window as
                // a signal to stop showing tooltip
                if (e.isActive === false &amp;&amp; this.$tooltip !== null)  {
                    this.$tooltip.removeMe();
                }
            };

            this.winOpened = function(e) {
                if (e.isShown === false) {
                    // cleanup tooltip reference
                    this.$tooltip = null;

                    if (e.source.winType !== &quot;info&quot;) {
                        this.stopShowingTooltip();
                    }
                }
            };

            /**
             * Stop showing tooltip
             * @private
             * @method stopShowingTooltip
             */
            this.stopShowingTooltip = function() {
                if (this.$target !== null) {
                    this.$target = null;
                }

                if (this.$toolTask !== null) {
                    this.$toolTask.shutdown();
                }

                this.hideTooltip();
            };

            /**
             * Hide tooltip if it has been shown
             * @method hideTooltip
             */
            this.hideTooltip = function(){
                if (this.$tooltip !== null) {
                    this.$tooltip.removeMe();
                    this.$tooltip = null;
                }
            };

            /**
             * Define pointer pressed event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerPressed
             */
            this.pointerPressed = function(e) {
                if (this.hideTooltipByPress === true &amp;&amp;
                    e.pointerType === &quot;mouse&quot; &amp;&amp;
                    this.$target !== null &amp;&amp;
                    (this.$tooltip === null || this.$tooltip.winType === &quot;info&quot;))
                {
                    this.stopShowingTooltip();
                }
            };

            /**
             * Define pointer released event handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerReleased
             */
            this.pointerReleased = function(e) {
                if ((this.hideTooltipByPress === false || e.pointerType !== &quot;mouse&quot;) &amp;&amp;
                    this.$target !== null &amp;&amp;
                    (this.$tooltip === null || this.$tooltip.winType === &quot;info&quot;))
                {
                    this.stopShowingTooltip();
                }
            };
        }
    ]);


    pkg.$configWith(pkg);
});
zebkit.package(&quot;ui.tree&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Tree UI components and all related to the component classes and interfaces.
     * Tree components are graphical representation of a tree model that allows a user
     * to navigate over the model item, customize the items rendering and
     * organize customizable editing of the items.
     *
     *       // create tree component instance to visualize the given tree model
     *       var tree = new zebkit.ui.tree.Tree({
     *           value: &quot;Root&quot;,
     *           kids : [
     *               &quot;Item 1&quot;,
     *               &quot;Item 2&quot;,
     *               &quot;Item 3&quot;
     *           ]
     *       });
     *
     *       // make all tree items editable with text field component
     *       tree.setEditorProvider(new zebkit.ui.tree.DefEditors());
     *
     * One more tree  component implementation - &quot;CompTree&quot; - allows developers
     * to create tree whose nodes are  other UI components
     *
     *       // create tree component instance to visualize the given tree model
     *       var tree = new zebkit.ui.tree.CompTree({
     *           value: new zebkit.ui.Label(&quot;Root label item&quot;),
     *           kids : [
     *               new zebkit.ui.Checkbox(&quot;Checkbox Item&quot;),
     *               new zebkit.ui.Button(&quot;Button Item&quot;),
     *               new zebkit.ui.TextField(&quot;Text field item&quot;)
     *           ]
     *       });
     *
     * @class zebkit.ui.tree
     * @access package
     */

    //  tree node metrics:
    //   |
    //   |-- &lt;-gapx-&gt; {icon} -- &lt;-gapx-&gt; {view}
    //

    /**
     * Simple private structure to keep a tree model item metrical characteristics
     * @constructor
     * @param {Boolean} b a state of an appropriate tree component node of the given
     * tree model item. The state is sensible for item that has children items and
     * the state indicates if the given tree node is collapsed (false) or expanded
     * (true)
     * @private
     * @class zebkit.ui.tree.ItemMetric
     */
    pkg.ItemMetric = function(b) {
        /**
         *  The whole width of tree node that includes a rendered item preferred
         *  width, all icons and gaps widths
         *  @attribute width
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  The whole height of tree node that includes a rendered item preferred
         *  height, all icons and gaps heights
         *  @attribute height
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Width of an area of rendered tree model item. It excludes icons, toggle
         *  and gaps widths
         *  @attribute viewWidth
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Height of an area of rendered tree model item. It excludes icons, toggle
         *  and gaps heights
         *  @attribute viewHeight
         *  @type {Integer}
         *  @readOnly
         */

        /**
         *  Indicates whether a node is in expanded or collapsed state
         *  @attribute isOpen
         *  @type {Boolean}
         *  @readOnly
         */

        this.width = this.height = this.x = this.y = this.viewHeight = 0;
        this.viewWidth = -1;
        this.isOpen = b;
    };

    /**
     * Default tree editor provider
     * @constructor
     * @class zebkit.ui.tree.DefEditors
     */
    pkg.DefEditors = Class([
        function() {
            /**
             * Internal component that are designed as default editor component
             * @private
             * @readOnly
             * @attribute tf
             * @type {zebkit.ui.TextField}
             */
            this.tf = new this.clazz.TextField(new zebkit.data.SingleLineTxt(&quot;&quot;));
        },

        function $clazz() {
            this.TextField = Class(ui.TextField, []);
        },

        function $prototype() {
            /**
             * Get an UI component to edit the given tree model element
             * @param  {zebkit.ui.tree.Tree} src a tree component
             * @param  {zebkit.data.Item} item an data model item
             * @return {zebkit.ui.Panel} an editor UI component
             * @method getEditor
             */
            this.getEditor = function(src, item){
                var o = item.value;
                this.tf.setValue(o === null ? &quot;&quot; : o.toString());
                return this.tf;
            };

            /**
             * Fetch a model item from the given UI editor component
             * @param  {zebkit.ui.tree.Tree} src a tree UI component
             * @param  {zebkit.ui.Panel} editor an editor that has been used to edit the tree model element
             * @return {Object} an new tree model element value fetched from the given UI editor component
             * @method fetchEditedValue
             */
            this.fetchEditedValue = function(src, editor){
                return editor.view.target.getValue();
            };

            /**
             * The method is called to ask if the given input event should trigger an tree component item
             * @param  {zebkit.ui.tree.Tree} src a tree UI component
             * @param  {zebkit.ui.event.PointerEvent|zebkit.ui.event.KeyEvent} e   an input event: pointer
             * or key event
             * @return {Boolean} true if the event should trigger edition of a tree component item
             * @method @shouldStartEdit
             */
            this.shouldStartEdit = function(src,e){
                return  e.id === &quot;pointerDoubleClicked&quot; ||
                       (e.id === &quot;keyPressed&quot; &amp;&amp; e.code === &quot;Enter&quot;);
            };
        }
    ]);

    /**
     * Default tree editor view provider
     * @class zebkit.ui.tree.DefViews
     * @constructor
     * @extends zebkit.draw.BaseViewProvider
     */
    pkg.DefViews = Class(zebkit.draw.BaseViewProvider, [
        /**
         * Get a view for the given model item of the UI tree component
         * @param  {zebkit.ui.tree.Tree} tree  a tree component
         * @param  {zebkit.data.Item} item a tree model element
         * @return {zebkit.draw.View}  a view to visualize the given tree data model element
         * @method  getView
         */
        function getView(tree, item) {
            return this.$super(tree, item.value);
        }
    ]);


    /**
     * Abstract tree component that can used as basement for building own tree components.
     * The component is responsible for rendering tree, calculating tree nodes metrics,
     * computing visible area, organizing basic user interaction. Classes that inherit it
     * has to provide the following important things:

        * **A tree model item metric** Developers have to implement &quot;getItemPreferredSize(item)&quot;
          method to say which size the given tree item wants to have.
        * **Tree node item rendering** If necessary developers have to implement the way
          a tree item has to be visualized by implementing &quot;this.paintItem(...)&quot; method

     *
     * @class zebkit.ui.tree.BaseTree
     * @constructor
     * @param {zebkit.data.TreeModel|Object} a tree model. It can be an instance of tree model
     * class or an object that described tree model. An example of such object is shown below:

            {
                value : &quot;Root&quot;,
                kids  : [
                    {
                        value: &quot;Child 1&quot;,
                        kids :[
                            &quot;Sub child 1&quot;
                        ]
                    },
                    &quot;Child 2&quot;,
                    &quot;Child 3&quot;
                ]
            }

     * @param {Boolean} [nodeState] a default tree nodes state (expanded or collapsed)
     * @extends zebkit.ui.Panel
     * @uses  zebkit.ui.DecorationViews
     */

     /**
      * Fired when a tree item has been toggled

            tree.on(&quot;toggled&quot;, function(src, item) {
               ...
            });

      * @event toggled
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} item an tree item that has been toggled
      */

     /**
      * Fired when a tree item has been selected

          tree.on(&quot;selected&quot;, function(src, prevItem) {
             ...
          });

      * @event selected
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} prevItem a previously selected tree item
      */


    /**
      * Fired when a tree item editing has been started

          tree.on(&quot;editingStarted&quot;, function(src, item, editor) {
             ...
          });

      * @event editingStarted
      * @param  {zebkit.ui.tree.BaseTree} src an tree component that triggers the event
      * @param  {zebkit.data.Item} item a tree item to be edited
      * @param  {zebkit.ui.Panel} editor an editor to be used to edit the given item
      */

    /**
      * Fired when a tree item editing has been stopped

          tree.on(&quot;editingStopped&quot;, function(src, item, oldValue, editor, isApplied) {
             ...
          });

      * @event editingStopped
      * @param  {zebkit.ui.tree.BaseTree} src a tree component that triggers the event
      * @param  {zebkit.data.Item} item a tree item that has been edited
      * @param  {Object} oldValue an old value of the edited tree item
      * @param  {zebkit.ui.Panel} editor an editor to be used to edit the given item
      * @param  {Boolean} isApplied flag that indicates if the edited value has been
      * applied to the given tree item
      */
    pkg.BaseTree = Class(ui.Panel, ui.DecorationViews, [
        function (d, b){
            if (arguments.length &lt; 2) {
                b = true;
            }

            this.maxw = this.maxh = 0;

            this.views     = {};
            this.viewSizes = {};

            this._isVal = false;
            this.nodes = {};
            this._ = new this.clazz.Listeners();
            this.setLineColor(&quot;gray&quot;);

            this.isOpenVal = b;

            this.setSelectable(true);
            this.$super();
            this.setModel(d);
            this.scrollManager = new ui.ScrollManager(this);
        },

        function  $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;toggled&quot;,
                                                        &quot;selected&quot;,
                                                        &quot;editingStarted&quot;,
                                                        &quot;editingStopped&quot;);
        },

        function $prototype() {
             /**
              * Tree component line color
              * @attribute lnColor
              * @type {String}
              * @readOnly
              */
            this.visibleArea = this.lnColor = null;

             /**
              * Selected tree model item
              * @attribute selected
              * @type {zebkit.data.Item}
              * @default null
              * @readOnly
              */
            this.model = this.selected = this.firstVisible = null;

            /**
             * Horizontal gap between a node elements: toggle, icons and tree item view
             * @attribute gapx
             * @readOnly
             * @default 2
             * @type {Integer}
             */

            /**
             * Vertical gap between a node elements: toggle, icons and tree item view
             * @attribute gapy
             * @readOnly
             * @default 2
             * @type {Integer}
             */

            this.gapx = this.gapy = 2;
            this.canHaveFocus = true;

            /**
             * Test if the given tree component item is opened
             * @param  {zebkit.data.Item}  i a tree model item
             * @return {Boolean} true if the given tree component item is opened
             * @method isOpen
             */
            this.isOpen = function(i){
                this.validate();
                return this.$isOpen(i);
            };

            /**
             * Get calculated for the given tree model item metrics
             * @param  {zebkit.data.Item} i a tree item
             * @return {Object}   an tree model item metrics. Th
             * @method getItemMetrics
             */
            this.getItemMetrics = function(i){
                this.validate();
                return this.getIM(i);
            };

            /**
             * Called every time a pointer pressed in toggle area.
             * @param  {zebkit.data.Item} root an tree item where toggle has been done
             * @method togglePressed
             * @protected
             */
            this.togglePressed = function(root) {
                this.toggle(root);
            };

            this.itemPressed = function(root, e) {
                this.select(root);
            };

            this.pointerPressed = function(e){
                if (this.firstVisible !== null &amp;&amp; e.isAction()) {
                    var x = e.x,
                        y = e.y,
                        root = this.getItemAt(this.firstVisible, x, y);

                    if (root !== null) {
                        x -= this.scrollManager.getSX();
                        y -= this.scrollManager.getSY();
                        var r = this.getToggleBounds(root);

                        if (x &gt;= r.x &amp;&amp; x &lt; r.x + r.width &amp;&amp; y &gt;= r.y &amp;&amp; y &lt; r.y + r.height){
                            this.togglePressed(root);
                        } else if (x &gt; r.x + r.width) {
                            this.itemPressed(root, e);
                        }
                    }
                }
            };

            this.vVisibility = function (){
                if (this.model === null) {
                    this.firstVisible = null;
                }
                else {
                    var nva = ui.$cvp(this, {});
                    if (nva === null) {
                        this.firstVisible = null;
                    } else {
                        if (this._isVal === false ||
                            (this.visibleArea === null              ||
                             this.visibleArea.x !== nva.x           ||
                             this.visibleArea.y !== nva.y           ||
                             this.visibleArea.width !== nva.width   ||
                             this.visibleArea.height !== nva.height   ))
                        {
                            this.visibleArea = nva;
                            if (this.firstVisible !== null) {
                                this.firstVisible = this.findOpened(this.firstVisible);
                                this.firstVisible = this.isOverVisibleArea(this.firstVisible) ? this.nextVisible(this.firstVisible)
                                                                                              : this.prevVisible(this.firstVisible);
                            } else {
                                this.firstVisible = (-this.scrollManager.getSY() &gt; Math.floor(this.maxh / 2)) ? this.prevVisible(this.findLast(this.model.root))
                                                                                                              : this.nextVisible(this.model.root);
                            }
                        }
                    }
                }
                this._isVal = true;
            };

            this.recalc = function() {
                this.maxh = this.maxw = 0;
                if (this.model !== null &amp;&amp; this.model.root !== null) {
                    this.$recalc(this.getLeft(), this.getTop(), null, this.model.root, true);
                    this.maxw -= this.getLeft();
                    this.maxh -= this.gapy;
                }
            };

            /**
             * Get tree model item  metrical bounds (location and size).
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item view location
             * and size:

                    {
                        x: {Integer},
                        y: {Integer},
                        width: {Integer},
                        height: {Integer}
                    }

             * @method getItemBounds
             * @protected
             */
            this.getItemBounds = function(root){
                var metrics = this.getIM(root),
                    toggle  = this.getToggleBounds(root),
                    image   = this.getIconBounds(root);

                toggle.x = image.x + image.width + (image.width &gt; 0 || toggle.width &gt; 0 ? this.gapx : 0);
                toggle.y = metrics.y + Math.floor((metrics.height - metrics.viewHeight) / 2);
                toggle.width = metrics.viewWidth;
                toggle.height = metrics.viewHeight;
                return toggle;
            };

            /**
             * Get toggle element bounds for the given tree model item.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item toggle location
             * and size:
             *
             *     {
             *         x: {Integer},
             *         y: {Integer},
             *         width: {Integer},
             *         height: {Integer}
             *     }
             *
             * @method getToggleBounds
             * @protected
             */
            this.getToggleBounds = function(root){
                var node = this.getIM(root), d = this.getToggleSize(root);
                return { x     : node.x,
                         y     : node.y + Math.floor((node.height - d.height) / 2),
                         width : d.width,
                         height: d.height };
            };

            /**
             * Get current toggle element view. The view depends on the state of tree item.
             * @param  {zebkit.data.Item} i a tree model item
             * @protected
             * @return {zebkit.draw.View}  a toggle element view
             * @method getToogleView
             */
            this.getToggleView = function(i){
                var v = i.kids.length &gt; 0 ? (this.getIM(i).isOpen ? this.views.expandedToggle
                                                                  : this.views.collapsedToggle) : null;

                return (typeof v === &#x27;undefined&#x27; ? null : v);
            };

            /**
             * An abstract method that a concrete tree component implementations have to
             * override. The method has to return a preferred size the given tree model
             * item wants to have.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item preferred size:
             *
             *     {
             *          width: {Integer},
             *          height: {Integer}
             *     }
             *
             * @method getItemPreferredSize
             * @protected
             */
            this.getItemPreferredSize = function(root) {
                throw new Error(&quot;Not implemented&quot;);
            };

            /**
             * An abstract method that a concrete tree component implementations should
             * override. The method has to render the given tree node of the specified
             * tree model item at the given location
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {zebkit.data.Item} root a tree model item to be rendered
             * @param  {zebkit.ui.tree.ItemMetric} node a tree node metrics
             * @param  {Ineteger} x a x location where the tree node has to be rendered
             * @param  {Ineteger} y a y location where the tree node has to be rendered
             * @method paintItem
             * @protected
             */
            this.$recalc = function (x,y,parent,root,isVis){
                var node = this.getIM(root);
                if (isVis === true) {
                    if (node.viewWidth &lt; 0) {
                        var viewSize = this.getItemPreferredSize(root);
                        node.viewWidth  = viewSize.width;
                        node.viewHeight = viewSize.height;
                    }

                    var imageSize = this.getIconSize(root),
                        toggleSize = this.getToggleSize(root);

                    if (parent !== null){
                        var pImg = this.getIconBounds(parent);
                        x = pImg.x + Math.floor((pImg.width - toggleSize.width) / 2);
                    }

                    node.x = x;
                    node.y = y;
                    node.width = toggleSize.width + imageSize.width +
                                 node.viewWidth + (toggleSize.width &gt; 0 ? this.gapx : 0) + 10 +
                                                  (imageSize.width  &gt; 0 ? this.gapx : 0);

                    node.height = Math.max(((toggleSize.height &gt; imageSize.height) ? toggleSize.height
                                                                                   : imageSize.height),
                                            node.viewHeight);

                    if (node.x + node.width &gt; this.maxw) {
                        this.maxw = node.x + node.width;
                    }

                    this.maxh += (node.height + this.gapy);
                    x = node.x + toggleSize.width + (toggleSize.width &gt; 0 ? this.gapx : 0);
                    y += (node.height + this.gapy);
                }

                var b = node.isOpen &amp;&amp; isVis === true;
                if (b) {
                    var count = root.kids.length;
                    for(var i = 0; i &lt; count; i++) {
                        y = this.$recalc(x, y, root, root.kids[i], b);
                    }
                }
                return y;
            };

            this.$isOpen = function(i) {
                return i === null || (i.kids.length &gt; 0 &amp;&amp; this.getIM(i).isOpen &amp;&amp; this.$isOpen(i.parent));
            };

            /**
             * Get a tree node metrics by the given tree model item.
             * @param  {zebkit.data.Item} item a tree model item
             * @return {zebkit.ui.tree.ItemMetric} a tree node metrics
             * @protected
             * @method getIM
             */
            this.getIM = function (item) {
                if (this.nodes.hasOwnProperty(item.$hash$) === false){
                    var node = new pkg.ItemMetric(this.isOpenVal);
                    this.nodes[item.$hash$] = node;
                    return node;
                }
                return this.nodes[item.$hash$];
            };

            /**
             * Get a tree item that is located at the given location.
             * @param  {zebkit.data.Item} [root] a starting tree node
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y a y coordinate
             * @return {zebkit.data.Item} a tree model item
             * @method getItemAt
             */
            this.getItemAt = function(root, x, y){
                this.validate();

                if (arguments.length &lt; 3) {
                    x = arguments[0];
                    y = arguments[1];
                    root = this.model.root;
                }

                if (this.firstVisible !== null &amp;&amp; y &gt;= this.visibleArea.y &amp;&amp; y &lt; this.visibleArea.y + this.visibleArea.height){
                    var dx    = this.scrollManager.getSX(),
                        dy    = this.scrollManager.getSY(),
                        found = this.getItemAtInBranch(root, x - dx, y - dy);

                    if (found !== null) {
                        return found;
                    }

                    var parent = root.parent;
                    while (parent !== null) {
                        var count = parent.kids.length;
                        for(var i = parent.kids.indexOf(root) + 1;i &lt; count; i ++ ){
                            found = this.getItemAtInBranch(parent.kids[i], x - dx, y - dy);
                            if (found !== null) {
                                return found;
                            }
                        }
                        root = parent;
                        parent = root.parent;
                    }
                }
                return null;
            };

            this.getItemAtInBranch = function(root,x,y){
                if (root !== null) {
                    var node = this.getIM(root);
                    if (x &gt;= node.x &amp;&amp; y &gt;= node.y &amp;&amp; x &lt; node.x + node.width &amp;&amp; y &lt; node.y + node.height + this.gapy) {
                        return root;
                    }

                    if (this.$isOpen(root)) {
                        for(var i = 0;i &lt; root.kids.length; i++) {
                            var res = this.getItemAtInBranch(root.kids[i], x, y);
                            if (res !== null) {
                                return res;
                            }
                        }
                    }
                }
                return null;
            };

            this.getIconView = function (i){
                return i.kids.length &gt; 0 ? (this.getIM(i).isOpen ? this.views.expandedSign
                                                                 : this.views.collapsedSign)
                                         : this.views.leafSign;
            };

            this.getIconSize = function (i) {
                return i.kids.length &gt; 0 ? (this.getIM(i).isOpen ? this.viewSizes.expandedSign
                                                                 : this.viewSizes.collapsedSign)
                                          : this.viewSizes.leafSign;
            };

            /**
             * Get icon element bounds for the given tree model item.
             * @param  {zebkit.data.Item} root an tree model item
             * @return {Object} a structure that keeps an item icon location
             * and size:
             *
             *     {
             *         x: {Integer},
             *         y: {Integer},
             *         width: {Integer},
             *         height: {Integer}
             *     }
             *
             * @method getToggleBounds
             * @protected
             */
            this.getIconBounds = function(root) {
                var node = this.getIM(root),
                    id   = this.getIconSize(root),
                    td   = this.getToggleSize(root);
                return { x:node.x + td.width + (td.width &gt; 0 ? this.gapx : 0),
                         y:node.y + Math.floor((node.height - id.height) / 2),
                         width:id.width, height:id.height };
            };

            this.getToggleSize = function(i) {
                return this.$isOpen(i) ? this.viewSizes.expandedToggle
                                       : this.viewSizes.collapsedToggle;
            };

            this.isOverVisibleArea = function (i) {
                var node = this.getIM(i);
                return node.y + node.height + this.scrollManager.getSY() &lt; this.visibleArea.y;
            };

            this.findOpened = function(item) {
                var parent = item.parent;
                return (parent === null || this.$isOpen(parent)) ? item : this.findOpened(parent);
            };

            this.findNext = function(item) {
                if (item !== null){
                    if (item.kids.length &gt; 0 &amp;&amp; this.$isOpen(item)){
                        return item.kids[0];
                    }
                    var parent = null;
                    while ((parent = item.parent) !== null){
                        var index = parent.kids.indexOf(item);
                        if (index + 1 &lt; parent.kids.length) {
                            return parent.kids[index + 1];
                        }
                        item = parent;
                    }
                }
                return null;
            };

            this.findPrev = function (item){
                if (item !== null) {
                    var parent = item.parent;
                    if (parent !== null) {
                        var index = parent.kids.indexOf(item);
                        return (index - 1 &gt;= 0) ? this.findLast(parent.kids[index - 1]) : parent;
                    }
                }
                return null;
            };

            this.findLast = function (item){
                return this.$isOpen(item) &amp;&amp; item.kids.length &gt; 0 ? this.findLast(item.kids[item.kids.length - 1])
                                                                  : item;
            };

            this.prevVisible = function (item){
                if (item === null || this.isOverVisibleArea(item)) {
                    return this.nextVisible(item);
                }

                var parent = null;
                while((parent = item.parent) !== null){
                    for(var i = parent.kids.indexOf(item) - 1;i &gt;= 0; i-- ){
                        var child = parent.kids[i];
                        if (this.isOverVisibleArea(child)) {
                            return this.nextVisible(child);
                        }
                    }
                    item = parent;
                }
                return item;
            };

            this.isVerVisible = function (item){
                if (this.visibleArea === null) {
                    return false;
                }

                var node = this.getIM(item),
                    yy1  = node.y + this.scrollManager.getSY(),
                    yy2  = yy1 + node.height - 1,
                    by   = this.visibleArea.y + this.visibleArea.height;

                return ((this.visibleArea.y &lt;= yy1 &amp;&amp; yy1 &lt; by) ||
                        (this.visibleArea.y &lt;= yy2 &amp;&amp; yy2 &lt; by) ||
                        (this.visibleArea.y &gt; yy1 &amp;&amp; yy2 &gt;= by)    );
            };

            this.nextVisible = function(item){
                if (item === null || this.isVerVisible(item) === true) {
                    return item;
                }

                var res = this.nextVisibleInBranch(item), parent = null;
                if (res !== null) {
                    return res;
                }

                while ((parent = item.parent) !== null){
                    var count = parent.kids.length;
                    for(var i = parent.kids.indexOf(item) + 1;i &lt; count; i++){
                        res = this.nextVisibleInBranch(parent.kids[i]);
                        if (res !== null) {
                            return res;
                        }
                    }
                    item = parent;
                }
                return null;
            };

            this.nextVisibleInBranch = function (item){
                if (this.isVerVisible(item)) {
                    return item;
                }

                if (this.$isOpen(item)){
                    for(var i = 0;i &lt; item.kids.length; i++){
                        var res = this.nextVisibleInBranch(item.kids[i]);
                        if (res !== null) {
                            return res;
                        }
                    }
                }
                return null;
            };

            this.paintSelectedItem = function(g, root, node, x, y) {
                var v = this.hasFocus() ? this.views.focusOnSelect : this.views.focusOffSelect;
                if (v !== null &amp;&amp; typeof v !== &#x27;undefined&#x27;) {
                    v.paint(g, x, y, node.viewWidth, node.viewHeight, this);
                }
            };

            this.paintTree = function (g,item){
                this.paintBranch(g, item);
                var parent = null;
                while( (parent = item.parent) !== null){
                    this.paintChild(g, parent, parent.kids.indexOf(item) + 1);
                    item = parent;
                }
            };

            this.paintBranch = function (g, root){
                if (root === null) {
                    return false;
                }

                var node = this.getIM(root),
                    dx   = this.scrollManager.getSX(),
                    dy   = this.scrollManager.getSY();

                if (zebkit.util.isIntersect(node.x + dx, node.y + dy,
                                           node.width, node.height,
                                           this.visibleArea.x, this.visibleArea.y,
                                           this.visibleArea.width, this.visibleArea.height))
                {
                    var toggle     = this.getToggleBounds(root),
                        toggleView = this.getToggleView(root),
                        image      = this.getIconBounds(root),
                        vx         = image.x + image.width + this.gapx,
                        vy         = node.y + Math.floor((node.height - node.viewHeight) / 2);

                    if (toggleView !== null) {
                        toggleView.paint(g, toggle.x, toggle.y, toggle.width, toggle.height, this);
                    }

                    if (image.width &gt; 0) {
                        this.getIconView(root).paint(g, image.x, image.y,
                                                     image.width, image.height, this);
                    }

                    if (this.selected === root){
                        this.paintSelectedItem(g, root, node, vx, vy);
                    }

                    if (typeof this.paintItem !== &#x27;undefined&#x27;) {
                        this.paintItem(g, root, node, vx, vy);
                    }

                    if (this.lnColor !== null){
                        g.setColor(this.lnColor);
                        var yy = toggle.y + Math.floor(toggle.height / 2) + 0.5;

                        g.beginPath();
                        g.moveTo(toggle.x + (toggleView === null ? Math.floor(toggle.width / 2)
                                                                 : toggle.width - 1), yy);
                        g.lineTo(image.x, yy);
                        g.stroke();
                    }
                } else {
                    if (node.y + dy &gt; this.visibleArea.y + this.visibleArea.height ||
                        node.x + dx &gt; this.visibleArea.x + this.visibleArea.width    )
                    {
                        return false;
                    }
                }
                return this.paintChild(g, root, 0);
            };

            this.$y = function (item, isStart){
                var node = this.getIM(item),
                    th = this.getToggleSize(item).height,
                    ty = node.y + Math.floor((node.height - th) / 2),
                    dy = this.scrollManager.getSY(),
                    y  = (item.kids.length &gt; 0) ? (isStart ? ty + th : ty - 1)
                                                : ty + Math.floor(th / 2);

                return (y + dy &lt; 0) ?  -dy - 1
                                    : ((y + dy &gt; this.height) ? this.height - dy : y);
            };

            /**
             * Paint children items of the given root tree item.
             * @param  {CanvasRenderingContext2D} g a graphical context
             * @param  {zebkit.data.Item} root a root tree item
             * @param  {Integer} index an index
             * @return {Boolean}
             * @protected
             * @method paintChild
             */
            this.paintChild = function (g, root, index){
                var b = this.$isOpen(root);
                if (root === this.firstVisible &amp;&amp; this.lnColor !== null) {
                    g.setColor(this.lnColor);
                    var xx = this.getIM(root).x + Math.floor((b ? this.viewSizes.expandedToggle.width
                                                                : this.viewSizes.collapsedToggle.width) / 2);
                    g.beginPath();
                    g.moveTo(xx + 0.5, this.getTop());
                    g.lineTo(xx + 0.5, this.$y(root, false));
                    g.stroke();
                }
                if (b === true &amp;&amp; root.kids.length &gt; 0){
                    var firstChild = root.kids.length &gt; 0 ?root.kids[0] : null;
                    if (firstChild === null) {
                        return true;
                    }

                    var x = this.getIM(firstChild).x + Math.floor((this.$isOpen(firstChild) ? this.viewSizes.expandedToggle.width
                                                                                            : this.viewSizes.collapsedToggle.width) / 2),
                    count = root.kids.length;
                    if (index &lt; count) {
                        var  node = this.getIM(root),
                             y    = (index &gt; 0) ? this.$y(root.kids[index - 1], true)
                                                : node.y + Math.floor((node.height + this.getIconSize(root).height) / 2);

                        for(var i = index;i &lt; count; i++ ) {
                            var child = root.kids[i];
                            if (this.lnColor !== null){
                                g.setColor(this.lnColor);
                                g.beginPath();
                                g.moveTo(x + 0.5, y);
                                g.lineTo(x + 0.5, this.$y(child, false));
                                g.stroke();
                                y = this.$y(child, true);
                            }
                            if (this.paintBranch(g, child) === false){
                                if (this.lnColor !== null &amp;&amp; i + 1 !== count){
                                    g.setColor(this.lnColor);
                                    g.beginPath();
                                    g.moveTo(x + 0.5, y);
                                    g.lineTo(x + 0.5, this.height - this.scrollManager.getSY());
                                    g.stroke();
                                }
                                return false;
                            }
                        }
                    }
                }
                return true;
            };

            this.nextPage = function (item,dir){
                var sum = 0, prev = item;
                while (item !== null &amp;&amp; sum &lt; this.visibleArea.height){
                    sum += (this.getIM(item).height + this.gapy);
                    prev = item;
                    item = dir &lt; 0 ? this.findPrev(item) : this.findNext(item);
                }
                return prev;
            };

            this.paint = function(g){
                if (this.model !== null){
                    this.vVisibility();
                    if (this.firstVisible !== null){
                        var sx = this.scrollManager.getSX(), sy = this.scrollManager.getSY();
                        try {
                            g.translate(sx, sy);
                            this.paintTree(g, this.firstVisible);
                            g.translate(-sx,  -sy);
                        } catch(e) {
                            g.translate(-sx,  -sy);
                            throw e;
                        }
                    }
                }
            };

            /**
             * Select the given item.
             * @param  {zebkit.data.Item} item an item to be selected. Use null value to clear
             * any selection
             * @method  select
             */
            this.select = function(item){
                if (this.isSelectable === true &amp;&amp; this.selected !== item){
                    var old = this.selected,
                        m    = null;

                    this.selected = item;
                    if (this.selected !== null) {
                        this.makeVisible(this.selected);
                    }

                    this._.selected(this, old);

                    if (old !== null &amp;&amp; this.isVerVisible(old)) {
                        m = this.getItemMetrics(old);
                        this.repaint(m.x + this.scrollManager.getSX(),
                                     m.y + this.scrollManager.getSY(),
                                     m.width, m.height);
                    }

                    if (this.selected !== null &amp;&amp; this.isVerVisible(this.selected)) {
                        m = this.getItemMetrics(this.selected);
                        this.repaint(m.x + this.scrollManager.getSX(),
                                     m.y + this.scrollManager.getSY(),
                                     m.width, m.height);
                    }
                }
            };

            /**
             * Make the given tree item visible. Tree component rendered content can takes more space than
             * the UI component size is. In this case the content can be scrolled to make visible required
             * tree item.
             * @param  {zebkit.data.Item} item an item to be visible
             * @method makeVisible
             */
            this.makeVisible = function(item){
                this.validate();
                var r = this.getItemBounds(item);
                this.scrollManager.makeVisible(r.x, r.y, r.width, r.height);
            };

            /**
             * Toggle off or on recursively all items of the given item
             * @param  {zebkit.data.Item} root a starting item to toggle
             * @param  {Boolean} b  true if all items have to be in opened
             * state and false otherwise
             * @method toggleAll
             * @chainable
             */
            this.toggleAll = function (root,b){
                if (root.kids.length &gt; 0){
                    if (this.getItemMetrics(root).isOpen !== b) {
                        this.toggle(root);
                    }

                    for(var i = 0; i &lt; root.kids.length; i++ ){
                        this.toggleAll(root.kids[i], b);
                    }
                }
                return this;
            };

            /**
             * Toggle the given tree item
             * @param  {zebkit.data.Item} item an item to be toggled
             * @method toggle
             * @chainable
             */
            this.toggle = function(item){
                if (item.kids.length &gt; 0){
                    this.validate();
                    var node = this.getIM(item);
                    node.isOpen = (node.isOpen ? false : true);
                    this.invalidate();
                    this._.toggled(this, item);

                    if (!node.isOpen &amp;&amp; this.selected !== null){
                        var parent = this.selected;
                        do {
                            parent = parent.parent;
                        } while (parent !== item &amp;&amp; parent !== null);

                        if (parent === item) {
                            this.select(item);
                        }
                    }

                    this.repaint();
                }
                return this;
            };

            this.itemInserted = function (model, item){
                this.vrp();
            };

            this.itemRemoved = function (model,item){
                if (item === this.firstVisible) {
                    this.firstVisible = null;
                }

                if (item === this.selected) {
                    this.select(null);
                }

                delete this.nodes[item];
                this.vrp();
            };

            this.itemModified = function (model, item, prevValue){
                var node = this.getIM(item);
                // invalidate an item metrics
                if (node !== null) {
                    node.viewWidth = -1;
                }
                this.vrp();
            };

            this.calcPreferredSize = function(target) {
                return this.model === null ? { width:0, height:0 }
                                           : { width:this.maxw, height:this.maxh };
            };

            /**
             * Say if items of the tree component should be selectable
             * @param {Boolean} b true is tree component items can be selected
             * @method setSelectable
             */
            this.setSelectable = function(b){
                if (this.isSelectable !== b){
                    if (b === false &amp;&amp; this.selected !== null) {
                        this.select(null);
                    }
                    this.isSelectable = b;
                    this.repaint();
                }
                return this;
            };

            /**
             * Set tree component connector lines color
             * @param {String} c a color
             * @method setLineColor
             * @chainable
             */
            this.setLineColor = function (c){
                this.lnColor = c;
                this.repaint();
                return this;
            };

            /**
             * Set the given horizontal gaps between tree node graphical elements:
             * toggle, icon, item view
             * @param {Integer} gx horizontal gap
             * @param {Integer} gy vertical gap
             * @method setGaps
             * @chainable
             */
            this.setGaps = function(gx, gy){
                if (gx !== this.gapx || gy !== this.gapy){
                    this.gapx = gx;
                    this.gapy = gy;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given tree model to be visualized with the UI component.
             * @param {zebkit.data.TreeModel|Object} d a tree model
             * @method setModel
             * @chainable
             */
            this.setModel = function(d){
                if (this.model !== d) {
                    if (zebkit.instanceOf(d, zebkit.data.TreeModel) === false) {
                        d = new zebkit.data.TreeModel(d);
                    }

                    this.select(null);
                    if (this.model !== null &amp;&amp; this.model._) {
                        this.model.off(this);
                    }
                    this.model = d;
                    if (this.model !== null &amp;&amp; this.model._) {
                        this.model.on(this);
                    }
                    this.firstVisible = null;
                    delete this.nodes;
                    this.nodes = {};
                    this.vrp();
                }
                return this;
            };
        },

        function focused(){
            this.$super();
            if (this.selected !== null) {
                var m = this.getItemMetrics(this.selected);
                this.repaint(m.x + this.scrollManager.getSX(),
                             m.y + this.scrollManager.getSY(), m.width, m.height);
            }
        },

        /**
         * Set the number of views to customize rendering of different visual elements of the tree
         * UI component. The following decorative elements can be customized:
         *
         *   - **&quot;collapsedSign&quot;** - closed tree item icon view
         *   - **&quot;expandedSign&quot;**  - opened tree item icon view
         *   - **&quot;leafSign&quot;**  - leaf tree item icon view
         *   - **&quot;expandedToggle&quot;**    - toggle on view
         *   - **&quot;collapsedToggle&quot;**   - toggle off view
         *   - **&quot;focusOffSelect&quot;**   - a view to express an item selection when tree component doesn&#x27;t hold focus
         *   - **&quot;focusOnSelect&quot;**   - a view to express an item selection when tree component holds focus
         *
         * For instance:

            // build tree UI component
            var tree = new zebkit.ui.tree.Tree({
                value: &quot;Root&quot;,
                kids: [
                    &quot;Item 1&quot;,
                    &quot;Item 2&quot;
                ]
            });

            // set &quot; [x] &quot; text render for toggle on and
            // &quot; [o] &quot; text render for toggle off tree elements
            tree.setViews({
                &quot;expandedToggle&quot; : new zebkit.draw.TextRender(&quot; [x] &quot;),
                &quot;collapsedToggle&quot;: new zebkit.draw.TextRender(&quot; [o] &quot;)
            });

         * @param {Object} v dictionary of tree component decorative elements views
         * @method setViews
         * @chainable
         */
        function setViews(v) {
            // setting to 0 prevents exception when on/off view is not defined
            this.viewSizes.expandedToggle  = { width: 0, height : 0};
            this.viewSizes.collapsedToggle = { width: 0, height : 0};
            this.viewSizes.expandedSign    = { width: 0, height : 0};
            this.viewSizes.collapsedSign   = { width: 0, height : 0};
            this.viewSizes.leafSign        = { width: 0, height : 0};

            for(var k in v) {
                this.views[k] = zebkit.draw.$view(v[k]);
                if (this.viewSizes.hasOwnProperty(k) &amp;&amp; this.views[k]) {
                    this.viewSizes[k] = this.views[k].getPreferredSize();
                }
            }

            this.vrp();
            return this;
        },

        function invalidate(){
            if (this.isValid === true){
                this._isVal = false;
            }
            this.$super();
        }
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Tree UI component that visualizes a tree data model. The model itself can be passed as JavaScript
     * structure or as a instance of zebkit.data.TreeModel. Internally tree component keeps the model always
     * as zebkit.data.TreeModel class instance:

         var tree = new zebkit.ui.tree.Tree({
              value: &quot;Root&quot;,
              kids : [  &quot;Item 1&quot;, &quot;Item 2&quot;]
         });

     * or

         var model = new zebkit.data.TreeModel(&quot;Root&quot;);
         model.add(model.root, &quot;Item 1&quot;);
         model.add(model.root, &quot;Item 2&quot;);

         var tree = new zebkit.ui.tree.Tree(model);

     * Tree model rendering is fully customizable by defining an own views provider. Default views
     * provider renders tree model item as text. The tree node can be made editable by defining an
     * editor provider. By default tree modes are not editable.
     * @class  zebkit.ui.tree.Tree
     * @constructor
     * @extends zebkit.ui.tree.BaseTree
     * @param {Object|zebkit.data.TreeModel} [model] a tree data model passed as JavaScript
     * structure or as an instance
     * @param {Boolean} [b] the tree component items toggle state. true to have all items
     * in opened state.
     */
    pkg.Tree = Class(pkg.BaseTree, [
        function (d, b){
            if (arguments.length &lt; 2) {
                b  = true;
            }

            this.setViewProvider(new pkg.DefViews());
            this.$super(d, b);
        },

        function $prototype() {
            this.itemGapY = 2;
            this.itemGapX = 4;

            /**
             * A tree model editor provider
             * @readOnly
             * @attribute editors
             * @default null
             * @type {zebkit.ui.tree.DefEditors}
             */
            this.editors = null;

            /**
             * A tree model items view provider
             * @readOnly
             * @attribute provider
             * @default an instance of zebkit.ui.tree.DefsViews
             * @type {zebkit.ui.tree.DefsViews}
             */
            this.provider = this.editedItem = this.pressedItem = null;

            this.setFont = function(f) {
                this.provider.setFont(f);
                this.vrp();
                return this;
            };

            this.childKeyPressed = function(e){
                if (e.code === &quot;Escape&quot;) {
                    this.stopEditing(false);
                } else {
                    if (e.code === &quot;Enter&quot; &amp;&amp;
                           ((zebkit.instanceOf(e.source, ui.TextField) === false) ||
                            (zebkit.instanceOf(e.source.view.target, zebkit.data.SingleLineTxt))))
                    {
                        this.stopEditing(true);
                    }
                }
            };

            this.catchScrolled = function (psx, psy){
                if (this.kids.length &gt; 0) {
                    this.stopEditing(false);
                }

                if (this.firstVisible === null) {
                    this.firstVisible = this.model.root;
                }
                this.firstVisible = (this.y &lt; psy) ? this.nextVisible(this.firstVisible)
                                                   : this.prevVisible(this.firstVisible);
                this.repaint();
            };

            this.laidout = function() {
                this.vVisibility();
            };

            this.getItemPreferredSize = function(root) {
                var ps = this.provider.getView(this, root).getPreferredSize();
                ps.width  += this.itemGapX * 2;
                ps.height += this.itemGapY * 2;
                return ps;
            };

            this.paintItem = function(g, root, node, x, y) {
                if (root !== this.editedItem){
                    var v = this.provider.getView(this, root);
                    v.paint(g, x + this.itemGapX, y + this.itemGapY,
                            node.viewWidth, node.viewHeight, this);
                }
            };

            /**
             * Initiate the given item editing if the specified event matches condition
             * @param  {zebkit.data.Item} item an item to be edited
             * @param  {zebkit.util.Event} e an even that may trigger the item editing
             * @return {Boolean}  return true if an item editing process has been started,
             * false otherwise
             * @method  se
             * @private
             */
            this.se = function (item, e){
                if (item !== null){
                    this.stopEditing(true);
                    if (this.editors !== null &amp;&amp; this.editors.shouldStartEdit(item, e)) {
                        this.startEditing(item);
                        return true;
                    }
                }
                return false;
            };

            this.pointerClicked = function(e){
                if (this.se(this.pressedItem, e)) {
                    this.pressedItem = null;
                }
            };

            this.pointerDoubleClicked = function(e) {
                if (this.se(this.pressedItem, e)) {
                    this.pressedItem = null;
                } else {
                    if (this.selected !== null &amp;&amp;
                        this.getItemAt(this.firstVisible, e.x, e.y) === this.selected)
                    {
                        this.toggle(this.selected);
                    }
                }
            };

            this.pointerReleased = function(e){
                if (this.se(this.pressedItem, e)) {
                    this.pressedItem = null;
                }
            };

            this.keyTyped = function(e){
                if (this.selected !== null){
                    switch(e.key) {
                        case &#x27;+&#x27;: if (this.isOpen(this.selected) === false) {
                            this.toggle(this.selected);
                        } break;
                        case &#x27;-&#x27;: if (this.isOpen(this.selected)) {
                            this.toggle(this.selected);
                        } break;
                    }
                }
            };

            this.keyPressed = function(e){
                var newSelection = null;
                switch(e.code) {
                    case &quot;ArrowDown&quot; :
                    case &quot;ArrowRight&quot;: newSelection = this.findNext(this.selected); break;
                    case &quot;ArrowUp&quot;   :
                    case &quot;ArrowLeft&quot; : newSelection = this.findPrev(this.selected); break;
                    case &quot;Home&quot;      :
                        if (e.ctrlKey) {
                            this.select(this.model.root);
                        } break;
                    case &quot;End&quot;       :
                        if (e.ctrlKey) {
                            this.select(this.findLast(this.model.root));
                        } break;
                    case &quot;PageDown&quot;  :
                        if (this.selected !== null) {
                            this.select(this.nextPage(this.selected, 1));
                        } break;
                    case &quot;PageUp&quot;    :
                        if (this.selected !== null) {
                            this.select(this.nextPage(this.selected,  -1));
                        } break;
                    //!!!!case &quot;Enter&quot;: if(this.selected !== null) this.toggle(this.selected);break;
                }
                if (newSelection !== null) {
                    this.select(newSelection);
                }
                this.se(this.selected, e);
            };

            /**
             * Start editing the given if an editor for the item has been defined.
             * @param  {zebkit.data.Item} item an item whose content has to be edited
             * @method startEditing
             * @protected
             */
            this.startEditing = function (item){
                this.stopEditing(true);
                if (this.editors !== null){
                    var editor = this.editors.getEditor(this, item);
                    if (editor !== null) {
                        this.editedItem = item;
                        var b  = this.getItemBounds(this.editedItem),
                            ps = editor.getPreferredSize();

                        editor.setBounds(b.x + this.scrollManager.getSX() + this.itemGapX,
                                         b.y - Math.floor((ps.height - b.height + 2 * this.itemGapY) / 2) +
                                         this.scrollManager.getSY() + this.itemGapY,
                                         ps.width, ps.height);

                        this.add(editor);
                        editor.requestFocus();
                        this._.editingStarted(this, item, editor);
                    }
                }
            };

            /**
             * Stop editing currently edited tree item and apply or discard the result of the
             * editing to tree data model.
             * @param  {Boolean} true if the editing result has to be applied to tree data model
             * @method stopEditing
             * @protected
             */
            this.stopEditing = function(applyData){
                if (this.editors !== null &amp;&amp; this.editedItem !== null) {
                    var item     = this.editedItem,
                        oldValue = item.value,
                        editor   = this.kids[0];

                    try {
                        if (applyData)  {
                            this.model.setValue(this.editedItem,
                                                this.editors.fetchEditedValue(this.editedItem, this.kids[0]));
                        }
                    } finally {
                        this.editedItem = null;
                        this.removeAt(0);
                        this.requestFocus();
                        this._.editingStopped(this, item, oldValue, editor, applyData);
                    }
                }
            };
        },

        function toggle(item) {
            this.stopEditing(false);
            this.$super(item);
            return this;
        },

        function itemInserted(target,item){
            this.stopEditing(false);
            this.$super(target,item);
        },

        function itemRemoved(target,item){
            this.stopEditing(false);
            this.$super(target,item);
        },

        /**
         * Set the given editor provider. The editor provider is a class that is used to decide which UI
         * component has to be used as an item editor, how the editing should be triggered and how the
         * edited value has to be fetched from an UI editor.
         * @param {zebkit.ui.tree.DefEditors} p an editor provider
         * @method setEditorProvider
         */
        function setEditorProvider(p){
            if (p != this.editors){
                this.stopEditing(false);
                this.editors = p;
            }
            return this;
        },

        /**
         * Set tree component items view provider. Provider says how tree model items
         * have to be visualized.
         * @param {zebkit.ui.tree.DefViews} p a view provider
         * @method setViewProvider
         * @chainable
         */
        function setViewProvider(p){
            if (this.provider != p) {
                this.stopEditing(false);
                this.provider = p;
                delete this.nodes;
                this.nodes = {};
                this.vrp();
            }
            return this;
        },

        /**
         * Set the given tree model to be visualized with the UI component.
         * @param {zebkit.data.TreeModel|Object} d a tree model
         * @method setModel
         * @chainable
         */
        function setModel(d){
            this.stopEditing(false);
            this.$super(d);
            return this;
        },

        function paintSelectedItem(g, root, node, x, y) {
            if (root !== this.editedItem) {
                this.$super(g, root, node, x, y);
            }
        },

        function itemPressed(root, e) {
            this.$super(root, e);
            if (this.se(root, e) === false) {
                this.pressedItem = root;
            }
        },

        function pointerPressed(e){
            this.pressedItem = null;
            this.stopEditing(true);
            this.$super(e);
        }
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Component tree component that expects other UI components to be a tree model values.
     * In general the implementation lays out passed via tree model UI components as tree
     * component nodes. For instance:

         var tree = new zebkit.ui.tree.Tree({
              value: new zebkit.ui.Label(&quot;Label root item&quot;),
              kids : [
                    new zebkit.ui.Checkbox(&quot;Checkbox Item&quot;),
                    new zebkit.ui.Button(&quot;Button item&quot;),
                    new zebkit.ui.Combo([&quot;Combo item 1&quot;, &quot;Combo item 2&quot;])
             ]
         });

     * But to prevent unexpected navigation it is better to use number of predefined
     * with component tree UI components:
     *
     *   - zebkit.ui.tree.CompTree.Label
     *   - zebkit.ui.tree.CompTree.Checkbox
     *   - zebkit.ui.tree.CompTree.Combo
     *
     * You can describe tree model keeping in mind special notation

         var tree = new zebkit.ui.tree.Tree({
              value: &quot;Label root item&quot;,  // zebkit.ui.tree.CompTree.Label
              kids : [
                    &quot;[ ] Checkbox Item 1&quot;, // unchecked zebkit.ui.tree.CompTree.Checkbox
                    &quot;[x] Checkbox Item 2&quot;, // checked zebkit.ui.tree.CompTree.Checkbox
                    [&quot;Combo item 1&quot;, &quot;Combo item 2&quot;] // zebkit.ui.tree.CompTree.Combo
             ]
         });

     *
     * @class  zebkit.ui.tree.CompTree
     * @constructor
     * @extends zebkit.ui.tree.BaseTree
     * @param {Object|zebkit.data.TreeModel} [model] a tree data model passed as JavaScript
     * structure or as an instance
     * @param {Boolean} [b] the tree component items toggle state. true to have all items
     * in opened state.
     */
    pkg.CompTree = Class(pkg.BaseTree, [
        function $clazz() {
            this.Label = Class(ui.Label, [
                function $prototype() {
                    this.canHaveFocus = true;
                }
            ]);

            this.Checkbox = Class(ui.Checkbox, []);

            this.Combo = Class(ui.Combo, [
                function keyPressed(e) {
                    if (e.code !== &quot;ArrowUp&quot; &amp;&amp; e.code !== &quot;ArrowDown&quot;) {
                        this.$super(e);
                    }
                }
            ]);

            this.TextField = Class(ui.TextField, [
                // let&#x27;s skip parent invalidation
                function invalidate() {
                    this.isValid  = false;
                    this.cachedWidth = -1;
                }
            ]);

            this.createModel = function(item, root, tree) {
                var mi = new zebkit.data.Item();

                if (typeof item.value !== &quot;undefined&quot;) {
                    mi.value = item.value !== null ? item.value : &quot;&quot;;
                } else {
                    mi.value = item;
                }

                mi.value = ui.$component(mi.value, tree);
                mi.parent = root;
                if (typeof item.kids !== &#x27;undefined&#x27; &amp;&amp; item.kids.length &gt; 0 &amp;&amp; zebkit.instanceOf(item, ui.Panel) === false) {
                    for (var i = 0; i &lt; item.kids.length; i++) {
                        mi.kids[i] = this.createModel(item.kids[i], mi, tree);
                    }
                }

                return mi;
            };
        },

        function $prototype() {
            this.$blockCIE = false;
            this.canHaveFocus = false;

            this.getItemPreferredSize = function(root) {
                return root.value.getPreferredSize();
            };

            this.childKeyTyped = function(e) {
                if (this.selected !== null){
                    switch(e.key) {
                        case &#x27;+&#x27;: if (this.isOpen(this.selected) === false) {
                            this.toggle(this.selected);
                        } break;
                        case &#x27;-&#x27;: if (this.isOpen(this.selected)) {
                            this.toggle(this.selected);
                        } break;
                    }
                }
            };

            this.setFont = function(f) {
                this.font = zebkit.isString(f) ? new zebkit.Font(f) : f;
                return this;
            };

            this.childKeyPressed = function(e) {
                if (this.isSelectable === true) {
                    var newSelection = null;
                    if (e.code === &quot;ArrowDown&quot;) {
                        newSelection = this.findNext(this.selected);
                    } else if (e.code === &quot;ArrowUp&quot;) {
                        newSelection = this.findPrev(this.selected);
                    }

                    if (newSelection !== null) {
                        this.select(newSelection);
                    }
                }
            };

            this.childPointerPressed = this.childFocusGained = function(e) {
                if (this.isSelectable === true &amp;&amp; this.$blockCIE !== true) {
                    this.$blockCIE = true;
                    try {
                        var item = zebkit.data.TreeModel.findOne(this.model.root,
                                                                zebkit.layout.getDirectChild(this,
                                                                                            e.source));
                        if (item !== null) {
                            this.select(item);
                        }
                    } finally {
                        this.$blockCIE = false;
                    }
                }
            };

            this.childFocusLost = function(e) {
                if (this.isSelectable === true) {
                    this.select(null);
                }
            };

            this.catchScrolled = function(psx, psy){
                this.vrp();
            };

            this.doLayout = function() {
                this.vVisibility();

                // hide all components
                for(var i = 0; i &lt; this.kids.length; i++) {
                    this.kids[i].setVisible(false);
                }

                if (this.firstVisible !== null) {
                    var $this = this,
                        started = 0;

                    this.model.iterate(this.model.root, function(item) {
                        var node = $this.nodes[item];  // slightly improve performance
                                                       // (instead of calling $this.getIM(...))

                        if (started === 0 &amp;&amp; item === $this.firstVisible) {
                            started = 1;
                        }

                        if (started === 1) {
                            var sy = $this.scrollManager.getSY();

                            if (node.y + sy &lt; $this.height) {
                                var image = $this.getIconBounds(item),
                                    x = image.x + image.width +
                                               (image.width &gt; 0 || $this.getToggleSize(item).width &gt; 0 ? $this.gapx : 0) +
                                               $this.scrollManager.getSX(),
                                    y = node.y + Math.floor((node.height - node.viewHeight) / 2) + sy;

                                item.value.setVisible(true);
                                item.value.setLocation(x, y);
                                item.value.width  = node.viewWidth;
                                item.value.height = node.viewHeight;
                            } else {
                                started = 2;
                            }
                        }

                        return (started === 2) ? 2 : (node.isOpen === false ? 1 : 0);
                    });
                }
            };

            this.itemInserted = function(target, item) {
                this.add(item.value);
            };
        },

        function itemRemoved(target,item){
            this.$super(target,item);
            this.remove(item.value);
        },

        function setModel(model) {
            var old = this.model;

            if (model !== null &amp;&amp; zebkit.instanceOf(model, zebkit.data.TreeModel) === false) {
                model = new zebkit.data.TreeModel(this.clazz.createModel(model, null, this));
            }

            this.$super(model);

            if (old !== this.model) {
                this.removeAll();
                if (this.model !== null) {
                    var $this = this;
                    this.model.iterate(this.model.root, function(item) {
                        $this.add(item.value);
                    });
                }
            }
            return this;
        },

        function recalc() {
            // track with the flag a node metrics has been updated
            this.$isMetricUpdated  = false;
            this.$super();

            // if a node size has been changed we have to force calling
            // repaint method for the whole tree component to render
            // tree lines properly
            if (this.$isMetricUpdated === true) {
                this.repaint();
            }
        },

        function recalc_(x,y,parent,root,isVis) {
            // in a case of component tree node view size has to be synced with
            // component
            var node = this.getIM(root);
            if (isVis === true) {
                var viewSize = this.getItemPreferredSize(root);
                if (this.$isMetricUpdated === false &amp;&amp; (node.viewWidth  !== viewSize.width  ||
                                                        node.viewHeight !== viewSize.height  ))
                {
                    this.$isMetricUpdated = true;
                }

                node.viewWidth  = viewSize.width;
                node.viewHeight = viewSize.height;
            }
            return this.$super(x,y,parent,root,isVis);
        },

        function select(item) {
            if (this.isSelectable === true &amp;&amp; item !== this.selected) {
                var old = this.selected;

                if (old !== null &amp;&amp; old.value.hasFocus()) {
                    ui.focusManager.requestFocus(null);
                }

                this.$super(item);

                if (item !== null) {
                    item.value.requestFocus();
                }
            }
        },

        function makeVisible(item) {
           item.value.setVisible(true);
           this.$super(item);
        }
    ]);


    zebkit.ui.$configWith(pkg);
});
zebkit.package(&quot;ui.grid&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    var ui = pkg.cd(&quot;..&quot;);

    //      ---------------------------------------------------
    //      | x |    col0 width     | x |   col2 width    | x |
    //      .   .
    //    Line width
    //   --&gt;.   .&lt;--

    /**
     * The package contains number of classes and interfaces to implement
     * UI Grid component. The grid allows developers to visualize matrix
     * model, customize the model data editing and rendering.
     *
     *     // create grid that contains 3 rows and four columns
     *     var grid = new zebkit.ui.grid.Grid([
     *         [ &quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;, &quot;Item 4&quot;, &quot;Item 5&quot; ],
     *         [ &quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;, &quot;Item 4&quot;, &quot;Item 5&quot; ],
     *         [ &quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;, &quot;Item 4&quot;, &quot;Item 5&quot; ].
     *     ]);
     *
     *     // add grid top caption
     *     grid.add(&quot;top&quot;, new zebkit.ui.grid.GridCaption([
     *         &quot;Title 1&quot;,
     *         &quot;Title 2&quot;,
     *         &quot;Title 3&quot;,
     *         &quot;Title 5&quot;,
     *         &quot;Title 6&quot;
     *     ]));
     *
     * @class zebkit.ui.grid
     * @access package
     */


    /**
     * Structure to keep grid cells visibility.
     * @constructor
     * @class zebkit.ui.grid.CellsVisibility
     */
    pkg.CellsVisibility = function() {
        this.hasVisibleCells = function(){
            return this.fr !== null &amp;&amp; this.fc !== null &amp;&amp;
                   this.lr !== null &amp;&amp; this.lc !== null   ;
        };

        /**
         * First visible row.
         * @attribute fr
         * @type {Integer}
         * @default null
         */

        /**
         * First visible column.
         * @attribute fc
         * @type {Integer}
         * @default null
         */

        /**
         * Last visible row.
         * @attribute lr
         * @type {Integer}
         * @default null
         */

        /**
         * Last visible column.
         * @attribute lc
         * @type {Integer}
         * @default null
         */

        // first visible row (row and y), first visible
        // col, last visible col and row
        this.fr = this.fc = this.lr = this.lc = null;
    };

    /**
     *  Interface that describes a grid component metrics
     *  @class zebkit.ui.grid.Metrics
     *  @interface zebkit.ui.grid.Metrics
     */
    pkg.Metrics = zebkit.Interface([
        &quot;abstract&quot;,

            /**
             * Get a structure that describes a grid component
             * columns and rows visibility
             * @return {zebkit.ui.grid.CellsVisibility} a grid cells visibility
             * @method getCellsVisibility
             */
            function getCellsVisibility() {},

            /**
             * Get the given column width of a grid component
             * @param {Integer} col a column index
             * @method getColWidth
             * @return {Integer} a column width
             */
            function getColWidth(col) {},

            /**
             * Get the given row height of a grid component
             * @param {Integer} row a row index
             * @method getRowHeight
             * @return {Integer} a row height
             */
            function getRowHeight(row) {},

            /**
             * Get the given column preferred width of a grid component
             * @param {Integer} col a column index
             * @method getPSColWidth
             * @return {Integer} a column preferred width
             */
            function getPSColWidth(col) {},

            /**
             * Get the given row preferred height of a grid component
             * @param {Integer} row a row index
             * @method getPSRowHeight
             * @return {Integer} a row preferred height
             */
            function getPSRowHeight(row) {},

            /**
             * Set the given row height of a grid component
             * @param {Integer} row a row index
             * @param {Integer} height a row height
             * @method setRowHeight
             */
            function setRowHeight(row, height) {},

            /**
             * Set the given column width of a grid component
             * @param {Integer} col a column index
             * @param {Integer} width a column width
             * @method setColWidth
             */
            function setColWidth(col, width) {},

            /**
             * Get number of rows in a grid component
             * @return {Integer} a number of rows
             * @method getGridRows
             */
            function getGridRows() {},

            /**
             * Get number of columns in a grid component
             * @return {Integer} a number of columns
             * @method getGridCols
             */
            function getGridCols() {}
    ]);

     /**
      * Get a x origin of a grid component. Origin indicates how
      * the grid component content has been scrolled
      * @method getXOrigin
      * @return {Integer} a x origin
      */

    /**
      * Get a y origin of a grid component. Origin indicates how
      * the grid component content has been scrolled
      * @method getYOrigin
      * @return {Integer} a y origin
      */

      /**
       * Grid line size
       * @attribute lineSize
       * @type {Integer}
       * @readOnly
       */

      /**
       * Indicate if a grid sizes its rows and cols basing on its preferred sizes
       * @attribute isUsePsMetric
       * @type {Boolean}
       * @readOnly
       */

    /**
     * Default grid cell views provider. The class rules how a grid cell content,
     * background has to be rendered and aligned. Developers can implement an own
     * views providers and than setup it for a grid by calling &quot;setViewProvider(...)&quot;
     * method.
     * @param {zebkit.draw.Render} [render] a string render
     * @class zebkit.ui.grid.DefViews
     * @extends zebkit.draw.BaseViewProvider
     * @constructor
     */
    pkg.DefViews = Class(zebkit.draw.BaseViewProvider, [
        function $prototype() {
            /**
             * Get a renderer to draw the specified grid model value.
             * @param  {zebkit.ui.grid.Grid} target a target Grid component
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {Object} obj   a model value for the given grid cell
             * @return {zebkit.draw.View}  an instance of  view to be used to
             * paint the given cell model value
             * @method  getView
             */

            /**
             * Get an horizontal alignment a content in the given grid cell
             * has to be adjusted. The method is optional.
             * @param  {zebkit.ui.grid.Grid} target a target grid component
             * @param  {Integer} row   a grid cell row
             * @param  {Integer} col   a grid cell column
             * @return {String}  a horizontal alignment (&quot;left&quot;, &quot;center&quot;, &quot;right&quot;)
             * @method  getXAlignment
             */

             /**
              * Get a vertical alignment a content in the given grid cell
              * has to be adjusted. The method is optional.
              * @param  {zebkit.ui.grid.Grid} target a target grid component
              * @param  {Integer} row   a grid cell row
              * @param  {Integer} col   a grid cell column
              * @return {String}  a vertical alignment (&quot;top&quot;, &quot;center&quot;, &quot;bottom&quot;)
              * @method  getYAlignment
              */

             /**
              * Get the given grid cell color
              * @param  {zebkit.ui.grid.Grid} target a target grid component
              * @param  {Integer} row   a grid cell row
              * @param  {Integer} col   a grid cell column
              * @return {String}  a cell color to be applied to the given grid cell
              * @method  getCellColor
              */
        }
    ]);

    /**
     * Stripped rows interface to extend a grid view provider.
     *
     *      var grid = new zebkit.ui.grid.Grid([ ... ]);
     *
     *      // Make grid rows stripped with blue and green colors
     *      grid.provider.extend(zebkit.ui.grid.StrippedRows({
     *          oddView : &quot;blue&quot;,
     *          evenView: &quot;green&quot;
     *      }));
     *
     *
     * @class zebkit.ui.grid.StrippedRows
     * @interface zebkit.ui.grid.StrippedRows
     */
    pkg.StrippedRows = zebkit.Interface([
        function $prototype() {
            /**
             * Odd rows view or color
             * @attribute oddView
             * @type {String|zebkit.draw.View}
             */
            this.oddView  = null;

            /**
             * Even rows view or color
             * @attribute evenView
             * @type {String|zebkit.draw.View}
             */
            this.evenView = null;

            /**
             * Get a cell view.
             * @param  {zebkit.ui.grid.Grid} grid [description]
             * @param  {Integer} row  a cell row
             * @param  {Integer} col  a cell column
             * @return {String|zebkit.draw.View}  a color or view
             * @method getCellColor
             */
            this.getCellColor = function(grid, row, col) {
                return row % 2  === 0 ? this.evenView
                                      : this.oddView;
            };
        }
    ]);

    /**
     * Simple grid cells editors provider implementation. By default the editors provider
     * uses a text field component or check box component as a cell content editor. Check
     * box component is used if a cell data type is boolean, otherwise text filed is applied
     * as the cell editor.

            // grid with tree columns and three rows
            // first and last column will be editable with text field component
            // second column will be editable with check box component
            var grid = new zebkit.ui.grid.Grid([
                [&quot;Text Cell&quot;, true, &quot;Text cell&quot;],
                [&quot;Text Cell&quot;, false, &quot;Text cell&quot;],
                [&quot;Text Cell&quot;, true, &quot;Text cell&quot;]
            ]);

            // make grid cell editable
            grid.setEditorProvider(new zebkit.ui.grid.DefEditors());


     * It is possible to customize a grid column editor by specifying setting &quot;editors[col]&quot; property
     * value. You can define an UI component that has to be applied as an editor for the given column
     * Also you can disable editing by setting appropriate column editor class to null:

            // grid with tree columns and three rows
            // first and last column will be editable with text field component
            // second column will be editable with check box component
            var grid = new zebkit.ui.grid.Grid([
                [&quot;Text Cell&quot;, true, &quot;Text cell&quot;],
                [&quot;Text Cell&quot;, false, &quot;Text cell&quot;],
                [&quot;Text Cell&quot;, true, &quot;Text cell&quot;]
            ]);

            // grid cell editors provider
            var editorsProvider = new zebkit.ui.grid.DefEditors();

            // disable the first column editing
            editorsProvider.editors[0] = null;

            // make grid cell editable
            grid.setEditorProvider(editorsProvider);

     * @constructor
     * @class zebkit.ui.grid.DefEditors
     */
    pkg.DefEditors = Class([
        function() {
            this.textEditor     = new this.clazz.TextField(&quot;&quot;, 150);
            this.boolEditor     = new this.clazz.Checkbox(null);
            this.selectorEditor = new this.clazz.Combo();

            this.editors = {};
        },

        function $clazz() {
            this.TextField = Class(ui.TextField, []);
            this.Checkbox  = Class(ui.Checkbox,  []);
            this.Combo     = Class(ui.Combo,     [
                function padShown(src, b) {
                    if (b === false) {
                        this.parent.stopEditing(true);
                        this.setSize(0,0);
                    }
                },

                function resized(pw, ph) {
                    this.$super(pw, ph);
                    if (this.width &gt; 0 &amp;&amp; this.height &gt; 0 &amp;&amp; this.hasFocus()) {
                        this.showPad();
                    }
                }
            ]);
        },

        function $prototype() {
            /**
             * Fetch an edited value from the given UI editor component.
             * @param  {zebkit.ui.grid.Grid} grid a target grid component
             * @param  {Integer} row a grid cell row that has been edited
             * @param  {Integer} col a grid cell column that has been edited
             * @param  {Object} data an original cell content
             * @param  {zebkit.ui.Panel} editor an editor that has been used to
             * edit the given cell
             * @return {Object} a value that can be applied as a new content of
             * the edited cell content
             * @method  fetchEditedValue
             */
            this.fetchEditedValue = function(grid, row, col, data, editor) {
                return editor.getValue();
            };

            /**
             * Get an editor UI component to be used for the given cell of the specified grid
             * @param  {zebkit.ui.grid.Grid} grid a grid whose cell is going to be edited
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {Object}  v    a grid cell model data
             * @return {zebkit.ui.Panel} an editor UI component to be used to edit the given cell
             * @method  getEditor
             */
            this.getEditor = function(grid, row, col, v) {
                var editor = null;
                if (this.editors.hasOwnProperty(col)) {
                    editor = this.editors[col];
                    if (editor !== null) {
                        editor.setValue(v);
                    }
                    return editor;
                } else {
                    editor = zebkit.isBoolean(v) ? this.boolEditor
                                                 : this.textEditor;

                    editor.setValue(v);
                    editor.setPadding(0);
                    var ah = Math.floor((grid.getRowHeight(row) - editor.getPreferredSize().height)/2);
                    editor.setPadding(ah, grid.cellInsetsLeft, ah, grid.cellInsetsRight);
                    return editor;
                }
            };

            /**
             * Test if the specified input event has to trigger the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid a grid
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers the given cell editing
             * @method shouldStart
             */
            this.shouldStart = function(grid, row, col, e){
                return e.id === &quot;pointerClicked&quot;;
            };

            /**
             * Test if the specified input event has to canceling the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid a grid
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers the given cell editing
             * cancellation
             * @method shouldCancel
             */
            this.shouldCancel = function(grid,row,col,e){
                return e.id === &quot;keyPressed&quot; &amp;&amp; &quot;Escape&quot; === e.code;
            };

            /**
             * Test if the specified input event has to trigger finishing the given grid cell editing
             * @param  {zebkit.ui.grid.Grid} grid [description]
             * @param  {Integer} row  a grid cell row
             * @param  {Integer} col  a grid cell column
             * @param  {zebkit.util.Event} e  an event to be evaluated
             * @return {Boolean} true if the given input event triggers finishing the given cell editing
             * @method shouldFinish
             */
            this.shouldFinish = function(grid,row,col,e){
                return e.id === &quot;keyPressed&quot; &amp;&amp; &quot;Enter&quot; === e.code;
            };
        }
    ]);

    /**
     * Grid caption base UI component class. This class has to be used
     * as base to implement grid caption components
     * @class  zebkit.ui.grid.BaseCaption
     * @extends zebkit.ui.Panel
     * @constructor
     * @param {Array} [titles] a caption component titles
     */

    /**
     * Fire when a grid row selection state has been changed
     *
     *     caption.on(&quot;captionResized&quot;, function(caption, rowcol, phw) {
     *         ...
     *     });
     *
     * @event captionResized
     * @param  {zebkit.ui.grid.BaseCaption} caption a caption
     * @param  {Integer} rowcol a row or column that has been resized
     * @param  {Integer} pwh a previous row or column size
     */
    pkg.BaseCaption = Class(ui.Panel, [
        function(titles) {
            this._ = new this.clazz.Listeners();

            this.$super();

            if (arguments.length &gt; 0) {
                for(var i = 0; i &lt; titles.length; i++) {
                    this.putTitle(i, titles[i]);
                }
            }
        },

        function $clazz() {
            this.Listeners = new zebkit.util.ListenersClass(&quot;captionResized&quot;);
        },

        function $prototype() {
            this.selectedColRow = -1;

            this.orient = this.metrics = this.pxy = null;

            /**
             * Minimal possible grid cell size
             * @type {Number}
             * @default 10
             * @attribute minSize
             */
            this.minSize = 10;

            /**
             * Size of the active area where cells size can be changed by pointer dragging event
             * @attribute activeAreaSize
             * @type {Number}
             * @default 5
             */
            this.activeAreaSize = 5;

            /**
             * Caption line color
             * @attribute lineColor
             * @type {String}
             * @default &quot;gray&quot;
             */
            this.lineColor = &quot;gray&quot;;

            /**
             * Indicate if the grid cell size has to be adjusted according
             * to the cell preferred size by pointer double click event.
             * @attribute isAutoFit
             * @default true
             * @type {Boolean}
             */

            /**
             * Indicate if the grid cells are resize-able.
             * to the cell preferred size by pointer double click event.
             * @attribute isResizable
             * @default true
             * @type {Boolean}
             */
            this.isAutoFit = this.isResizable = true;

            this.getCursorType = function (target, x, y) {
                return this.metrics !== null    &amp;&amp;
                       this.selectedColRow &gt;= 0 &amp;&amp;
                       this.isResizable         &amp;&amp;
                       this.metrics.isUsePsMetric === false ? ((this.orient === &quot;horizontal&quot;) ? ui.Cursor.W_RESIZE
                                                                                              : ui.Cursor.S_RESIZE)
                                                            : null;
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (this.pxy !== null) {
                    var b  = (this.orient === &quot;horizontal&quot;),
                        rc = this.selectedColRow,
                        ns = (b ? this.metrics.getColWidth(rc) + e.x
                                : this.metrics.getRowHeight(rc) + e.y) - this.pxy;

                    this.captionResized(rc, ns);

                    if (ns &gt; this.minSize) {
                        this.pxy = b ? e.x : e.y;
                    }
                }
            };

            /**
             * Define pointer drag started events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e){
                if (this.metrics !== null &amp;&amp;
                    this.isResizable      &amp;&amp;
                    this.metrics.isUsePsMetric === false)
                {
                    this.calcRowColAt(e.x, e.y);

                    if (this.selectedColRow &gt;= 0) {
                        this.pxy = (this.orient === &quot;horizontal&quot;) ? e.x
                                                                  : e.y;
                    }
                }
            };

            /**
             * Define pointer drag ended events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragEnded
             */
            this.pointerDragEnded = function (e){
                if (this.pxy !== null) {
                    this.pxy = null;
                }

                if (this.metrics !== null) {
                    this.calcRowColAt(e.x, e.y);
                }
            };

            /**
             * Define pointer moved events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                if (this.metrics !== null) {
                    this.calcRowColAt(e.x, e.y);
                }
            };

            /**
             * Define pointer clicked events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerClicked
             */
            this.pointerDoubleClicked = function(e) {
                if (this.pxy     === null    &amp;&amp;
                    this.metrics !== null    &amp;&amp;
                    this.selectedColRow &gt;= 0 &amp;&amp;
                    this.isAutoFit === true     )
                {
                    var size = this.getCaptionPS(this.selectedColRow);
                    if (this.orient === &quot;horizontal&quot;) {
                        this.metrics.setColWidth (this.selectedColRow, size);
                    } else {
                        this.metrics.setRowHeight(this.selectedColRow, size);
                    }
                    this.captionResized(this.selectedColRow, size);
                }
            };

            /**
             * Get the given row or column caption preferred size
             * @param  {Integer} rowcol a row or column of a caption
             * @return {Integer}  a size of row or column caption
             * @method getCaptionPS
             */
            this.getCaptionPS = function(rowcol) {
                return 0;
            };

            this.captionResized = function(rowcol, ns) {
                if (ns &gt; this.minSize) {
                    if (this.orient === &quot;horizontal&quot;) {
                        var pw = this.metrics.getColWidth(rowcol);
                        this.metrics.setColWidth(rowcol, ns);
                        this._.captionResized(this, rowcol, pw);
                    } else  {
                        var ph = this.metrics.getRowHeight(rowcol);
                        this.metrics.setRowHeight(rowcol, ns);
                        this._.captionResized(this, rowcol, ph);
                    }
                }
            };

            this.calcRowColAt = function(x, y) {
                var $this = this;
                this.selectedColRow = this.getCaptionAt(x, y, function(m, xy, xxyy, wh, i) {
                    xxyy += (wh + m.lineSize);
                    return (xy &lt; xxyy + $this.activeAreaSize &amp;&amp;
                            xy &gt; xxyy - $this.activeAreaSize   );

                });
            };

            /**
             * Compute a column (for horizontal caption component) or row (for
             * vertically aligned caption component) at the given location
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y an y coordinate
             * @param  {Function} [f] an optional match function. The method can be passed
             * if you need to detect a particular area of row or column. The method gets
             * a grid metrics as the first argument, a x or y location to be detected,
             * a row or column y or x coordinate, a row or column height or width and
             * row or column index. The method has to return true if the given location
             * is in.
             * @return {Integer}  a row or column
             * @method calcRowColAt
             */
            this.getCaptionAt = function (x,y,f){
                if (this.metrics !== null &amp;&amp;
                    x &gt;= 0                &amp;&amp;
                    y &gt;= 0                &amp;&amp;
                    x &lt; this.width        &amp;&amp;
                    y &lt; this.height         )
                {
                    var m     = this.metrics,
                        cv    = m.getCellsVisibility(),
                        isHor = (this.orient === &quot;horizontal&quot;);

                    if ((isHor &amp;&amp; cv.fc !== null) ||
                        (isHor === false &amp;&amp; cv.fr !== null))
                    {
                        var gap  = m.lineSize,
                            xy   = isHor ? x : y,
                            xxyy = isHor ? cv.fc[1] - this.x - gap + m.getXOrigin()
                                         : cv.fr[1] - this.y - gap + m.getYOrigin();

                        for (var i = (isHor ? cv.fc[0] : cv.fr[0]);i &lt;= (isHor ? cv.lc[0] : cv.lr[0]); i ++ ) {
                            var wh = isHor ? m.getColWidth(i) : m.getRowHeight(i);
                            if ((arguments.length &gt; 2 &amp;&amp; f(m, xy, xxyy, wh, i)) ||
                                (arguments.length &lt; 3 &amp;&amp; xy &gt; xxyy &amp;&amp; xy &lt; xxyy + wh))
                            {
                                return i;
                            }
                            xxyy += wh + gap;
                        }
                    }
                }
                return -1;
            };

            this.paintOnTop = function(g) {
                if (this.lineColor !== null &amp;&amp; this.metrics !== null) {
                    var v = this.metrics.getCellsVisibility();
                    if (v !== null) {
                        var m       = this.metrics,
                            b       = this.orient === &quot;horizontal&quot;,
                            startRC = b ? v.fc[0] : v.fr[0],
                            endRC   = b ? v.lc[0] : v.lr[0],
                            xy      = b ? v.fc[1] - this.x - m.lineSize + m.getXOrigin()
                                        : v.fr[1] - this.y - m.lineSize + m.getYOrigin();

                        g.setColor(this.lineColor);
                        for(var i = startRC; i &lt;= endRC; i++) {
                            if (i !== 0) {
                                if (b) {
                                    g.drawLine(xy, 0, xy, this.height, m.lineSize);
                                } else  {
                                    g.drawLine(0, xy, this.width, xy, m.lineSize);
                                }
                            }
                            xy += (b ? m.getColWidth(i): m.getRowHeight(i)) + m.lineSize;
                        }
                    }
                }
            };

            /**
             * Implement the method to be aware when number of rows or columns in
             * a grid model has been updated
             * @param  {zebkit.ui.grid.Grid} target a target grid
             * @param  {Integer} prevRows a previous number of rows
             * @param  {Integer} prevCols a previous number of columns
             * @method matrixResized
             */

            /**
             * Implement the method to be aware when a grid model data has been
             * re-ordered.
             * @param  {zebkit.ui.grid.Grid} target a target grid
             * @param  {Object} sortInfo an order information
             * @method matrixSorted
             */
        },

        function setParent(p) {
            this.$super(p);

            this.metrics = this.orient = null;
            if (p === null || zebkit.instanceOf(p, pkg.Metrics)) {
                this.metrics = p;
                if (this.constraints !== null) {
                    this.orient = (this.constraints === &quot;top&quot;   ||
                                   this.constraints === &quot;bottom&quot;  ) ? &quot;horizontal&quot;
                                                                    : &quot;vertical&quot;;
                }
            }
        }
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Caption cell render. This class can be used to customize grid caption
     * cells look and feel.
     * @param  {zebkit.draw.Render} a render to be used to draw grid caption cells.
     * @constructor
     * @class zebkit.ui.grid.CaptionViewProvider
     * @extends zebkit.ui.grid.DefViews
     */
    pkg.CaptionViewProvider = Class(pkg.DefViews, [
        function $prototype() {
            this.meta = null;

            this.$getCellMeta = function(rowcol) {
                if (this.meta === null) {
                    this.meta = {};
                }

                if (this.meta.hasOwnProperty(rowcol)) {
                    return this.meta[rowcol];
                } else {
                    this.meta[rowcol] = {
                        ax : null,
                        ay : null,
                        bg : null
                    };
                    return this.meta[rowcol];
                }
            };

            this.getXAlignment = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].ax;
            };

            this.getYAlignment = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].ay;
            };

            this.getCellBackground = function(target, rowcol) {
                return this.meta === null || this.meta.hasOwnProperty(rowcol) === false ? null
                                                                                        : this.meta[rowcol].bg;
            };

            this.setTitleAlignments = function(rowcol, ax, ay) {
                var m = this.$getCellMeta(rowcol);
                if (m.ax !== ax || m.ay !== ay) {
                    m.ax = ax;
                    m.ay = ay;
                    return true;
                } else {
                    return false;
                }
            };

            this.setCellBackground = function(rowcol, bg) {
                var m = this.$getCellMeta(rowcol);
                if (m.bg !== bg) {
                    m.bg = zebkit.draw.$view(bg);
                    return true;
                } else {
                    return false;
                }
            };
        }
    ]);

    /**
     * Grid caption class that implements rendered caption.
     * Rendered means all caption titles, border are painted
     * as a number of views.
     * @param  {Array} [titles] a caption titles. Title can be a string or
     * a zebkit.draw.View class instance
     * @param  {zebkit.draw.BaseTextRender} [render] a text render to be used
     * to paint grid titles
     * @constructor
     * @class zebkit.ui.grid.GridCaption
     * @extends zebkit.ui.grid.BaseCaption
     */
    pkg.GridCaption = Class(pkg.BaseCaption, [
        function(titles, render) {
            this.titles = {};

            this.setViewProvider(new pkg.CaptionViewProvider(render));

            if (arguments.length === 0) {
                this.$super();
            } else {
                this.$super(titles);
            }
        },

        function $prototype() {
            this.psW = this.psH = 0;

            /**
             * Grid caption view provider.
             * @attribute provider
             * @type {zebkit.ui.grid.CaptionViewProvider}
             * @readOnly
             */
            this.provider = null;

            /**
             * Default vertical cell view alignment.
             * @attribute defYAlignment
             * @type {String}
             * @default &quot;center&quot;
             */
            this.defYAlignment = &quot;center&quot;;

            /**
             * Default horizontal cell view alignment.
             * @attribute defYAlignment
             * @type {String}
             * @default &quot;center&quot;
             */
            this.defXAlignment = &quot;center&quot;;

            /**
             * Default cell background view.
             * @attribute defCellBg
             * @type {zebkit.draw.View}
             * @default null
             */
            this.defCellBg = null;

            /**
             * Set the given caption view provider.
             * @param {zebkit.ui.grid.CaptionViewProvider} p a caption view provider.
             * @method setViewProvider
             * @chainable
             */
            this.setViewProvider = function(p) {
                if (p !== this.provider) {
                    this.provider = p;
                    this.vrp();
                }
                return this;
            };

            /**
             * Get rendered caption cell object.
             * @param  {Ineteger} rowcol a row or column
             * @return {Object} a rendered caption cell object
             * @method getTitle
             */
            this.getTitle = function(rowcol) {
                return this.titles.hasOwnProperty(rowcol) ? this.titles[rowcol]
                                                          : null;
            };

            this.calcPreferredSize = function (l) {
                return { width:this.psW, height:this.psH };
            };

            this.setFont = function(f) {
                this.provider.setFont(f);
                this.vrp();
                return this;
            };

            this.setColor = function(c) {
                this.provider.setColor(c);
                this.repaint();
                return this;
            };

            this.recalc = function(){
                this.psW = this.psH = 0;
                if (this.metrics !== null){
                    var m     = this.metrics,
                        isHor = (this.orient === &quot;horizontal&quot;),
                        size  = isHor ? m.getGridCols() : m.getGridRows();

                    for (var i = 0;i &lt; size; i++) {
                        var v = this.provider.getView(this, i, this.getTitle(i));
                        if (v !== null) {
                            var ps = v.getPreferredSize();
                            if (isHor === true) {
                                if (ps.height &gt; this.psH) {
                                    this.psH = ps.height;
                                }
                                this.psW += ps.width;
                            } else {
                                if (ps.width &gt; this.psW) {
                                    this.psW = ps.width;
                                }
                                this.psH += ps.height;
                            }
                        }
                    }

                    if (this.psH === 0) {
                        this.psH = pkg.Grid.DEF_ROWHEIGHT;
                    }

                    if (this.psW === 0) {
                        this.psW = pkg.Grid.DEF_COLWIDTH;
                    }
                }
            };

            /**
             * Put the given title for the given caption cell.
             * @param  {Integer} rowcol a grid caption cell index
             * @param  {String|zebkit.draw.View|zebkit.ui.Panel} title a title of the given
             * grid caption cell. Can be a string or zebkit.draw.View or zebkit.ui.Panel
             * class instance
             * @method putTitle
             * @chainable
             */
            this.putTitle = function(rowcol, value) {
                if (value === null) {
                    if (this.titles.hasOwnProperty(rowcol)) {
                        delete this.titles[rowcol];
                    }
                } else {
                    this.titles[rowcol] = value;
                }

                this.vrp();
                return this;
            };

            /**
             * Set the specified alignments of the given caption column or row.
             * @param {Integer} rowcol a row or column depending on the caption orientation
             * @param {String} xa a horizontal caption cell alignment. Use &quot;left&quot;, &quot;right&quot; or
             * &quot;center&quot; as the title alignment value.
             * @param {String} ya a vertical caption cell alignment. Use &quot;top&quot;, &quot;bottom&quot; or
             * &quot;center&quot; as the title alignment value.
             * @method setTitleAlignments
             * @chainable
             */
            this.setTitleAlignments = function(rowcol, xa, ya){
                if (this.provider.setTitleAlignments(rowcol, xa, ya)) {
                    this.repaint();
                }
                return this;
            };

            /**
             * Set the given caption cell background
             * @param {Integer} rowcol a caption cell row or column
             * @param {zebkit.draw.View|String} bg a color or view
             * @method setCellBackground
             * @chainable
             */
            this.setCellBackground = function(rowcol, bg) {
                if (this.provider.setCellBackground(rowcol, bg)) {
                    this.repaint();
                }
                return this;
            };

            /**
             * Get cell caption preferred size.
             * @param  {Integer} rowcol row or col of the cell depending the caption
             * orientation.
             * @return {Integer} a preferred width or height of the cell
             * @method getCaptionPS
             * @protected
             */
            this.getCaptionPS = function(rowcol) {
                var v = this.provider.getView(this, rowcol, this.getTitle(rowcol));
                return (v !== null) ? (this.orient === &quot;horizontal&quot; ? v.getPreferredSize().width
                                                                    : v.getPreferredSize().height)
                                    : 0;
            };
        },

        function paintOnTop(g) {
            if (this.metrics !== null){
                var cv = this.metrics.getCellsVisibility();

                if ((cv.fc !== null &amp;&amp; cv.lc !== null &amp;&amp; this.orient === &quot;horizontal&quot;)||
                    (cv.fr !== null &amp;&amp; cv.lr !== null &amp;&amp; this.orient === &quot;vertical&quot;  )   )
                {
                    var isHor  = (this.orient === &quot;horizontal&quot;),
                        gap    = this.metrics.lineSize,
                        top    = this.getTop(),
                        left   = this.getLeft(),
                        bottom = this.getBottom(),
                        right  = this.getRight(),
                        x      = isHor ? cv.fc[1] - this.x + this.metrics.getXOrigin() - gap
                                       : left,
                        y      = isHor ? top
                                       : cv.fr[1] - this.y + this.metrics.getYOrigin() - gap,
                        size   = isHor ? this.metrics.getGridCols()
                                       : this.metrics.getGridRows();

                    //           top
                    //           &gt;|&lt;
                    //  +=========|===========================
                    //  ||        |
                    //  ||   +====|============+     +========
                    //  ||   ||   |            ||   ||
                    //  ||--------&gt; left       ||   ||
                    //  ||   ||&lt;--------------&gt;||   ||
                    //  ||   ||       ww       ||   ||
                    //  ||   ||                ||   ||
                    // &gt;-------&lt; lineSize      ||   ||
                    //  ||   ||                ||   ||
                    //  x   first
                    //      visible

                    for(var i = (isHor ? cv.fc[0] : cv.fr[0]); i &lt;= (isHor ? cv.lc[0] : cv.lr[0]); i++) {
                        var ww = isHor ? this.metrics.getColWidth(i)
                                       : this.width - left - right,
                            hh = isHor ? this.height - top - bottom
                                       : this.metrics.getRowHeight(i),
                            v = this.provider.getView(this, i, this.getTitle(i));

                        if (v !== null) {
                            var xa = this.provider.getXAlignment(this, i, v),
                                ya = this.provider.getYAlignment(this, i, v),
                                bg = this.provider.getCellBackground(this, i, v);

                            if (xa === null) {
                                xa = this.defXAlignment;
                            }

                            if (ya === null) {
                                ya = this.defYAlignment;
                            }

                            if (bg === null) {
                                bg = this.defCellBg;
                            }

                            var ps = v.getPreferredSize(),
                                vx = xa === &quot;center&quot; ? Math.floor((ww - ps.width)/2)
                                                     : (xa === &quot;right&quot; ? ww - ps.width - ((i === size - 1) ? right : 0)
                                                                       : (i === 0 ? left: 0)),
                                vy = ya === &quot;center&quot; ? Math.floor((hh - ps.height)/2)
                                                     : (ya === &quot;bottom&quot; ? hh - ps.height - ((i === size - 1) ? bottom : 0)
                                                                        : (i === 0 ? top: 0));
                            if (bg !== null) {
                                if (isHor) {
                                    bg.paint(g, x, 0, ww + gap , this.height, this);
                                } else  {
                                    bg.paint(g, 0, y, this.width, hh + gap, this);
                                }
                            }

                            g.save();
                            g.clipRect(x + gap, y + gap, ww, hh);
                            v.paint(g, x + vx + gap, y + vy + gap, ps.width, ps.height, this);
                            g.restore();
                        }

                        if (isHor) {
                            x += ww + gap;
                        } else {
                            y += hh + gap;
                        }
                    }
                }

                this.$super(g);
            }
        }
    ]);

    /**
     * Predefined left vertical grid caption.
     * @constructor
     * @class zebkit.ui.grid.LeftGridCaption
     * @extends zebkit.ui.grid.GridCaption
     */
    pkg.LeftGridCaption = Class(pkg.GridCaption, [
        function $prototype() {
            this.constraints = &quot;left&quot;;
        }
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Grid caption class that implements component based caption.
     * Component based caption uses other UI component as the
     * caption titles.
     * @param  {Array} a caption titles. Title can be a string or
     * a zebkit.ui.Panel class instance
     * @constructor
     * @class zebkit.ui.grid.CompGridCaption
     * @extends zebkit.ui.grid.BaseCaption
     */
    pkg.CompGridCaption = Class(pkg.BaseCaption, [
        function(titles) {
            if (arguments.length === 0) {
                this.$super();
            } else {
                this.$super(titles);
            }

            this.setLayout(new this.clazz.Layout());
        },

        function $clazz() {
            this.Layout = Class(zebkit.layout.Layout, [
                function $prototype() {
                    this.doLayout = function (target) {
                        var m    = target.metrics,
                            b    = target.orient === &quot;horizontal&quot;,
                            top  = target.getTop(),
                            left = target.getLeft(),
                            wh   = (b ? target.height - top  - target.getBottom()
                                      : target.width  - left - target.getRight()),
                            xy   = (b ? left + m.getXOrigin()
                                      : top  + m.getYOrigin());

                        for (var i = 0; i &lt; target.kids.length; i++) {
                            var kid = target.kids[i],
                                cwh = (b ? m.getColWidth(i)
                                         : m.getRowHeight(i));

                            if (i === 0) {
                                cwh -= (b ? (left - m.lineSize) : top);
                            }

                            if (kid.isVisible === true) {
                                if (b) {
                                    kid.setBounds(xy, top, cwh, wh);
                                } else {
                                    kid.setBounds(left, xy, wh, cwh);
                                }
                            }

                            xy += (cwh + m.lineSize);
                        }
                    };

                    this.calcPreferredSize = function (target) {
                        return zebkit.layout.getMaxPreferredSize(target);
                    };
                }
            ]);

            this.Link = Class(ui.Link, []);

            this.StatusPan = Class(ui.StatePan, []);

            /**
             * Title panel that is designed to be used as CompGridCaption UI component title element.
             * The panel keeps a grid column or row title, a column or row sort indicator. Using the
             * component you can have sortable grid columns.
             * @constructor
             * @param {String} a grid column or row title
             * @class zebkit.ui.grid.CompGridCaption.TitlePan
             */
            var clazz = this;
            this.TitlePan = Class(ui.Panel, [
                function(title) {
                    this.$super();

                    /**
                     * Image panel to keep grtid caption title
                     * @attribute iconPan
                     * @type {zebkit.ui.ImagePan}
                     * @readOnly
                     */
                    this.iconPan = new ui.ImagePan(null);

                    /**
                     * Title link
                     * @attribute link
                     * @type {zebkit.ui.Link}
                     * @readOnly
                     */
                    this.link = new clazz.Link(title);
                    this.statusPan = new clazz.StatusPan();
                    this.statusPan.setVisible(this.isSortable);

                    this.add(this.iconPan);
                    this.add(this.link);
                    this.add(this.statusPan);
                },

                function $clazz() {
                    this.layout = new zebkit.layout.FlowLayout(&quot;center&quot;, &quot;center&quot;, &quot;horizontal&quot;, 8);
                },

                function $prototype() {
                    this.sortState = 0;

                    /**
                     * Indicates if the title panel has to initiate a column sorting
                     * @default false
                     * @attribute isSortable
                     * @readOnly
                     * @type {Boolean}
                     */
                    this.isSortable = false;
                },

                function getGridCaption() {
                    var c = this.parent;
                    while(c !== null &amp;&amp; zebkit.instanceOf(c, pkg.BaseCaption) === false) {
                        c = c.parent;
                    }
                    return c;
                },

                function matrixSorted(target, info) {
                    if (this.isSortable) {
                        var col = this.parent.indexOf(this);
                        if (info.col === col) {
                            this.sortState = info.name === &#x27;descent&#x27; ? 1 : -1;
                            this.statusPan.setState(info.name);
                        } else {
                            this.sortState = 0;
                            this.statusPan.setState(&quot;*&quot;);
                        }
                    }
                },

                /**
                 * Set the caption icon
                 * @param {String|Image} path a path to an image or image object
                 * @method setIcon
                 * @chainable
                 */
                function setIcon(path) {
                    this.iconPan.setImage(path);
                    return this;
                },

                function matrixResized(target, prevRows, prevCols){
                    if (this.isSortable) {
                        this.sortState = 0;
                        this.statusPan.setState(&quot;*&quot;);
                    }
                },

                function fired(target) {
                    if (this.isSortable === true) {
                        var f = this.sortState === 1 ? zebkit.data.ascent
                                                     : zebkit.data.descent,
                            model = this.getGridCaption().metrics.model,
                            col   = this.parent.indexOf(this);
                        model.sortCol(col, f);
                    }
                },

                function kidRemoved(index, kid) {
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.off(this);
                    }
                    this.$super(index, kid);
                },

                function kidAdded(index, constr, kid) {
                    // TODO: not very prefect check
                    if (zebkit.instanceOf(kid, zebkit.util.Fireable)) {
                        kid.on(this);
                    }
                    this.$super(index, constr, kid);
                }
            ]);
        },

        /**
         * @for zebkit.ui.grid.CompGridCaption
         */
        function $prototype() {
            this.catchInput = function(t) {
                return zebkit.instanceOf(t, zebkit.util.Fireable) === false;
            };

            this.scrolled = function() {
                this.vrp();
            };

            /**
             * Put the given title component for the given caption cell.
             * @param  {Integer} rowcol a grid caption cell index
             * @param  {String|zebkit.ui.Panel|zebkit.draw.View} title a title of the given grid caption cell.
             * Can be a string or zebkit.draw.View or zebkit.ui.Panel class instance
             * @method putTitle
             * @chainable
             */
            this.putTitle = function(rowcol, t) {
                // add empty titles
                for(var i = this.kids.length - 1;  i &gt;= 0 &amp;&amp; i &lt; rowcol; i++) {
                    this.add(new this.clazz.TitlePan(&quot;&quot;));
                }

                if (zebkit.isString(t)) {
                    t = new this.clazz.TitlePan(t);
                } else if (zebkit.instanceOf(t, zebkit.draw.View)) {
                    var p = new ui.ViewPan();
                    p.setView(t);
                    t = p;
                }

                if (rowcol &lt; this.kids.length) {
                    this.setAt(rowcol, t);
                } else {
                    this.add(t);
                }

                return this;
            };

            /**
             * Set the given column sortable state
             * @param {Integer} col a column
             * @param {Boolean} b true if the column has to be sortable
             * @method setSortable
             * @chainable
             */
            this.setSortable = function(col, b) {
                var c = this.kids[col];
                if (c.isSortable !== b) {
                    c.isSortable = b;
                    c.statusPan.setVisible(b);
                }
                return this;
            };

            this.matrixSorted = function(target, info) {
                for(var i = 0; i &lt; this.kids.length; i++) {
                    if (this.kids[i].matrixSorted) {
                        this.kids[i].matrixSorted(target, info);
                    }
                }
            };

            this.matrixResized = function(target,prevRows,prevCols){
                for(var i = 0; i &lt; this.kids.length; i++) {
                    if (this.kids[i].matrixResized) {
                        this.kids[i].matrixResized(target,prevRows,prevCols);
                    }
                }
            };

            this.getCaptionPS = function(rowcol) {
                return rowcol &lt; this.kids.length ? (this.orient === &quot;horizontal&quot; ? this.kids[rowcol].getPreferredSize().width
                                                                                 : this.kids[rowcol].getPreferredSize().height)
                                                 : 0;
            };
        },

        function captionResized(rowcol, ns) {
            this.$super(rowcol, ns);
            this.vrp();
        },

        function setParent(p) {
            if (this.parent !== null &amp;&amp; typeof this.parent.scrollManager !== &quot;undefined&quot; &amp;&amp; this.parent.scrollManager !== null) {
                this.parent.scrollManager.off(this);
            }

            if (p !== null &amp;&amp; typeof p.scrollManager !== &#x27;undefined&#x27; &amp;&amp; p.scrollManager !== null) {
                p.scrollManager.on(this);
            }

            this.$super(p);
        },

        function insert(i,constr, c) {
            if (zebkit.isString(c)) {
                c = new this.clazz.TitlePan(c);
            }
            this.$super(i,constr, c);
        }
    ]);

    /**
     * Predefined left vertical component grid caption.
     * @constructor
     * @class zebkit.ui.grid.LeftCompGridCaption
     * @extends zebkit.ui.grid.CompGridCaption
     */
    pkg.LeftCompGridCaption = Class(pkg.CompGridCaption, [
        function $prototype() {
            this.constraints = &quot;left&quot;;
        }
    ]);



    var ui = pkg.cd(&quot;..&quot;);

    // TODO: this is the future thoughts regarding
    // grid cell selection customization
    pkg.RowSelMode = Class([
        function $prototype() {
            this.selectedIndex = 0;
            this.$blocked = false;

            this.isSelected = function(row, col) {
                return row &gt;= 0 &amp;&amp; this.selectedIndex === row;
            };

            this.select = function(row, col, b) {
                if (arguments.length === 1 || (arguments.length === 2 &amp;&amp; zebkit.isNumber(col))) {
                    b = true;
                }

                if (this.isSelected(row, col) !== b){
                    if (this.selectedIndex &gt;= 0) {
                        this.clearSelect();
                    }

                    if (b === true) {
                        this.selectedIndex = row;
                        this.target._.rowSelected();
                    }
                }
            };

            this.clearSelect = function() {
                if (this.selectedIndex &gt;= 0) {
                    this.selectedIndex = -1;
                    this.target._.rowSelected();
                }
            };

            this.posChanged = function(src) {
                if (this.$blocked === false) {
                    this.$blocked = true;
                    try {

                    }
                    finally {
                        this.$blocked = false;
                    }
                }
            };
        }
    ]);

    /**
     * Grid UI component class. The grid component visualizes &quot;zebkit.data.Matrix&quot; data model.
     * Grid cell visualization can be customized by defining and setting an own view provider.
     * Grid component supports cell editing. Every existent UI component can be configured
     * as a cell editor by defining an own editor provider.
     *

            // create a grid that contains three rows and tree columns
            var grid  = new zebkit.ui.grid.Grid([
                [ &quot;Cell 1.1&quot;, &quot;Cell 1.2&quot;, &quot;Cell 1.3&quot;],
                [ &quot;Cell 2.1&quot;, &quot;Cell 2.2&quot;, &quot;Cell 2.3&quot;],
                [ &quot;Cell 3.1&quot;, &quot;Cell 3.2&quot;, &quot;Cell 3.3&quot;]
            ]);

            // add the top caption
            grid.add(&quot;top&quot;, new zebkit.ui.grid.GridCaption([
                &quot;Caption title 1&quot;, &quot;Caption title 2&quot;, &quot;Caption title 3&quot;
            ]));

            // set rows size
            grid.setRowsHeight(45);

     *
     * Grid can have top and left captions.
     * @class  zebkit.ui.grid.Grid
     * @constructor
     * @param {zebkit.data.Matrix|Array} [model] a matrix model to be visualized with the grid
     * component. It can be an instance of zebkit.data.Matrix class or an array that contains
     * embedded arrays. Every embedded array is a grid row.
     * @param {Integer} [rows]  a number of rows
     * @param {Integer} [columns] a number of columns
     * @extends zebkit.ui.Panel
     * @uses zebkit.ui.grid.Metrics
     * @uses zebkit.ui.DecorationViews
     */

    /**
     * Fire when a grid row selection state has been changed

            grid.on(function(grid, row, count, status) {
                ...
            });

     * @event rowSelected
     * @param  {zebkit.ui.grid.Grid} grid a grid that triggers the event
     * @param  {Integer} row a first row whose selection state has been updated. The row is
     * -1 if all selected rows have been unselected
     * @param  {Integer} count a number of rows whose selection state has been updated
     * @param {Boolean} status a status. true means rows have been selected
     */
    pkg.Grid = Class(ui.Panel, zebkit.util.Position.Metric, pkg.Metrics, ui.DecorationViews, [
        function(model) {
            /**
             * Default cell background color
             * @type {String}
             * @attribute defCellColor
             * @default pkg.DefViews.cellBackground
             */
            this.defCellColor = pkg.DefViews.cellBackground;

            if (arguments.length === 0) {
                model = new this.clazz.Matrix(5, 5);
            } else if (arguments.length === 2) {
                model = new this.clazz.Matrix(arguments[0], arguments[1]);
            }

            this._ = new this.clazz.Listeners();
            this.views = {};

            this.visibility = new pkg.CellsVisibility();

            this.$super();

            this.add(&quot;corner&quot;, new this.clazz.CornerPan());
            this.setModel(model);
            this.setViewProvider(new pkg.DefViews());
            this.setPosition(new zebkit.util.Position(this));
            this.scrollManager = new ui.ScrollManager(this);
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;rowSelected&quot;);
            this.Matrix    = Class(zebkit.data.Matrix, []);

            this.DEF_COLWIDTH  = 80;
            this.DEF_ROWHEIGHT = 25;
            this.CornerPan = Class(ui.Panel, []);
        },

        function $prototype() {
            this.psWidth_    = this.psHeight_  = this.colOffset = 0;
            this.rowOffset   = this.pressedCol = this.selectedIndex = 0;
            this.scrollManager = this.model = this.visibleArea = null;

            /**
             * Reference to top caption component
             * @attribute topCaption
             * @type {zebkit.ui.grid.GridCaption|zebkit.ui.grid.CompGridCaption}
             * @default null
             * @readOnly
             */

            /**
             * Reference to left caption component
             * @attribute leftCaption
             * @type {zebkit.ui.grid.GridCaption|zebkit.ui.grid.CompGridCaption}
             * @default null
             * @readOnly
             */
            this.editor = this.editors = this.leftCaption = this.topCaption = this.colWidths = null;
            this.rowHeights = this.position = this.stub = null;

            /**
             * Currently editing row. -1 if no row is editing
             * @attribute editingRow
             * @type {Integer}
             * @default -1
             * @readOnly
             */

            /**
             * Currently editing column. -1 if no column is editing
             * @attribute editingCol
             * @type {Integer}
             * @default -1
             * @readOnly
             */
            this.editingRow = this.editingCol = this.pressedRow = -1;

            /**
             * Grid navigation mode
             * @attribute navigationMode
             * @default &quot;row&quot;
             * @type {String}
             */
            this.navigationMode = &quot;row&quot;;

            /**
             * Grid line size
             * @attribute lineSize
             * @default 1
             * @type {Integer}
             */

            /**
             * Grid cell top padding
             * @attribute cellInsetsTop
             * @default 1
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell left padding
             * @attribute cellInsetsLeft
             * @default 2
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell bottom padding
             * @attribute cellInsetsBottom
             * @default 1
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell right padding
             * @attribute cellInsetsRight
             * @default 2
             * @type {Integer}
             * @readOnly
             */
            this.lineSize = this.cellInsetsTop = this.cellInsetsBottom = 1;
            this.cellInsetsLeft = this.cellInsetsRight = 2;

            /**
             * Default cell content horizontal alignment
             * @type {String}
             * @attribute defXAlignment
             * @default &quot;left&quot;
             */
            this.defXAlignment = &quot;left&quot;;

            /**
             * Default cell content vertical alignment
             * @type {String}
             * @attribute defYAlignment
             * @default &quot;center&quot;
             */
            this.defYAlignment = &quot;center&quot;;

            /**
             * Indicate if vertical lines have to be rendered
             * @attribute drawVerLines
             * @type {Boolean}
             * @readOnly
             * @default true
             */
            this.drawHorLines = true;

            /**
             * Indicate if horizontal lines have to be rendered
             * @attribute drawHorLines
             * @type {Boolean}
             * @readOnly
             * @default true
             */
            this.drawVerLines = true;

            /**
             * Indicates if left and right grid net vertical lines
             * have to be rendered or not.
             * @attribute drawSideLines
             * @type {Boolean}
             * @readOnly
             * @default true
             */
            this.drawSideLines = true;

            /**
             * Line color
             * @attribute lineColor
             * @type {String}
             * @default gray
             * @readOnly
             */
            this.lineColor = &quot;gray&quot;;

            /**
             * Indicate if size of grid cells have to be calculated
             * automatically basing on its preferred heights and widths
             * @attribute isUsePsMetric
             * @type {Boolean}
             * @default false
             * @readOnly
             */
            this.isUsePsMetric = false;

            /**
             * Defines if the pos narker has to be renederd over rendered data
             * @attribute paintPosMarkerOver
             * @type {Boolean}
             * @default true
             */
            this.paintPosMarkerOver = true;

            this.$topY = function() {
                // grid without top caption renders line at the top, so we have to take in account
                // the place for the line
                return this.getTop() +
                      (this.topCaption === null || this.topCaption.isVisible === false ? this.lineSize
                                                                                       : this.getTopCaptionHeight());
            };

            this.$leftX = function() {
                // grid without left caption renders line at the left, so we have to take in account
                // the place for the line
                return this.getLeft() +
                      (this.leftCaption === null || this.leftCaption.isVisible === false ? this.lineSize
                                                                                         : this.getLeftCaptionWidth());
            };

            /**
             * Set the grid cell content default horizontal alignment.
             * @param {String} ax a horizontal alignment. Use &quot;left&quot;, &quot;right&quot; or &quot;center&quot;
             * as the alignment value.
             * @method setDefCellXAlignment
             * @chainable
             */
            this.setDefCellXAlignment = function(ax) {
                this.setDefCellAlignments(ax, this.defYAlignment);
                return this;
            };

            /**
             * Set the grid cell default vertical alignment.
             * @param {String} ay a vertical alignment. Use &quot;top&quot;, &quot;bottom&quot; or &quot;center&quot;
             * as the alignment value.
             * @method setDefCellYAlignment
             * @chainable
             */
            this.setDefCellYAlignment = function(ay) {
                this.setDefCellAlignments(this.defXAlignment, ay);
                return this;
            };

            /**
             * Set the grid cell default horizontal and vertical alignments.
             * @param {String} ax a horizontal alignment. Use &quot;left&quot;, &quot;right&quot; or &quot;center&quot;
             * @param {String} ay a horizontal alignment. Use &quot;top&quot;, &quot;bottom&quot; or &quot;center&quot;
             * as the alignment value.
             * @method setDefCellAlignments
             * @chainable
             */
            this.setDefCellAlignments = function(ax, ay) {
                if (this.defXAlignment !== ax || this.defYAlignment !== ay) {
                    this.defXAlignment = ax;
                    this.defYAlignment = ay;
                    this.repaint();
                }
                return this;
            };

            this.colVisibility = function(col,x,d,b){
                var cols = this.getGridCols();
                if (cols === 0) {
                    return null;
                } else {
                    var left = this.getLeft(),
                        dx   = this.scrollManager.getSX(),
                        xx1  = Math.min(this.visibleArea.x + this.visibleArea.width,
                                        this.width - this.getRight()),
                        xx2  = Math.max(left, this.visibleArea.x +
                                        this.getLeftCaptionWidth());

                    for(; col &lt; cols &amp;&amp; col &gt;= 0; col += d) {
                        if (x + dx &lt; xx1 &amp;&amp; (x + this.colWidths[col] + dx) &gt; xx2) {
                            if (b) {
                                return [col, x];
                            }
                        } else if (b === false)  {
                            return this.colVisibility(col, x, (d &gt; 0 ?  -1 : 1), true);
                        }

                        if (d &lt; 0) {
                            if (col &gt; 0) {
                                x -= (this.colWidths[col - 1] + this.lineSize);
                            }
                        } else {
                            if (col &lt; cols - 1) {
                                x += (this.colWidths[col] + this.lineSize);
                            }
                        }
                    }
                    return b ? null : ((d &gt; 0) ? [col -1, x]
                                               : [0, this.$leftX() ]);
                }
            };

            this.rowVisibility = function(row,y,d,b) {
                var rows = this.getGridRows();
                if (rows === 0) {
                    return null;
                } else {
                    var top = this.getTop(),
                        dy  = this.scrollManager.getSY(),
                        yy1 = Math.min(this.visibleArea.y + this.visibleArea.height,
                                       this.height - this.getBottom()),
                        yy2 = Math.max(this.visibleArea.y,
                                       top + this.getTopCaptionHeight());

                    for(; row &lt; rows &amp;&amp; row &gt;= 0; row += d){
                        if (y + dy &lt; yy1 &amp;&amp; (y + this.rowHeights[row] + dy) &gt; yy2){
                            if (b) {
                                return [row, y];
                            }
                        } else {
                            if (b === false) {
                                return this.rowVisibility(row, y, (d &gt; 0 ?  -1 : 1), true);
                            }
                        }

                        if (d &lt; 0){
                            if (row &gt; 0) {
                                y -= (this.rowHeights[row - 1] + this.lineSize);
                            }
                        } else {
                            if (row &lt; rows - 1) {
                                y += (this.rowHeights[row] + this.lineSize);
                            }
                        }
                    }
                    return b ? null : ((d &gt; 0) ? [row - 1, y]
                                               : [0, this.$topY()]);
                }
            };

            this.vVisibility = function(){
                var va = ui.$cvp(this, {});
                if (va === null) {
                    this.visibleArea = null;
                    this.visibility.fr = null; // say no visible cells are available
                } else {
                    // visible area has not been calculated or
                    // visible area has been changed
                    if (this.visibleArea === null            ||
                        va.x !== this.visibleArea.x          ||
                        va.y !== this.visibleArea.y          ||
                        va.width  !== this.visibleArea.width ||
                        va.height !== this.visibleArea.height  )
                    {
                        this.iColVisibility(0);
                        this.iRowVisibility(0);
                        this.visibleArea = va;
                    }

                    var v = this.visibility,
                        b = v.hasVisibleCells();

                    if (this.colOffset !== 100) {
                        if (this.colOffset &gt; 0 &amp;&amp; b){
                            v.lc = this.colVisibility(v.lc[0], v.lc[1],  -1, true);
                            v.fc = this.colVisibility(v.lc[0], v.lc[1],  -1, false);
                        } else {
                            if (this.colOffset &lt; 0 &amp;&amp; b) {
                                v.fc = this.colVisibility(v.fc[0], v.fc[1], 1, true);
                                v.lc = this.colVisibility(v.fc[0], v.fc[1], 1, false);
                            } else {
                                v.fc = this.colVisibility(0, this.$leftX(), 1, true);
                                v.lc = (v.fc !== null) ? this.colVisibility(v.fc[0], v.fc[1], 1, false)
                                                       : null;
                            }
                        }
                        this.colOffset = 100;
                    }

                    if (this.rowOffset !== 100) {
                        if (this.rowOffset &gt; 0 &amp;&amp; b) {
                            v.lr = this.rowVisibility(v.lr[0], v.lr[1],  -1, true);
                            v.fr = this.rowVisibility(v.lr[0], v.lr[1],  -1, false);
                        } else {
                            if(this.rowOffset &lt; 0 &amp;&amp; b){
                                v.fr = this.rowVisibility(v.fr[0], v.fr[1], 1, true);
                                v.lr = (v.fr !== null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                            } else {
                                v.fr = this.rowVisibility(0, this.$topY(), 1, true);
                                v.lr = (v.fr !== null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                            }
                        }
                        this.rowOffset = 100;
                    }
                }
            };

            /**
             * Make the given cell visible.
             * @param  {Integer} row a cell row
             * @param  {Integer} col a cell column
             * @method makeVisible
             * @chainable
             */
            this.makeVisible = function(row, col) {
                var top  = this.getTop()  + this.getTopCaptionHeight(),
                    left = this.getLeft() + this.getLeftCaptionWidth(),
                    o    = ui.calcOrigin(this.getColX(col) ,
                                         this.getRowY(row) ,

                                         // width depends on marker mode: cell or row
                                         this.getLineSize(row) &gt; 1 ? this.colWidths[col] + this.lineSize
                                                                 : this.psWidth_,
                                         this.rowHeights[row] + this.lineSize,
                                         this.scrollManager.getSX(),
                                         this.scrollManager.getSY(),
                                         this, top, left,
                                         this.getBottom(),
                                         this.getRight());

                this.scrollManager.scrollTo(o[0], o[1]);
                return this;
            };

            this.$se = function(row, col, e) {
                if (row &gt;= 0) {
                    this.stopEditing(true);

                    if (this.editors !== null &amp;&amp;
                        this.editors.shouldStart(this, row, col, e))
                    {
                        return this.startEditing(row, col);
                    }
                }
                return false;
            };

            this.getXOrigin = function() {
                return this.scrollManager.getSX();
            };

            this.getYOrigin = function () {
                return this.scrollManager.getSY();
            };

            /**
             * Get a preferred width the given column wants to have
             * @param  {Integer} col a column
             * @return {Integer} a preferred width of the given column
             * @method getColPSWidth
             */
            this.getColPSWidth = function(col){
                return this.getPSSize(col, false);
            };

            /**
             * Get a preferred height the given row wants to have
             * @param  {Integer} col a row
             * @return {Integer} a preferred height of the given row
             * @method getRowPSHeight
             */
            this.getRowPSHeight = function(row) {
                return this.getPSSize(row, true);
            };

            this.recalc = function(){
                if (this.isUsePsMetric) {
                    this.rPsMetric();
                } else {
                    this.rCustomMetric();
                }

                var cols = this.getGridCols(),
                    rows = this.getGridRows();

                this.psWidth_  = this.lineSize * (cols + ((this.leftCaption === null || this.leftCaption.isVisible === false) ? 1 : 0));
                this.psHeight_ = this.lineSize * (rows + ((this.topCaption === null || this.topCaption.isVisible === false) ? 1 : 0));

                var i = 0;
                for (;i &lt; cols; i++) {
                    this.psWidth_  += this.colWidths[i];
                }

                for (i = 0;i &lt; rows; i++) {
                    this.psHeight_ += this.rowHeights[i];
                }
            };

            /**
             * Get number of rows in the given grid
             * @return {Integer} a number of rows
             * @method getGridRows
             */
            this.getGridRows = function() {
                return this.model !== null ? this.model.rows : 0;
            };

            /**
             * Get number of columns in the given grid
             * @return {Integer} a number of columns
             * @method getGridColumns
             */
            this.getGridCols = function(){
                return this.model !== null ? this.model.cols : 0;
            };

            /**
             * Get the  given grid row height
             * @param  {Integer} row a grid row
             * @return {Integer} a height of the given row
             * @method getRowHeight
             */
            this.getRowHeight = function(row){
                this.validateMetric();
                return this.rowHeights[row];
            };

            /**
             * Get the given grid column width
             * @param  {Integer} col a grid column
             * @return {Integer} a width of the given column
             * @method getColWidth
             */
            this.getColWidth = function(col){
                this.validateMetric();
                return this.colWidths[col];
            };

            this.getCellsVisibility = function(){
                this.validateMetric();
                return this.visibility;
            };

            /**
             * Get the given column top-left corner x coordinate
             * @param  {Integer} col a column
             * @return {Integer} a top-left corner x coordinate of the given column
             * @method getColX
             */
            this.getColX = function (col){
                // speed up a little bit by avoiding calling validateMetric method
                if (this.isValid === false) {
                    this.validateMetric();
                }

                var start = 0,
                    d     = 1,
                    x     = this.getLeft() +
                            (this.leftCaption === null || this.leftCaption.isVisible === false ? this.lineSize : 0) +
                            this.getLeftCaptionWidth();

                if (this.visibility.hasVisibleCells()) {
                    start = this.visibility.fc[0];
                    x     = this.visibility.fc[1];
                    d     = (col &gt; this.visibility.fc[0]) ? 1 : -1;
                }

                for(var i = start;i !== col; x += ((this.colWidths[i] + this.lineSize) * d),i += d) {}
                return x;
            };

            /**
             * Get the given row top-left corner y coordinate
             * @param  {Integer} row a row
             * @return {Integer} a top-left corner y coordinate
             * of the given column
             * @method getColX
             */
            this.getRowY = function (row){
                // speed up a little bit by avoiding calling validateMetric method
                if (this.isValid === false) {
                    this.validateMetric();
                }

                var start = 0,
                    d     = 1,
                    y     = this.getTop() +
                            (this.topCaption === null || this.topCaption.isVisible === false ? this.lineSize : 0) +
                            this.getTopCaptionHeight();

                if (this.visibility.hasVisibleCells()){
                    start = this.visibility.fr[0];
                    y     = this.visibility.fr[1];
                    d     = (row &gt; this.visibility.fr[0]) ? 1 : -1;
                }

                for(var i = start;i !== row; y += ((this.rowHeights[i] + this.lineSize) * d),i += d) {}
                return y;
            };

            this.childPointerEntered  =
            this.childPointerExited   =
            this.childPointerReleased =
            this.childPointerReleased =
            this.childPointerPressed  =
            this.childKeyReleased     =
            this.childKeyTyped        =
            this.childKeyPressed      = function(e){
                if (this.editingRow &gt;= 0) {
                    if (this.editors.shouldCancel(this,
                                                  this.editingRow,
                                                  this.editingCol, e))
                    {
                        this.stopEditing(false);
                    } else {
                        if (this.editors.shouldFinish(this,
                                                      this.editingRow,
                                                      this.editingCol, e))
                        {
                            this.stopEditing(true);
                        }
                    }
                }
            };

            this.iColVisibility = function(off) {
                this.colOffset = (this.colOffset === 100) ? this.colOffset = off
                                                          : ((off !== this.colOffset) ? 0 : this.colOffset);
            };

            this.iRowVisibility = function(off) {
                this.rowOffset = (this.rowOffset === 100) ? off
                                                          : (((off + this.rowOffset) === 0) ? 0 : this.rowOffset);
            };

            /**
             * Get top grid caption height. Return zero if no top caption element has been defined
             * @return {Integer} a top caption height
             * @protected
             * @method  getTopCaptionHeight
             */
            this.getTopCaptionHeight = function(){
                return (this.topCaption !== null &amp;&amp; this.topCaption.isVisible === true) ? this.topCaption.height : 0;
            };

            /**
             * Get left grid caption width. Return zero if no left caption element has been defined
             * @return {Integer} a left caption width
             * @protected
             * @method  getLeftCaptionWidth
             */
            this.getLeftCaptionWidth = function(){
                return (this.leftCaption !== null &amp;&amp; this.leftCaption.isVisible === true) ? this.leftCaption.width : 0;
            };

            this.paint = function(g){
                this.vVisibility();

                if (this.visibility.hasVisibleCells()) {
                    var dx = this.scrollManager.getSX(),
                        dy = this.scrollManager.getSY(),
                        th = this.getTopCaptionHeight(),
                        tw = this.getLeftCaptionWidth();

                    try {
                        g.save();
                        g.translate(dx, dy);

                        if (th &gt; 0 || tw &gt; 0) {
                            g.clipRect(tw - dx, th - dy, this.width  - tw, this.height - th);
                        }

                        if (this.paintPosMarkerOver !== true) {
                            this.paintPosMarker(g);
                        }

                        this.paintData(g);
                        if (this.paintNetOnCaption !== true &amp;&amp; (this.drawHorLines === true || this.drawVerLines === true)) {
                            this.paintNet(g);
                        }

                        if (this.paintPosMarkerOver === true) {
                            this.paintPosMarker(g);
                        }

                        g.restore();
                    } catch(e) {
                        g.restore();
                        throw e;
                    }
                }
            };

            this.paintOnTop = function(g) {
                if (this.paintNetOnCaption === true &amp;&amp; (this.drawHorLines === true || this.drawVerLines === true)) {
                    this.paintNet(g);
                }
            };

            this.catchScrolled = function (psx, psy){
                var offx = this.scrollManager.getSX() - psx,
                    offy = this.scrollManager.getSY() - psy;

                if (offx !== 0) {
                    this.iColVisibility(offx &gt; 0 ? 1 :  - 1);
                }

                if (offy !== 0) {
                    this.iRowVisibility(offy &gt; 0 ? 1 :  - 1);
                }

                this.stopEditing(false);
                this.repaint();
            };

            //TODO: zebkit doesn&#x27;t support yet the method
            this.isInvalidatedByChild = function (c){
                return c !== this.editor || this.isUsePsMetric;
            };

            /**
             * Stop editing a grid cell.
             * @param  {Boolean} applyData true if the edited data has to be applied as a new
             * grid cell content
             * @protected
             * @method stopEditing
             */
            this.stopEditing = function(applyData){
                if (this.editors !== null &amp;&amp;
                    this.editingRow &gt;= 0  &amp;&amp;
                    this.editingCol &gt;= 0    )
                {
                    try {
                        if (zebkit.instanceOf(this.editor, pkg.Grid)) {
                            this.editor.stopEditing(applyData);
                        }

                        var data = this.getDataToEdit(this.editingRow, this.editingCol);
                        if (applyData){
                            this.setEditedData(this.editingRow,
                                               this.editingCol,
                                               this.editors.fetchEditedValue( this,
                                                                              this.editingRow,
                                                                              this.editingCol,
                                                                              data, this.editor));
                        }
                        this.repaintRows(this.editingRow, this.editingRow);
                    } finally {
                        this.editingCol = this.editingRow = -1;
                        if (this.indexOf(this.editor) &gt;= 0) {
                            this.remove(this.editor);
                        }
                        this.editor = null;
                        this.requestFocus();
                    }
                }
            };

            /**
             * Set if horizontal and vertical lines have to be painted
             * @param {Boolean} hor true if horizontal lines have to be painted
             * @param {Boolean} ver true if vertical lines have to be painted
             * @method setDrawLines
             * @chainable
             */
            this.setDrawLines = function(hor, ver){
                if (this.drawVerLines !== hor || this.drawHorLines !== ver) {
                    this.drawHorLines = hor;
                    this.drawVerLines = ver;
                    this.repaint();
                }
                return this;
            };

            /**
             * Set navigation mode. It is possible to use &quot;row&quot; or &quot;cell&quot; navigation mode.
             * In first case navigation happens over row, in the second
             * case navigation happens over cell.
             * @param {String} mode a navigation mode (&quot;row&quot; or &quot;cell&quot;)
             * @method setNavigationMode
             * @chainable
             */
            this.setNavigationMode = function(mode) {
                if (mode.toLowerCase() === &quot;row&quot;) {
                    this.navigationMode = &quot;row&quot;;

                    this.getLineSize = function(row) {
                        return 1;
                    };

                    this.getMaxOffset = function() {
                        return this.getGridRows() - 1;
                    };
                } else {
                    this.navigationMode = &quot;cell&quot;;

                    if (mode.toLowerCase() === &quot;cell&quot;) {
                        this.getLineSize = function(row) {
                            return this.getGridCols();
                        };

                        this.getMaxOffset = function() {
                            return this.getGridRows() * this.getGridCols() - 1;
                        };
                    } else {
                        throw new Error(&quot;Unsupported position marker mode&quot;);
                    }
                }
                return this;
            };

            this.getLines = function() {
                return this.getGridRows();
            };

            this.getLineSize = function(line) {
                return 1;
            };

            this.getMaxOffset = function() {
                return this.getGridRows() - 1;
            };

            this.posChanged = function(target, prevOffset, prevLine, prevCol) {
                var row = this.position.currentLine;
                if (row &gt;= 0) {
                    this.makeVisible(row, this.position.currentCol);
                    this.select(row, true);
                    this.repaintRows(prevLine, row);
                } else {
                    this.repaintRows(prevLine, prevLine);
                }
            };

            this.keyReleased = function(e) {
                if (this.position !== null) {
                    this.$se(this.position.currentLine,
                             this.position.currentCol, e);
                }
            };

            this.keyTyped = function(e){
                if (this.position !== null) {
                    this.$se(this.position.currentLine, this.position.currentCol, e);
                }
            };

            this.keyPressed = function(e){
                if (this.position !== null) {
                    switch(e.code) {
                        case &quot;ArrowLeft&quot;   : this.position.seek(-1); break;
                        case &quot;ArrowUp&quot;     : this.position.seekLineTo(&quot;up&quot;); break;
                        case &quot;ArrowRight&quot;  : this.position.seek(1); break;
                        case &quot;ArrowDown&quot;   : this.position.seekLineTo(&quot;down&quot;);break;
                        case &quot;PageUp&quot;      : this.position.seekLineTo(&quot;up&quot;, this.pageSize(-1));break;
                        case &quot;PageDown&quot;    : this.position.seekLineTo(&quot;down&quot;, this.pageSize(1));break;
                        case &quot;End&quot;         :
                            if (e.ctrlKey) {
                                this.position.setOffset(this.getLines() - 1);
                            } break;
                        case &quot;Home&quot;        :
                            if (e.ctrlKey) {
                                this.position.setOffset(0);
                            } break;
                    }

                    this.$se(this.position.currentLine, this.position.currentCol, e);
                }
            };

            /**
             * Checks if the given grid cell is selected
             * @param  {Integer}  row a grid row
             * @param  {Integer}  col a grid col
             * @return {Boolean}  true if the given row is selected
             * @method isSelected
             */
            this.isSelected = function(row, col) {
                return row === this.selectedIndex;
            };

            /**
             * Repaint range of grid rows
             * @param  {Integer} r1 the first row to be repainted
             * @param  {Integer} r2 the last row to be repainted
             * @method repaintRows
             * @chainable
             */
            this.repaintRows = function (r1,r2){
                if (r1 &lt; 0) {
                    r1 = r2;
                }

                if (r2 &lt; 0) {
                    r2 = r1;
                }

                if (r1 &gt; r2) {
                    var i = r2;
                    r2 = r1;
                    r1 = i;
                }

                var rows = this.getGridRows();
                if (r1 &lt; rows) {
                    if (r2 &gt;= rows) {
                        r2 = rows - 1;
                    }

                    var y1 = this.getRowY(r1),
                        y2 = ((r1 === r2) ? y1 + 1 : this.getRowY(r2)) + this.rowHeights[r2];

                    this.repaint(0, y1 + this.scrollManager.getSY(), this.width, y2 - y1);
                }

                return this;
            };

            /**
             * Detect a cell by the given location
             * @param  {Integer} x a x coordinate relatively the grid component
             * @param  {Integer} y a y coordinate relatively the grid component
             * @return {Object} an object that contains detected grid cell row as
             * &quot;row&quot; field and a grid column as &quot;col&quot; field. null is returned if
             * no cell can be detected.
             * @method cellByLocation
             */
            this.cellByLocation = function(x,y){
                this.validate();

                var dx  = this.scrollManager.getSX(),
                    dy  = this.scrollManager.getSY(),
                    v   = this.visibility,
                    ry1 = v.fr[1] + dy,
                    rx1 = v.fc[1] + dx,
                    row = -1,
                    col = -1,
                    i   = 0,
                    ry2 = v.lr[1] + this.rowHeights[v.lr[0]] + dy,
                    rx2 = v.lc[1] + this.colWidths[v.lc[0]] + dx;

                if (y &gt; ry1 &amp;&amp; y &lt; ry2) {
                    for(i = v.fr[0];i &lt;= v.lr[0]; ry1 += this.rowHeights[i] + this.lineSize, i++) {
                        if (y &gt; ry1 &amp;&amp; y &lt; ry1 + this.rowHeights[i]) {
                            row = i;
                            break;
                        }
                    }
                }
                if (x &gt; rx1 &amp;&amp; x &lt; rx2) {
                    for (i = v.fc[0];i &lt;= v.lc[0]; rx1 += this.colWidths[i] + this.lineSize, i++ ) {
                        if (x &gt; rx1 &amp;&amp; x &lt; rx1 + this.colWidths[i]) {
                            col = i;
                            break;
                        }
                    }
                }
                return (col &gt;= 0 &amp;&amp; row &gt;= 0) ? { row:row, col:col } : null;
            };

            this.doLayout = function(target) {
                var topHeight = (this.topCaption !== null &amp;&amp;
                                 this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0,
                    leftWidth = (this.leftCaption !== null &amp;&amp;
                                 this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width : 0;

                if (this.topCaption !== null){
                    this.topCaption.setBounds(this.getLeft() + leftWidth, this.getTop(),
                                              Math.min(target.width - this.getLeft() - this.getRight() - leftWidth,
                                                       this.psWidth_),
                                              topHeight);
                }

                if (this.leftCaption !== null){
                    this.leftCaption.setBounds(this.getLeft(),
                                               this.getTop() + topHeight,
                                               leftWidth,
                                               Math.min(target.height - this.getTop() - this.getBottom() - topHeight,
                                                        this.psHeight_));
                }

                if (this.stub !== null &amp;&amp; this.stub.isVisible === true)
                {
                    if (this.topCaption  !== null &amp;&amp; this.topCaption.isVisible === true &amp;&amp;
                        this.leftCaption !== null &amp;&amp; this.leftCaption.isVisible === true  )
                    {
                        this.stub.setBounds(this.getLeft(), this.getTop(),
                                            this.topCaption.x - this.stub.x,
                                            this.leftCaption.y - this.stub.y);
                    } else {
                        this.stub.setSize(0, 0);
                    }
                }

                if (this.editors !== null &amp;&amp;
                    this.editor  !== null &amp;&amp;
                    this.editor.parent === this &amp;&amp;
                    this.editor.isVisible === true)
                {
                    var w = this.colWidths[this.editingCol],
                        h = this.rowHeights[this.editingRow],
                        x = this.getColX(this.editingCol),
                        y = this.getRowY(this.editingRow);

                    if (this.isUsePsMetric){
                        x += this.cellInsetsLeft;
                        y += this.cellInsetsTop;
                        w -= (this.cellInsetsLeft + this.cellInsetsRight);
                        h -= (this.cellInsetsTop + this.cellInsetsBottom);
                    }

                    this.editor.setBounds(x + this.scrollManager.getSX(),
                                          y + this.scrollManager.getSY(), w, h);
                }
            };

            this.canHaveFocus = function (){
                return this.editor === null;
            };

            /**
             * Clear grid row or rows selection
             * @method clearSelect
             * @chainable
             */
            this.clearSelect = function (){
                if (this.selectedIndex &gt;= 0) {
                    var prev = this.selectedIndex;
                    this.selectedIndex = -1;
                    this._.rowSelected(this, -1, 0, false);
                    this.repaintRows(-1, prev);
                }
                return this;
            };

            /**
             * Mark as selected or unselected the given grid cell
             * @param  {Integer} row a grid row
             * @param  {Integer} col a grid row,
             * @param  {boolean} [b] a selection status. true if the parameter
             * has not been specified
             * @method select
             * @chainable
             */
            this.select = function (row, b){
                if (arguments.length &lt; 2) {
                    b = true;
                }

                if (this.isSelected(row) !== b){
                    if (this.selectedIndex &gt;= 0) {
                        this.clearSelect();
                    }

                    if (b) {
                        this.selectedIndex = row;
                        this._.rowSelected(this, row, 1, b);
                    }
                }

                return this;
            };

            this.laidout = function () {
                this.vVisibility();
            };

            this.pointerClicked = function(e) {
                if (e.isAction() &amp;&amp; this.visibility.hasVisibleCells()){
                    this.stopEditing(true);

                    if (e.isAction()){
                        var p = this.cellByLocation(e.x, e.y);
                        if (p !== null) {
                            if (this.position !== null){
                                var row = this.position.currentLine,
                                    col = this.position.currentCol,
                                    ls  = this.getLineSize(p.row);

                                // normalize column depending on marker mode: row or cell
                                // in row mode marker can select only the whole row, so
                                // column can be only 1  (this.getLineSize returns 1)
                                if (row === p.row &amp;&amp; col === p.col % ls) {
                                    this.makeVisible(row, col);
                                } else {
                                    this.clearSelect();
                                    this.position.setRowCol(p.row, p.col % ls);
                                }
                            }

                            if (this.$se(p.row, p.col, e)) {
                                // TODO: initiated editor has get pointer clicked event
                            }
                        }
                    }
                }
            };

            this.calcPreferredSize = function(target) {
                return {
                    width : this.psWidth_  +
                           ((this.leftCaption !== null  &amp;&amp;
                             this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width : 0),
                    height: this.psHeight_ +
                           ((this.topCaption !== null  &amp;&amp;
                             this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0)
                };
            };

            /**
             * Paint vertical and horizontal grid component lines
             * @param  {CanvasRenderingContext2D} g a HTML5 canvas 2D context
             * @method paintNet
             * @protected
             */
            this.paintNet = function(g) {
                var v    = this.visibility,
                    i    = 0,
                    topX = v.fc[1] - this.lineSize,
                    topY = v.fr[1] - this.lineSize,
                    botX = v.lc[1] + this.colWidths[v.lc[0]],
                    botY = v.lr[1] + this.rowHeights[v.lr[0]],
                    prevWidth = g.lineWidth;

                g.setColor(this.lineColor);
                g.lineWidth = this.lineSize;
                g.beginPath();

                if (this.drawHorLines === true) {
                    i = v.fr[0];

                    var y  = topY + this.lineSize/2,
                        tx = (this.paintNetOnCaption === true) ? this.getLeft() : topX;

                    for(;i &lt;= v.lr[0]; i++){
                        g.moveTo(tx, y);
                        g.lineTo(botX, y);
                        y += this.rowHeights[i] + this.lineSize;
                    }
                    g.moveTo(tx, y);
                    g.lineTo(botX, y);
                }

                if (this.drawVerLines === true) {
                    i = v.fc[0];

                    if (this.drawSideLines !== true &amp;&amp; v.fc[0] === 0) {
                        i++;
                        topX = v.fc[1] + this.colWidths[0];
                    }

                    var x    = topX + this.lineSize/2,
                        cols = this.getGridCols() - 1,
                        ty   = (this.paintNetOnCaption === true) ? this.getTop() : topY;

                    for(;i &lt;= v.lc[0] &amp;&amp;  (this.drawSideLines === true || i &lt; cols); i++){
                        g.moveTo(x , ty);
                        g.lineTo(x, botY);
                        x += this.colWidths[i] + this.lineSize;
                    }
                    g.moveTo(x, ty);
                    g.lineTo(x, botY);
                }
                g.stroke();
                g.lineWidth = prevWidth;
            };

            /**
             * Paint grid data
             * @param  {CanvasRenderingContext2D} g a HTML5 canvas 2d context
             * @method paintData
             * @protected
             */
            this.paintData = function(g) {
                var y    = this.visibility.fr[1] + this.cellInsetsTop,
                    addW = this.cellInsetsLeft   + this.cellInsetsRight,
                    addH = this.cellInsetsTop    + this.cellInsetsBottom,
                    ts   = g.$states[g.$curState],
                    cx   = ts.x,
                    cy   = ts.y,
                    cw   = ts.width,
                    ch   = ts.height,
                    res  = {};

                for(var i = this.visibility.fr[0];i &lt;= this.visibility.lr[0] &amp;&amp; y &lt; cy + ch; i++){
                    if (y + this.rowHeights[i] &gt; cy) {
                        var x = this.visibility.fc[1] + this.cellInsetsLeft;

                        for(var j = this.visibility.fc[0];j &lt;= this.visibility.lc[0]; j++) {
                            if (this.isSelected(i, j) === true) {
                                this.paintCellSelection(g, i, j, x - this.cellInsetsLeft, y - this.cellInsetsTop);
                            } else {
                                var bg = typeof this.provider.getCellColor !== &#x27;undefined&#x27; ? this.provider.getCellColor(this, i, j)
                                                                                           : this.defCellColor;
                                if (bg !== null) {
                                    if (typeof bg.paint !== &#x27;undefined&#x27;) {
                                        bg.paint(g, x - this.cellInsetsLeft,
                                                    y - this.cellInsetsTop,
                                                    this.colWidths[j], this.rowHeights[i], this);
                                    } else {
                                        g.setColor(bg);
                                        g.fillRect(x - this.cellInsetsLeft,
                                                   y - this.cellInsetsTop,
                                                   this.colWidths[j], this.rowHeights[i]);
                                    }
                                }
                            }

                            var v = (i === this.editingRow &amp;&amp;
                                     j === this.editingCol   ) ? null
                                                               : this.provider.getView(this, i, j,
                                                                                       this.model.get(i, j));
                            if (v !== null) {
                                var w = this.colWidths[j]  - addW,
                                    h = this.rowHeights[i] - addH;

                                res.x = x &gt; cx ? x : cx;
                                res.width = Math.min(x + w, cx + cw) - res.x;
                                res.y = y &gt; cy ? y : cy;
                                res.height = Math.min(y + h, cy + ch) - res.y;

                                if (res.width &gt; 0 &amp;&amp; res.height &gt; 0) {
                                    // TODO: most likely the commented section should be removed
                                    // if (this.isUsePsMetric !== true) {
                                    //     v.paint(g, x, y, w, h, this);
                                    // }
                                    //else {
                                        var ax = typeof this.provider.getXAlignment !== &#x27;undefined&#x27; ? this.provider.getXAlignment(this, i, j)
                                                                                                    : this.defXAlignment,
                                            ay = typeof this.provider.getYAlignment !== &#x27;undefined&#x27; ? this.provider.getYAlignment(this, i, j)
                                                                                                    : this.defYAlignment,
                                            vw = w, // cell width
                                            vh = h, // cell height
                                            xx = x,
                                            yy = y,
                                            id = -1,
                                            ps = (ax !== null || ay !== null) ? v.getPreferredSize(vw, vh)
                                                                              : null;

                                        if (ax !== null) {
                                            xx = x + ((ax === &quot;center&quot;) ? Math.floor((w - ps.width) / 2)
                                                                        : ((ax === &quot;right&quot;) ? w - ps.width : 0));
                                            vw = ps.width;
                                        }

                                        if (ay !== null) {
                                            yy = y + ((ay === &quot;center&quot;) ? Math.floor((h - ps.height) / 2)
                                                                        : ((ay === &quot;bottom&quot;) ? h - ps.height : 0));
                                            vh = ps.height;
                                        }

                                        if (xx &lt; res.x || yy &lt; res.y || (xx + vw) &gt; (x + w) || (yy + vh) &gt; (y + h)) {
                                            id = g.save();
                                            g.clipRect(res.x, res.y, res.width, res.height);
                                        }

                                        v.paint(g, xx, yy, vw, vh, this);
                                        if (id &gt;= 0) {
                                           g.restore();
                                        }
                                   // }
                                }
                            }
                            x += (this.colWidths[j] + this.lineSize);
                        }
                    }
                    y += (this.rowHeights[i] + this.lineSize);
                }
            };

            /**
             * Get position marker view taking in account focus state.
             * @return {zebkit.draw.View} a position marker view
             * @private
             * @method  $getPosMarker
             */
            this.$getPosMarker = function() {
                return this.hasFocus() ? (typeof this.views.marker === &#x27;undefined&#x27; ? null : this.views.marker)
                                       : (typeof this.views.offmarker === &#x27;undefined&#x27; ? null : this.views.offmarker);
            };

            /**
             * Paint position marker.
             * @param  {CanvasRenderingContext2D} g a graphical 2D context
             * @protected
             * @method paintPosMarker
             */
            this.paintPosMarker = function(g) {
                if (this.position       !== null &amp;&amp;
                    this.position.offset &gt;= 0       )
                {
                    var view       = this.$getPosMarker(),
                        row        = this.position.currentLine,
                        col        = this.position.currentCol,
                        rowPosMode = this.navigationMode === &quot;row&quot;,
                        v          = this.visibility;

                    // depending on position changing mode (cell or row) analyze
                    // whether the current position is in visible area
                    if (view !== null &amp;&amp; row &gt;= v.fr[0] &amp;&amp; row &lt;= v.lr[0] &amp;&amp;
                        (rowPosMode === true || (col &gt;= v.fc[0] &amp;&amp; col &lt;= v.lc[0])))
                    {
                        // TODO: remove the clip, think it is redundant code
                        // g.clipRect(this.getLeftCaptionWidth() - this.scrollManager.getSX(),
                        //            this.getTopCaptionHeight() - this.scrollManager.getSY(),
                        //            this.width, this.height);

                        // detect if grid marker position works in row selection mode
                        if (rowPosMode === true) {
                            // row selection mode
                            view.paint(g,   v.fc[1],
                                            this.getRowY(row),
                                            v.lc[1] - v.fc[1] + this.colWidths[v.lc[0]],
                                            this.rowHeights[row], this);
                        } else {
                            // cell selection mode
                            view.paint(g,   this.getColX(col),
                                            this.getRowY(row),
                                            this.colWidths[col],
                                            this.rowHeights[row], this);
                        }
                    }
                }
            };

            /**
             * Paint a selection for the given grid cell
             * @param  {CanvasRenderingContext2D} g a graphical 2D context
             * @param  {Integer} row a cell row.
             * @param  {Integer} col a cell column.
             * @param  {Integer} x a cell x location.
             * @param  {Integer} y a cell y location.
             * @protected
             * @method paintCellSelection
             */
            this.paintCellSelection = function(g, row, col, x, y) {
                if (this.editingRow &lt; 0) {
                    var v = ui.focusManager.focusOwner === this ? this.views.focusOnSelect
                                                                : this.views.focusOffSelect;
                    if (v !== null &amp;&amp; typeof v !== &#x27;undefined&#x27;)  {
                        v.paint(g, x, y, this.colWidths[col], this.rowHeights[row], this);
                    }
                }
            };

            this.rPsMetric = function(){
                var cols  = this.getGridCols(),
                    rows  = this.getGridRows(),
                    addW  = this.cellInsetsLeft + this.cellInsetsRight,
                    addH  = this.cellInsetsTop  + this.cellInsetsBottom,
                    capPS = null,
                    i     = 0;

                if (this.colWidths === null || this.colWidths.length !== cols) {
                    this.colWidths = Array(cols);
                    for (;i &lt; cols; i++) {
                        this.colWidths[i] = 0;
                    }
                } else {
                    for (;i &lt; cols; i++) {
                        this.colWidths[i] = 0;
                    }
                }

                if (this.rowHeights === null || this.rowHeights.length !== rows) {
                    this.rowHeights = Array(rows);
                    for (i = 0; i &lt; rows; i++) {
                        this.rowHeights[i] = 0;
                    }
                } else {
                    for (i = 0;i &lt; rows; i++) {
                        this.rowHeights[i] = 0;
                    }
                }

                for(i = 0; i &lt; cols; i++ ){
                    for(var j = 0; j &lt; rows; j++ ){
                        var v = this.provider.getView(this, j, i, this.model.get(j, i));
                        if (v !== null){
                            var ps = v.getPreferredSize();
                            ps.width  += addW;
                            ps.height += addH;
                            if (ps.width  &gt; this.colWidths[i] ) {
                                this.colWidths [i] = ps.width;
                            }

                            if (ps.height &gt; this.rowHeights[j]) {
                                this.rowHeights[j] = ps.height;
                            }
                        } else {
                            if (pkg.Grid.DEF_COLWIDTH &gt; this.colWidths [i]) {
                                this.colWidths [i] = pkg.Grid.DEF_COLWIDTH;
                            }

                            if (pkg.Grid.DEF_ROWHEIGHT &gt; this.rowHeights[j]) {
                                this.rowHeights[j] = pkg.Grid.DEF_ROWHEIGHT;
                            }
                        }
                    }
                }

                if (this.topCaption !== null &amp;&amp; this.topCaption.isVisible === true) {
                    for(i = 0;i &lt; cols; i++ ) {
                        capPS = this.topCaption.getCaptionPS(i);
                        if (capPS  &gt; this.colWidths[i]) {
                            this.colWidths[i] = capPS;
                        }
                    }
                }

                if (this.leftCaption !== null &amp;&amp; this.leftCaption.isVisible === true) {
                    for(i = 0;i &lt; rows; i++ ) {
                        capPS = this.leftCaption.getCaptionPS(i);
                        if (capPS  &gt; this.rowHeights[i]) {
                            this.rowHeights[i] = capPS;
                        }
                    }
                }
            };

            this.getPSSize = function (rowcol, b) {
                if (this.isUsePsMetric === true) {
                    return b ? this.getRowHeight(rowcol) : this.getColWidth(rowcol);
                } else {
                    var max = 0, count = b ? this.getGridCols() : this.getGridRows();
                    for(var j = 0;j &lt; count; j ++ ){
                        var r = b ? rowcol : j, c = b ? j : rowcol,
                            v = this.provider.getView(this, r, c, this.model.get(r, c));

                        if (v !== null){
                            var ps = v.getPreferredSize();
                            if (b) {
                                if (ps.height &gt; max) {
                                    max = ps.height;
                                }
                            } else {
                                if (ps.width &gt; max) {
                                    max = ps.width;
                                }
                            }
                        }
                    }
                    return max + this.lineSize * 2 +
                           (b ? this.cellInsetsTop + this.cellInsetsBottom
                              : this.cellInsetsLeft + this.cellInsetsRight);
                }
            };

            this.rCustomMetric = function(){
                var start = 0;
                if (this.colWidths !== null) {
                    start = this.colWidths.length;
                    if (this.colWidths.length !== this.getGridCols()) {
                        this.colWidths.length = this.getGridCols();
                    }
                } else {
                    this.colWidths = Array(this.getGridCols());
                }

                for(; start &lt; this.colWidths.length; start ++ ) {
                    this.colWidths[start] = pkg.Grid.DEF_COLWIDTH;
                }

                start = 0;
                if (this.rowHeights !== null) {
                    start = this.rowHeights.length;
                    if (this.rowHeights.length !== this.getGridRows()) {
                        this.rowHeights.length = this.getGridRows();
                    }
                } else {
                    this.rowHeights = Array(this.getGridRows());
                }

                for(; start &lt; this.rowHeights.length; start++) {
                    this.rowHeights[start] = pkg.Grid.DEF_ROWHEIGHT;
                }
            };

            /**
             * Calculate number of rows to be scrolled up or down to scroll one page
             * @param  {Integer} d a direction. 1 for scroll down and -1 for scroll up
             * @return {Integer}  a page size in rows to be scrolled up or down
             * @method pageSize
             * @protected
             */
            this.pageSize = function(d) {
                this.validate();
                if (this.visibility.hasVisibleCells() &amp;&amp; this.position !== null) {
                    var off = this.position.offset;
                    if (off &gt;= 0){
                        var hh  = this.visibleArea.height - this.getTopCaptionHeight(),
                            sum = 0,
                            poff = off;

                        for(; off &gt;= 0 &amp;&amp; off &lt; this.getGridRows() &amp;&amp; sum &lt; hh; sum += this.rowHeights[off] + this.lineSize,off += d) {}
                        return Math.abs(poff - off);
                    }
                }
                return 0;
            };

            /**
             * Set the given height for the specified grid row. The method has no effect
             * if the grid component is forced to use preferred size metric.
             * @param {Integer} row a grid row
             * @param {Integer} h   a height of the grid row
             * @method setRowHeight
             * @chainable
             */
            this.setRowHeight = function(row, h) {
                this.setRowsHeight(row, 1, h);
                return this;
            };

            /**
             * Set the given height for all or the specified range of rows
             * @param {Integer} [row] start row
             * @param {Integer} [len] number of rows whose height has to be set
             * @param {Integer} h  a height
             * @method setRowsHeight
             * @chainable
             */
            this.setRowsHeight = function(row, len, h) {
                if (this.isUsePsMetric === false){
                    if (arguments.length === 1) {
                        h   = arguments[0];
                        row = 0;
                        len = this.getGridRows();
                    }

                    if (len !== 0) {
                        this.validateMetric();
                        var b = false;
                        for(var i=row; i &lt; row + len; i++) {
                            if (this.rowHeights[i] !== h) {
                                this.psHeight_ += (h - this.rowHeights[i]);
                                this.rowHeights[i] = h;
                                b = true;
                            }
                        }

                        if (b === true) {
                            this.stopEditing(false);
                            this.cachedHeight = this.getTop() + this.getBottom() + this.psHeight_ +
                                                ((this.topCaption !== null &amp;&amp; this.topCaption.isVisible === true) ? this.topCaption.getPreferredSize().height : 0);

                            if (this.parent !== null) {
                                this.parent.invalidate();
                            }

                            this.iRowVisibility(0);
                            this.invalidateLayout();
                            this.repaint();
                        }
                    }

                    return this;
                }
            };

            /**
             * Set the given width for the specified grid column. The method has no effect
             * if the grid component is forced to use preferred size metric.
             * @param {Integer} column a grid column
             * @param {Integer} w   a width of the grid column
             * @method setColWidth
             * @chainable
             */
            this.setColWidth = function (col,w){
                this.setColsWidth(col, 1, w);
                return this;
            };

            /**
             * Set the given width for all or the specified range of columns
             * @param {Integer} [col] start column
             * @param {Integer} [len] number of columns whose height has to be set
             * @param {Integer} w  a width
             * @method setColsHeight
             * @chainable
             */
            this.setColsWidth = function(col, len, w){
                if (this.isUsePsMetric === false){
                    if (arguments.length === 1) {
                        w   = arguments[0];
                        col = 0;
                        len = this.getGridCols();
                    }

                    if (len !== 0)  {
                        this.validateMetric();
                        var b = false;
                        for(var i = col; i &lt; col + len; i++) {
                            if (this.colWidths[i] !== w){
                                this.psWidth_ += (w - this.colWidths[i]);
                                this.colWidths[i] = w;
                                b = true;
                            }
                        }

                        if (b === true) {
                            this.stopEditing(false);
                            this.cachedWidth = this.getRight() + this.getLeft() +
                                               this.psWidth_ + ((this.leftCaption !== null &amp;&amp;
                                                                 this.leftCaption.isVisible === true) ? this.leftCaption.getPreferredSize().width
                                                                                                      : 0);
                            if (this.parent !== null) {
                                this.parent.invalidate();
                            }
                            this.iColVisibility(0);
                            this.invalidateLayout();
                            this.repaint();
                        }
                    }

                    return this;
                }
            };

            this.matrixResized = function(target, prevRows, prevCols) {
                this.clearSelect();

                this.vrp();
                if (this.position !== null) {
                    this.position.setOffset(null);
                }

                for(var i = 0; i &lt; this.kids.length; i++) {
                    if (typeof this.kids[i].matrixResized !== &#x27;undefined&#x27;) {
                        this.kids[i].matrixResized(target,prevRows,prevCols);
                    }
                }
            };

            this.cellModified = function(target,row,col,prevValue) {
                if (this.isUsePsMetric){
                    this.invalidate();
                }

                for(var i=0; i &lt; this.kids.length; i++) {
                    if (typeof this.kids[i].cellModified !== &#x27;undefined&#x27;) {
                        this.kids[i].cellModified(target,row,col, prevValue);
                    }
                }
            };

            this.matrixSorted = function(target, info) {
                this.clearSelect();
                this.vrp();

                for(var i=0; i &lt; this.kids.length; i++) {
                    if (typeof this.kids[i].matrixSorted !== &#x27;undefined&#x27;) {
                        this.kids[i].matrixSorted(target, info);
                    }
                }
            };

            /**
             * Set the given editor provider. Editor provider is a way to customize
             * cell editing.
             * @param {Object} p an editor provider
             * @method setEditorProvider
             * @chainable
             */
            this.setEditorProvider = function(p){
                if (p !== this.editors){
                    this.stopEditing(true);
                    this.editors = p;
                }
                return this;
            };

            /**
             * Force to size grid columns and rows according to its preferred size
             * @param {Boolean} b use true to use preferred size
             * @method setUsePsMetric
             * @chainable
             */
            this.setUsePsMetric = function(b){
                if (this.isUsePsMetric !== b){
                    this.isUsePsMetric = b;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the position controller.
             * @param {zebkit.util.Position} p a position controller
             * @method setPosition
             * @chainable
             */
            this.setPosition = function(p){
                if (this.position !== p){
                    if (this.position !== null) {
                        this.position.off(this);
                    }

                    /**
                     * Virtual cursor position controller
                     * @readOnly
                     * @attribute position
                     * @type {zebkit.util.Position}
                     */
                    this.position = p;
                    if (this.position !== null) {
                        this.position.on(this);
                        this.position.setMetric(this);
                    }
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the given cell view provider. Provider is a special
             * class that says how grid cells content has to be rendered,
             * aligned, colored
             * @param {Object} p a view provider
             * @method setViewProvider
             * @chainable
             */
            this.setViewProvider = function(p){
                if (this.provider !== p){
                    this.provider = p;
                    this.vrp();
                }
                return this;
            };

            /**
             * Set the given matrix model to be visualized and controlled
             * with the grid component
             * @param {zebkit.data.Matrix|Array} d a model passed as an
             * instance of  matrix model or an array that contains
             * model rows as embedded arrays.
             * @method setModel
             * @chainable
             */
            this.setModel = function(d){
                if (d !== this.model) {
                    this.clearSelect();
                    if (Array.isArray(d)) {
                        d = new this.clazz.Matrix(d);
                    }

                    if (this.model !== null &amp;&amp; typeof this.model._ !== &#x27;undefined&#x27;) {
                        this.model.off(this);
                    }

                    this.model = d;
                    if (this.model !== null &amp;&amp; typeof this.model._ !== &#x27;undefined&#x27;) {
                        this.model.on(this);
                    }

                    if (this.position !== null) {
                        this.position.setOffset(null);
                    }

                    this.vrp();
                }

                return this;
            };

            /**
             * Set the given top, left, right, bottom cell paddings
             * @param {Integer} p a top, left, right and bottom cell paddings
             * @method setCellPadding
             * @chainable
             */
            this.setCellPadding = function (p){
                this.setCellPaddings(p,p,p,p);
                return this;
            };

            /**
             * Set the given top, left, right, bottom cell paddings
             * @param {Integer} t a top cell padding
             * @param {Integer} l a left cell padding
             * @param {Integer} b a bottom cell padding
             * @param {Integer} r a rightcell padding
             * @method setCellPaddings
             * @chainable
             */
            this.setCellPaddings = function (t,l,b,r){
                if (t !== this.cellInsetsTop    || l !== this.cellInsetsLeft ||
                    b !== this.cellInsetsBottom || r !== this.cellInsetsRight)
                {
                    this.cellInsetsTop = t;
                    this.cellInsetsLeft = l;
                    this.cellInsetsBottom = b;
                    this.cellInsetsRight = r;
                    this.vrp();
                }

                return this;
            };

            /**
             * Set the given color to render the grid vertical and horizontal lines
             * @param {String} c a color
             * @method setLineColor
             * @chainable
             */
            this.setLineColor = function (c){
                if (c !== this.lineColor){
                    this.lineColor = c;
                    if (this.drawVerLines || this.drawHorLines) {
                        this.repaint();
                    }
                }
                return this;
            };

            /**
             * Set the given grid lines size
             * @param {Integer} s a size
             * @method setLineSize
             * @chainable
             */
            this.setLineSize = function (s){
                if (s !== this.lineSize){
                    this.lineSize = s;
                    this.vrp();
                }
                return this;
            };

            /**
             * Start editing the given grid cell. Editing is initiated only if an editor
             * provider has been set and the editor provider defines not-null UI component
             * as an editor for the given cell.
             * @param  {Integer} row a grid cell row
             * @param  {Integer} col a grid cell column
             * @return {Boolean}  true if a cell editor has been initiated, otherwise
             * returns false.
             * @method startEditing
             */
            this.startEditing = function(row, col){
                this.stopEditing(true);
                if (this.editors !== null){
                    var editor = this.editors.getEditor(this, row, col,
                                                        this.getDataToEdit(row, col));

                    if (editor !== null){
                        this.editingRow = row;
                        this.editingCol = col;
                        if (editor.isPopupEditor === true) {
                            var p = zebkit.layout.toParentOrigin(this.getColX(col) + this.scrollManager.getSX(),
                                                                 this.getRowY(row) + this.scrollManager.getSY(),
                                                                 this);

                            editor.setLocation(p.x, p.y);
                            ui.makeFullyVisible(this.getCanvas(), editor);
                            this.editor = editor;

                            var $this = this;
                            this.editor.winOpened = function(e) {
                                if (e.isShown === false){
                                    $this.stopEditing(typeof e.source.isAccepted !== &#x27;undefined&#x27; ? e.source.isAccepted() : false);
                                }
                            };
                            ui.showModalWindow(this, editor, this);
                        } else {
                            this.add(&quot;editor&quot;, editor);
                            this.repaintRows(this.editingRow, this.editingRow);
                        }
                        ui.focusManager.requestFocus(editor);

                        return true;
                    }
                }
                return false;
            };

            /**
             * Fetch a data from matrix model that has to be edited
             * @param  {Integer} row a row
             * @param  {Integer} col a column
             * @return {Object} a matrix model data to be edited
             * @method getDataToEdit
             * @protected
             */
            this.getDataToEdit = function (row, col){
                return this.model.get(row, col);
            };

            /**
             * Apply the given edited data to grid matrix model
             * @param  {Integer} row a row
             * @param  {Integer} col a column
             * @param  {Object}  an edited matrix model data to be applied
             * @method setEditedData
             * @protected
             */
            this.setEditedData = function (row,col,value){
                this.model.put(row, col, value);
            };

            /**
             * Set the grid left caption titles
             * @param title* number of titles
             * @method setLeftCaption
             * @chainable
             */
            this.setLeftCaption = function() {
                if (this.leftCaption !== null) {
                    this.leftCaption.removeMe();
                }
                this.add(&quot;left&quot;, new pkg.GridCaption(Array.prototype.slice.call(arguments)));
                return this;
            };

            /**
             * Set the grid top caption titles
             * @param title* number of titles
             * @method setTopCaption
             * @chainable
             */
            this.setTopCaption = function() {
                if (this.topCaption !== null) {
                    this.topCaption.removeMe();
                }
                this.add(&quot;top&quot;, new pkg.GridCaption(Array.prototype.slice.call(arguments)));
                return this;
            };
        },

        function focused() {
            this.$super();
            this.repaint();
        },

        function invalidate(){
            this.$super();
            this.iColVisibility(0);
            this.iRowVisibility(0);
        },

        function kidAdded(index, ctr, c){
            this.$super(index, ctr, c);

            if ((ctr === null &amp;&amp; this.topCaption === null) || &quot;top&quot; === ctr){
                this.topCaption = c;
            } else {
                if (&quot;editor&quot; === ctr) {
                    this.editor = c;
                } else {
                    if ((ctr === null &amp;&amp; this.leftCaption === null) || &quot;left&quot; === ctr) {
                        this.leftCaption = c;
                    } else {
                        if ((ctr === null &amp;&amp; this.stub === null) || &quot;corner&quot; === ctr) {
                            this.stub = c;
                        }
                    }
                }
            }
        },

        function kidRemoved(index,c) {
            this.$super(index, c);
            if (c === this.editor) {
                this.editor = null;
            } else if (c === this.topCaption) {
                this.topCaption = null;
            } else if (c === this.leftCaption){
                this.leftCaption = null;
            } else if (c === this.stub) {
                this.stub = null;
            }
        }

        /**
         *  Set number of views to render different grid component elements
         *  @param {Object} a set of views as dictionary where key is a view
         *  name and the value is a view instance, string (for color, border),
         *  or render function. The following view elements can be passed:
         *
         *
         *      {
         *         &quot;focusOnSelect&quot; : &lt;view to render selected row for the grid that holds focus&gt;,
         *         &quot;focusOffSelect&quot;: &lt;view to render selected row for the grid that doesn&#x27;t hold focus&gt;
         *      }
         *
         *
         *  @method  setViews
         */
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Special UI panel that manages to stretch grid columns to occupy the whole panel space.
     *
     *     ...
     *
     *     var canvas = new zebkit.ui.zCanvas(),
     *         grid = new zebkit.ui.grid.Grid(100,10),
     *         pan  = new zebkit.ui.grid.GridStretchPan(grid);
     *
     *     canvas.root.setLayout(new zebkit.layout.BorderLayout());
     *     canvas.root.add(&quot;center&quot;, pan);
     *
     *     ...
     *
     * @constructor
     * @param {zebkit.ui.grid.Grid} grid a grid component that has to be added in the panel
     * @class zebkit.ui.grid.GridStretchPan
     * @extends zebkit.ui.Panel
     */
    pkg.GridStretchPan = Class(ui.Panel, [
        function (grid){
            this.$super(this);

            this.grid = grid;

            this.$widths = [];
            this.$prevWidth = 0;
            this.$propW = -1;
            this.add(grid);
        },

        function $prototype() {
            this.$props = this.$strPs = null;

            /**
             * Target grid component
             * @type {zebkit.ui.Grid}
             * @readOnly
             * @attribute grid
             */
            this.grid = null;

            this.calcPreferredSize = function(target) {
                this.recalcPS();
                return (target.kids.length === 0 ||
                        target.grid.isVisible === false) ? { width:0, height:0 }
                                                         : { width:this.$strPs.width,
                                                             height:this.$strPs.height };
            };

            this.doLayout = function(target){
                this.recalcPS();
                if (target.kids.length &gt; 0){
                    var grid = this.grid,
                        left = target.getLeft(),
                        top = target.getTop();

                    if (grid.isVisible === true) {
                        grid.setBounds(left, top,
                                       target.width  - left - target.getRight(),
                                       target.height - top  - target.getBottom());

                        for(var i = 0; i &lt; this.$widths.length; i++) {
                            grid.setColWidth(i, this.$widths[i]);
                        }
                    }
                }
            };

            this.captionResized = function(src, col, pw){
                if (col &lt; this.$widths.length - 1) {
                    var grid = this.grid,
                        w    = grid.getColWidth(col),
                        dt   = w - pw;

                    if (dt &lt; 0) {
                        grid.setColWidth(col + 1, grid.getColWidth(col + 1) - dt);
                    } else {
                        var ww = grid.getColWidth(col + 1) - dt,
                            mw = this.getMinWidth();

                        if (ww &lt; mw) {
                            grid.setColWidth(col, w - (mw - ww));
                            grid.setColWidth(col + 1, mw);
                        } else {
                            grid.setColWidth(col + 1, ww);
                        }
                    }

                    this.$propW = -1;
                }
            };

            this.getMinWidth = function () {
                return zebkit.instanceOf(this.grid.topCaption, pkg.BaseCaption) ? this.grid.topCaption.minSize
                                                                               : 10;
            };

            this.calcColWidths = function(targetAreaW){
                var grid = this.grid,
                    cols = grid.getGridCols(),
                    ew   = targetAreaW - (this.$props.length + 1) * grid.lineSize,
                    sw   = 0;

                if (this.$widths.length !== cols) {
                    this.$widths = Array(cols);
                }

                for(var i = 0; i &lt; cols; i++){
                    if (this.$props.length - 1 === i) {
                        this.$widths[i] = ew - sw;
                    } else {
                        this.$widths[i] = Math.round(ew * this.$props[i]);
                        sw += this.$widths[i];
                    }
                }
            };

            this.recalcPS = function (){
                var grid = this.grid;
                if (grid !== null &amp;&amp; grid.isVisible === true) {
                    // calculate size excluding padding where
                    // the target grid columns have to be stretched
                    var p        = this.parent,
                        isScr    = zebkit.instanceOf(p, ui.ScrollPan),
                        taWidth  = (isScr ? p.width - p.getLeft() - p.getRight() - this.getRight() - this.getLeft()
                                          : this.width - this.getRight() - this.getLeft()),
                        taHeight = (isScr ? p.height - p.getTop() - p.getBottom() - this.getBottom() - this.getTop()
                                          : this.height - this.getBottom() - this.getTop());

                    // exclude left caption
                    if (this.grid.leftCaption !== null &amp;&amp;
                        this.grid.leftCaption.isVisible === true)
                    {
                        taWidth -= this.grid.leftCaption.getPreferredSize().width;
                    }

                    if (this.$strPs === null || this.$prevWidth !== taWidth) {
                        var cols = grid.getGridCols();
                        if (this.$propW &lt; 0 || this.$props === null || this.$props.length !== cols) {
                            // calculate col proportions
                            if (this.$props === null || this.$props.length !== cols) {
                                this.$props = Array(cols);
                            }
                            this.$propW = 0;

                            var i = 0, w = 0;

                            for(i = 0; i &lt; cols; i++){
                                w = grid.getColWidth(i);
                                if (w === 0) {
                                    w = grid.getColPSWidth(i);
                                }
                                this.$propW += w;
                            }

                            for(i = 0; i &lt; cols; i++){
                                w = grid.getColWidth(i);
                                if (w === 0) {
                                    w = grid.getColPSWidth(i);
                                }
                                this.$props[i] = w / this.$propW;
                            }
                        }

                        this.$prevWidth  = taWidth;
                        this.calcColWidths(taWidth);
                        this.$strPs   = {
                            width : taWidth,
                            height: grid.getPreferredSize().height
                        };

                        // check if the calculated height is greater than
                        // height of the parent component and re-calculate
                        // the metrics if vertical scroll bar is required
                        // taking in account horizontal reduction because of
                        // the scroll bar visibility
                        if (isScr === true &amp;&amp;
                            p.height &gt; 0 &amp;&amp;
                            (typeof p.vBar !== &#x27;undefined&#x27; || p.vBar === null) &amp;&amp;
                            p.autoHide === false &amp;&amp;
                            taHeight &lt; this.$strPs.height)
                        {
                            taWidth -= p.vBar.getPreferredSize().width;
                            this.calcColWidths(taWidth);
                            this.$strPs.width = taWidth;
                        }
                    }
                }
            };
        },

        function kidAdded(index,constr,l){
            this.$propsW = -1;
            if (l.topCaption !== null) {
                l.topCaption.on(this);
            }
            this.scrollManager = l.scrollManager;
            this.$super(index, constr, l);
        },

        function kidRemoved(i,l){
            this.$propsW = -1;
            if (l.topCaption !== null) {
                l.topCaption.off(this);
            }
            this.scrollManager = null;
            this.$super(i, l);
        },

        function invalidate(){
            this.$strPs = null;
            this.$super();
        }
    ]);


    zebkit.ui.$configWith(pkg);
});
zebkit.package(&quot;ui.design&quot;, function(pkg, Class) {
    var ui = pkg.cd(&quot;..&quot;);

    /**
     * The package contains number of UI components that can be helpful to
     * perform visual control of an UI component. You can control an UI component
     * size and location.
     *
     *     var root = (new zebkit.ui.zCanvas(400, 300)).root;
     *     root.setLayout(new zebkit.layout.RasterLayout());
     *     root.setPadding(8);
     *
     *     // Add check box component wrapped with shaper panel
     *     // to control the component size and location
     *     var ch = new zebkit.ui.Checkbox(&quot;Check-box&quot;)
     *                           .setBounds(10, 10, 100, 30);
     *
     *     root.add(new zebkit.ui.design.ShaperPan(ch));
     *
     * @class  zebkit.ui.design
     * @access package
     */
    var CURSORS = {
        left        : ui.Cursor.W_RESIZE,
        right       : ui.Cursor.E_RESIZE,
        top         : ui.Cursor.N_RESIZE,
        bottom      : ui.Cursor.S_RESIZE,
        topLeft     : ui.Cursor.NW_RESIZE,
        topRight    : ui.Cursor.NE_RESIZE,
        bottomLeft  : ui.Cursor.SW_RESIZE,
        bottomRight : ui.Cursor.SE_RESIZE,
        center      : ui.Cursor.MOVE,
        none        : ui.Cursor.DEFAULT
    };

    /**
     * A designer border view. The border view visually indicates areas
     * of border with different size possibilities. The border logically
     * split area around a component to number of predefined areas such
     * as: &quot;center&quot;, &quot;bottom&quot;, &quot;right&quot;, &quot;left&quot;, &quot;topRight&quot;, &quot;topLeft&quot;,
     * &quot;bottomLeft&quot;, &quot;bottomRight&quot;, &quot;none&quot;. See illustration below:
     *
     *
     *      |topLeft|-----------| top |-------------|topRight|
     *          |                                        |
     *          |                                        |
     *      |  left |            center             |  right |
     *          |                                        |
     *          |                                        |
     *      |bottomLeft|-------|bottom|-------------|bottomRight|
     *
     *
     * @constructor
     * @class zebkit.ui.design.ShaperBorder
     * @extends zebkit.draw.View
     */
    pkg.ShaperBorder = Class(zebkit.draw.View, [
        function $prototype() {
            /**
             * Border color
             * @attribute color
             * @type {String}
             * @default &quot;blue&quot;
             */
            this.color = &quot;blue&quot;;

            /**
             * Border gap.
             * @attribute gap
             * @type {Number}
             * @default 7
             */
            this.gap = 7;

            function contains(x, y, gx, gy, ww, hh) {
                return gx &lt;= x &amp;&amp; (gx + ww) &gt; x &amp;&amp; gy &lt;= y &amp;&amp; (gy + hh) &gt; y;
            }

            this.paint = function(g,x,y,w,h,d){
                var cx = Math.floor((w - this.gap)/2),
                    cy = Math.floor((h - this.gap)/2);

                g.setColor(this.color);
                g.beginPath();
                g.rect(x, y, this.gap, this.gap);
                g.rect(x + cx, y, this.gap, this.gap);
                g.rect(x, y + cy, this.gap, this.gap);
                g.rect(x + w - this.gap, y, this.gap, this.gap);
                g.rect(x, y + h - this.gap, this.gap, this.gap);
                g.rect(x + cx, y + h - this.gap, this.gap, this.gap);
                g.rect(x + w - this.gap, y + cy, this.gap, this.gap);
                g.rect(x + w - this.gap, y + h - this.gap, this.gap, this.gap);
                g.fill();

                g.beginPath();

                // very strange thing with rect() method if it called with w or h
                // without decreasing with gap it is ok, otherwise moving   a
                // component with the border outside parent component area leaves
                // traces !
                //
                // adding 0.5 (to center line) solves the problem with traces
                g.rect(x + Math.floor(this.gap / 2) + 0.5,
                       y + Math.floor(this.gap / 2) + 0.5,
                       w - this.gap,
                       h - this.gap );

                g.stroke();
            };

            /**
             * Detect area type by the given location of the given component
             * @param  {zebkit.ui.Panel} target a target component
             * @param  {Integer} x a x coordinate
             * @param  {Integer} y an y coordinate
             * @return {String} a detected area type
             * @protected
             * @method detectAt
             */
            this.detectAt = function(target, x, y) {
                if (contains(x, y, this.gap, this.gap, target.width - 2 * this.gap, target.height - 2 * this.gap)) {
                    return &quot;center&quot;;
                }

                if (contains(x, y, 0, 0, this.gap, this.gap)) {
                    return &quot;topLeft&quot;;
                }

                if (contains(x, y, 0, target.height - this.gap, this.gap, this.gap)) {
                    return &quot;bottomLeft&quot;;
                }

                if (contains(x, y, target.width - this.gap, 0, this.gap, this.gap)) {
                    return &quot;topRight&quot;;
                }

                if (contains(x, y, target.width - this.gap, target.height - this.gap, this.gap, this.gap)) {
                    return &quot;bottomRight&quot;;
                }

                var mx = Math.floor((target.width - this.gap) / 2);
                if (contains(x, y, mx, 0, this.gap, this.gap)) {
                    return &quot;top&quot;;
                }

                if (contains(x, y, mx, target.height - this.gap, this.gap, this.gap)) {
                    return &quot;bottom&quot;;
                }

                var my = Math.floor((target.height - this.gap)/2);
                if (contains(x, y, 0, my, this.gap, this.gap)) {
                    return &quot;left&quot;;
                }

                return contains(x, y, target.width - this.gap, my, this.gap, this.gap) ? &quot;right&quot;
                                                                                       : &quot;none&quot;;
            };
        }
    ]);

    /**
     * This is UI component class that implements possibility to embeds another
     * UI components to control the component size and location visually.

            // create canvas
            var canvas = new zebkit.ui.zCanvas(300,300);

            // create two UI components
            var lab = new zebkit.ui.Label(&quot;Label&quot;);
            var but = new zebkit.ui.Button(&quot;Button&quot;);

            // add created before label component as target of the shaper
            // component and than add the shaper component into root panel
            canvas.root.add(new zebkit.ui.design.ShaperPan(lab).properties({
                bounds: [ 30,30,100,40]
            }));

            // add created before button component as target of the shaper
            // component and than add the shaper component into root panel
            canvas.root.add(new zebkit.ui.design.ShaperPan(but).properties({
                bounds: [ 130,130,100,50]
            }));

     * @class  zebkit.ui.design.ShaperPan
     * @constructor
     * @extends zebkit.ui.Panel
     * @param {zebkit.ui.Panel} target a target UI component whose size and location
     * has to be controlled
     */
    pkg.ShaperPan = Class(ui.Panel, [
        function(t) {
            this.shaperBr = new pkg.ShaperBorder();
            this.$super(new zebkit.layout.BorderLayout());
            this.px = this.py = 0;
            this.setBorder(this.shaperBr);
            if (arguments.length &gt; 0) {
                this.add(t);
            }
        },

        function $clazz() {
            this.colors = [ &quot;lightGray&quot;, &quot;blue&quot; ];
        },

        function $prototype() {
            this.colors = null;

           /**
            * Indicates if controlled component can be moved
            * @attribute isMoveEnabled
            * @type {Boolean}
            * @default true
            */

           /**
            * Indicates if controlled component can be sized
            * @attribute isResizeEnabled
            * @type {Boolean}
            * @default true
            */

            /**
             * Minimal possible height or controlled component
             * @attribute minHeight
             * @type {Integer}
             * @default 12
             */

            /**
             * Minimal possible width or controlled component
             * @attribute minWidth
             * @type {Integer}
             * @default 12
             */
            this.minHeight = this.minWidth = 12;
            this.canHaveFocus = this.isResizeEnabled = this.isMoveEnabled = true;
            this.$state = null;

            this.catchInput = true;

            this.getCursorType = function (t, x ,y) {
                return this.kids.length &gt; 0 ? CURSORS[this.shaperBr.detectAt(t, x, y)]
                                            : null;
            };

            /**
             * Define key pressed events handler
             * @param  {zebkit.ui.event.KeyEvent} e a key event
             * @method keyPressed
             */
            this.keyPressed = function(e) {
                if (this.kids.length &gt; 0){
                    var dx = (e.code === &quot;ArrowLeft&quot; ? -1 : (e.code === &quot;ArrowRight&quot; ? 1 : 0)),
                        dy = (e.code === &quot;ArrowUp&quot;   ? -1 : (e.code === &quot;ArrowDown&quot;  ? 1 : 0)),
                        w  = this.width  + dx,
                        h  = this.height + dy,
                        x  = this.x + dx,
                        y  = this.y + dy;

                    if (e.shiftKey) {
                        if (this.isResizeEnabled === true &amp;&amp; w &gt; this.shaperBr.gap * 2 &amp;&amp; h &gt; this.shaperBr.gap * 2) {
                            this.setSize(w, h);
                        }
                    } else {
                        if (this.isMoveEnabled) {
                            if (x + this.width/2  &gt; 0 &amp;&amp;
                                y + this.height/2 &gt; 0 &amp;&amp;
                                x &lt; this.parent.width  - this.width/2  &amp;&amp;
                                y &lt; this.parent.height - this.height/2    )
                            {
                                this.setLocation(x, y);
                            }
                        }
                    }
                }
            };

            /**
             * Define pointer drag started events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragStarted
             */
            this.pointerDragStarted = function(e) {
                this.$state = null;
                if (this.isResizeEnabled || this.isMoveEnabled) {
                    var t = this.shaperBr.detectAt(this, e.x, e.y);
                    if ((this.isMoveEnabled   === true || t !== &quot;center&quot;)||
                        (this.isResizeEnabled === true || t === &quot;center&quot;)  )
                    {
                        this.$state = { top    : (t === &quot;top&quot;    || t === &quot;topLeft&quot;     || t === &quot;topRight&quot;   ) ? 1 : 0,
                                       left   : (t === &quot;left&quot;   || t === &quot;topLeft&quot;     || t === &quot;bottomLeft&quot; ) ? 1 : 0,
                                       right  : (t === &quot;right&quot;  || t === &quot;topRight&quot;    || t === &quot;bottomRight&quot;) ? 1 : 0,
                                       bottom : (t === &quot;bottom&quot; || t === &quot;bottomRight&quot; || t === &quot;bottomLeft&quot; ) ? 1 : 0 };

                        this.px = e.absX;
                        this.py = e.absY;
                    }
                }
            };

            /**
             * Define pointer dragged events handler
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e){
                if (this.$state !== null) {
                    var dy = (e.absY - this.py),
                        dx = (e.absX - this.px),
                        s  = this.$state,
                        nw = this.width  - dx * s.left + dx * s.right,
                        nh = this.height - dy * s.top  + dy * s.bottom;

                    if (nw &gt;= this.minWidth &amp;&amp; nh &gt;= this.minHeight) {
                        this.px = e.absX;
                        this.py = e.absY;
                        if ((s.top + s.right + s.bottom + s.left) === 0) {
                            this.setLocation(this.x + dx, this.y + dy);
                        } else {
                            this.setBounds(this.x + dx * s.left, this.y + dy * s.top, nw, nh);
                     //       this.invalidateLayout();
                        }
                    }
                }
            };

            /**
             * Set the border color for the given focus state.
             * @param {Boolean} b a focus state. true means the component holds focus,
             * false means the component is not a focus owner.
             * @param {String} color a border color
             * @method setBorderColor
             * @chainable
             */
            this.setBorderColor = function (b, color) {
                var rp = false;
                if (this.colors === null) {
                    this.colors = [ &quot;lightGray&quot;, &quot;blue&quot;];
                    rp = true;
                }

                var oldCol = this.colors[b?1:0];
                if (oldCol !== color) {
                    this.colors[b ? 1 : 0] = color;
                    rp = true;
                }

                var hasFocus = this.hasFocus();
                if (this.shaperBr.color !== this.colors[hasFocus?1:0]) {
                    this.shaperBr.color = this.colors[hasFocus?1:0];
                    rp = true;
                }

                if (rp) {
                    this.repaint();
                }

                return this;
            };

            /**
             * Set the border colors.
             * @param {String} col1 a color the border has to have when the
             * component doesn&#x27;t hold focus.
             * @param {String} [col2] a color the border has to have if the
             * component is focus owner.
             * @method setBorderColors
             * @chainable
             */
            this.setBorderColors = function(col1, col2) {
                this.setColor(false, col1);
                if (arguments.length &gt; 1) {
                    this.setColor(true, col2);
                }
                return this;
            };
        },

        function insert(i, constr, d) {
            if (this.kids.length &gt; 0) {
                this.removeAll();
            }

            var top  = this.getTop(),
                left = this.getLeft();

            if (d.width === 0 || d.height === 0) {
                d.toPreferredSize();
            }

            this.setBounds(d.x - left, d.y - top,
                           d.width + left + this.getRight(),
                           d.height + top + this.getBottom());
            this.$super(i, &quot;center&quot;, d);
        },

        function focused(){
            this.$super();
            this.shaperBr.color = this.colors[this.hasFocus()? 1 : 0];
            this.repaint();
        }
    ]);

    /**
     * Special tree model implementation that represents zebkit UI component
     * hierarchy as a simple tree model.
     * @param  {zebkit.ui.Panel} target a root UI component
     * @constructor
     * @class zebkit.ui.design.FormTreeModel
     * @extends zebkit.data.TreeModel
     */
    pkg.FormTreeModel = Class(zebkit.data.TreeModel, [
        function (target){
            this.$super(this.buildModel(target, null));
        },

        function $prototype() {
            /**
             * Build tree model by the given UI component.
             * @param  {zebkit.ui.Panel} comp a component
             * @return {zebkit.data.Item} a root tree model item
             * @method buildModel
             */
            this.buildModel = function(comp, root){
                var b    = typeof this.exclude !== &#x27;undefined&#x27; &amp;&amp; this.exclude(comp),
                    item = b ? root : this.createItem(comp);

                for(var i = 0; i &lt; comp.kids.length; i++) {
                    var r = this.buildModel(comp.kids[i], item);
                    if (r !== null) {
                        r.parent = item;
                        item.kids.push(r);
                    }
                }
                return b ? null : item;
            };

            /**
             * Find a tree item that relates to the given component.
             * @param  {zebkit.ui.Panel} c a component.
             * @return {zebkit.data.Item} a tree item.
             * @method itemByComponent
             */
            this.itemByComponent = function (c, r) {
                if (arguments.length &lt; 2) {
                    r = this.root;
                }

                if (r.comp === c) {
                    return c;
                }

                for(var i = 0;i &lt; r.kids.length; i++) {
                    var item = this.itemByComponent(c, r.kids[i]);
                    if (item !== null) {
                        return item;
                    }
                }
                return null;
            };

            this.createItem = function(comp){
                var name = comp.clazz.$name;
                if (typeof name === &#x27;undefined&#x27;) {
                    name = comp.toString();
                }

                var index = name.lastIndexOf(&#x27;.&#x27;),
                    item = new zebkit.data.Item(index &gt; 0 ? name.substring(index + 1) : name);

                item.comp = comp;
                return item;
            };
        }
    ]);
});
zebkit.package(&quot;web&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    /**
     * Web specific stuff to provide abstracted method to work in WEB context.
     * @class zebkit.web
     * @access package
     */

    /**
     * Device ratio.
     * @attribute $deviceRatio
     * @readOnly
     * @private
     * @type {Number}
     */
    pkg.$deviceRatio = typeof window.devicePixelRatio !== &quot;undefined&quot; ? window.devicePixelRatio
                                                                      : (typeof window.screen.deviceXDPI !== &quot;undefined&quot; ? window.screen.deviceXDPI / window.screen.logicalXDPI // IE
                                                                                                                         : 1);

    pkg.$windowSize = function() {
        // iOS retina devices can have a problem with performance
        // in landscape mode because of a bug (full page size is
        // just 1 pixels column more than video memory that can keep it)
        // So, just make width always one pixel less.
        return  {
            width : window.innerWidth, //   - 1,
            height: window.innerHeight
        };
    };

    /**
     * Calculates view port of a browser window
     * @return {Object} a browser window view port size.
     *
     *    &#x60;&#x60;&#x60;json
     *    {
     *      width : {Integer},
     *      height: {Integer}
     *    }
     *    &#x60;&#x60;&#x60;
     *
     * @method $viewPortSize
     * @for  zebkit.web
     * @private
     */
    pkg.$viewPortSize = function() {
        var ws   = pkg.$windowSize(),
            body = document.body,
            css  = [ &quot;margin-left&quot;, &quot;margin-right&quot;, &quot;margin-top&quot;, &quot;margin-bottom&quot;,
                     &quot;padding-left&quot;, &quot;padding-right&quot;, &quot;padding-top&quot;, &quot;padding-bottom&quot;,
                     &quot;border-left-width&quot;, &quot;border-right-width&quot;, &quot;border-top-width&quot;, &quot;border-bottom-width&quot;];

        for(var i = 0; i &lt; css.length;) {
            ws.width  -= (pkg.$measure(body, css[i++]) + pkg.$measure(body, css[i++]));
            ws.height -= (pkg.$measure(body, css[i++]) + pkg.$measure(body, css[i++]));
        }
        return ws;
    };

    pkg.$measure = function(e, cssprop) {
        var value = window.getComputedStyle(e, null).getPropertyValue(cssprop);
        return (value === null || value === &#x27;&#x27;) ? 0
                                                : parseInt(/(^[0-9\.]+)([a-z]+)?/.exec(value)[1], 10);
    };


    /**
     * Tests if the given DOM element is in document
     * @private
     * @param  {Element} element a DOM element
     * @return {Boolean} true if the given DOM element is in document
     * @method $contains
     * @for  zebkit.web
     */
    pkg.$contains = function(element) {
        // TODO: not sure it is required, probably it can be replaced with document.body.contains(e);
        return (typeof document.contains !== &#x27;undefined&#x27; &amp;&amp; document.contains(element)) ||
               (typeof document.body.contains !== &#x27;undefined&#x27; &amp;&amp; document.body.contains(element)); // !!! use body for IE
    };

    /**
     * Test if the given page coordinates is inside the given element
     * @private
     * @param  {Element} element a DOM element
     * @param  {Number} pageX an x page coordinate
     * @param  {Number} pageY an y page coordinate
     * @return {Boolean} true if the given point is inside the specified DOM element
     * @method $isInsideElement
     */
    pkg.$isInsideElement = function(element, pageX, pageY) {
        var r = element.getBoundingClientRect();
        return r !== null            &amp;&amp;
               pageX &gt;= r.left       &amp;&amp;
               pageY &gt;= r.top        &amp;&amp;
               pageX &lt;= r.right - 1  &amp;&amp;
               pageY &lt;= r.bottom - 1   ;
    };

    var $focusInOutSupported = (function() {
        var support = false,
            parent  = document.lastChild,
            a       = document.createElement(&#x27;a&#x27;);

        a.href = &#x27;#&#x27;;
        a.setAttribute(&quot;style&quot;, &quot;position:fixed;left:-99em;top:-99em;&quot;);
        a.addEventListener(&#x27;focusin&#x27;, function() {
            support = true;
        });

        parent.appendChild(a).focus();
        parent.removeChild(a);
        return support;
    })();

    pkg.$focusin = function(element, f, b) {
        return element.addEventListener($focusInOutSupported ? &quot;focusin&quot; : &quot;focus&quot;, f, b);
    };

    pkg.$focusout = function(element, f, b) {
        return element.addEventListener($focusInOutSupported ? &quot;focusout&quot; : &quot;blur&quot;, f, b);
    };

    pkg.$eventsBlackHole = function(e) {
        e.preventDefault();
        e.stopPropagation();
    };

    /**
     * Creates HTML element that &quot;eats&quot; (doesn&#x27;t propagate and prevents default) all input (touch, mouse, key)
     * events that it gets.
     * @return {HTMLElement} a created HTML element.
     * @method  $createBlockedElement
     * @protected
     * @for  zebkit.web
     */
    pkg.$createBlockedElement = function() {
        var be = document.createElement(&quot;div&quot;);
        be.style.height = be.style.width  = &quot;100%&quot;;
        be.style.left = be.style.top = &quot;0px&quot;;
        be.style.position = &quot;absolute&quot;;
        be.style[&quot;z-index&quot;] = &quot;100000&quot;;
        be.setAttribute(&quot;zebkit&quot;, &quot;blockedElement&quot;);

        be.onmouseup   = be.onmousedown = be.onmouseout =
        be.onmouseover = be.onmousemove = be.onkeydown  =
        be.onkeypress  = be.onkeyup = pkg.$eventsBlackHole;

        var events = [ &quot;touchstart&quot;, &quot;touchend&quot;, &quot;touchmove&quot;,
                       &quot;pointerdown&quot;, &quot;pointerup&quot;, &quot;pointermove&quot;,
                       &quot;pointerenter&quot;, &quot;pointerleave&quot; ];

        for(var i = 0 ; i &lt; events.length ; i++ ) {
           be.addEventListener(events[i], pkg.$eventsBlackHole, false);
        }

        return be;
    };

    /**
     * Extend standard 2D HTML Canvas context instance with the given set of methods.
     * If new methods clash with already existent 2D context method the old one is overwritten
     * with new one and old method is saved using its name prefixed with &quot;$&quot; character
     * @param  {CanvasRenderingContext2D} ctx  a 2D HTML Canvas context instance
     * @param  {Array} methods list of methods to be added to the context
     * @method $extendContext
     * @private
     */
    pkg.$extendContext = function(ctx, methods) {
        for(var k in methods) {
            if (k === &quot;$init&quot;) {
                methods[k].call(ctx);
            } else {
                var old = ctx[k];
                if (typeof old !== &#x27;undefined&#x27;) {
                    var kk = &quot;$&quot; + k;
                    if (typeof ctx[kk] === &#x27;undefined&#x27;) {
                        ctx[kk] = old;
                    }
                }
                ctx[k] = methods[k];
            }
        }
    };

    /**
     * Adjusts the given HTML Canvas element to the required size that takes in account device DPI.
     * Extend the canvas 2D context with extra methods and variables that are used with zebkit UI
     * engine.
     * @param  {HTMLCanvasElement} c a HTML canvas element
     * @param  {Integer} w  a required width of the given canvas
     * @param  {Integer} h  a required height of the given canvas
     * @param  {Boolean} [forceResize] flag to force canvas resizing even if the canvas has identical width and height.
     * It is required to re-create canvas 2D context to work properly.
     * @return {CanvasRenderingContext2D} a 2D context of the canvas element
     * @method $canvas
     * @protected
     * @for  zebkit.web
     */
    pkg.$canvas = function(c, w, h, forceResize) {
        // fetch current CSS size of canvas
        var cs = window.getComputedStyle(c, null),
            cw = parseInt(cs.getPropertyValue(&quot;width&quot;),  10),
            ch = parseInt(cs.getPropertyValue(&quot;height&quot;), 10),
            ctx = c.getContext(&quot;2d&quot;),
            updateRatio = false;

        // if CSS width or height has not been set for the canvas
        // it has to be done, otherwise scaling on hi-DPI screen
        // will not work
        if (isNaN(parseInt(c.style.width ))||
            isNaN(parseInt(c.style.height))  )
        {
            c.style.width  = &quot;&quot; + cw + &quot;px&quot;;
            c.style.height = &quot;&quot; + ch + &quot;px&quot;;
            updateRatio = true;
        }

        // setup new canvas CSS size if appropriate width and height
        // parameters have been passed and they don&#x27;t match current CSS
        // width and height
        if (arguments.length &gt; 1) {
            if (cw !== w || ch !== h) {
                c.style.width  = &quot;&quot; + w + &quot;px&quot;;
                c.style.height = &quot;&quot; + h + &quot;px&quot;;
                updateRatio = true;
            }
            cw = w;
            ch = h;
        }

        // canvas 2D context is singleton so check if the
        // context has already been modified to prevent
        // redundancy
        if (typeof ctx.$ratio === &quot;undefined&quot;) {
            ctx.$ratio = (ctx.webkitBackingStorePixelRatio ||   // backing store ratio
                          ctx.mozBackingStorePixelRatio    ||
                          ctx.msBackingStorePixelRatio     ||
                          ctx.backingStorePixelRatio       ||
                          ctx.backingStorePixelRatio       || 1);

            ctx.$getImageData = ctx.getImageData;
            ctx.$scale        = ctx.scale;          // save original method if at some stage
                                                    // it will be overridden (zebkit does it)
                                                    // only original method has to be used to
                                                    // adjust canvas to screen DPI
            if (pkg.$deviceRatio != ctx.$ratio) {
                var r = pkg.$deviceRatio / ctx.$ratio;
                ctx.getImageData= function(x, y, w, h) {
                    return this.$getImageData(x * r, y * r, w, h);
                };
            }

            // populate extra method to 2d context
            pkg.$extendContext(ctx, zebkit.draw.Context2D);
        }

        // take in account that canvas can be visualized on
        // Retina screen where the size of canvas (backstage)
        // can be less than it is real screen size. Let&#x27;s
        // make it match each other
        if (ctx.$ratio != pkg.$deviceRatio) {
            var ratio = pkg.$deviceRatio / ctx.$ratio;

            // calculate canvas with and height taking in account
            // screen ratio
            cw = Math.floor(cw * ratio);
            ch = Math.floor(ch * ratio);

            // adjust canvas size if it is necessary
            if (c.width != cw || c.height != ch || updateRatio === true || forceResize === true) {
                c.width  = cw;
                c.height = ch;
                ctx.$scale(ratio, ratio);
            }
        } else {
            // adjust canvas size if it is necessary
            if (c.width != cw || c.height != ch || forceResize === true) {
                c.width  = cw;
                c.height = ch;
            }
        }

        // TODO: top works not good in FF and it is better don&#x27;t use it
        // So, ascent has to be taking in account as it was implemented
        // before
        if (ctx.textBaseline !== &quot;top&quot; ) {
            ctx.textBaseline = &quot;top&quot;;
        }

        return ctx;
    };


    //  zebkit dependencies:
    //      -- zebkit.ui.event.Clipboard
    //      -- zebkit.web.$fetchKeyCode
    //
    //

    // IE doesn&#x27;t allow standard window.Event instantiation
    // this is a workaround to avoid the problem
    function CustomEvent(event, params ) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent( &#x27;CustomEvent&#x27; );
        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;

    function $dupKeyEvent(e, id, target)  {
        var k = new CustomEvent(id);
        k.keyCode   = e.keyCode;
        k.key       = e.key;
        k.code      = e.code;
// TODO: cannot be set in strict mode and most likely it is set with dispactEvent() function
// properly
//        k.target    = target;
        k.ctrlKey   = e.ctrlKey;
        k.altKey    = e.altKey;
        k.shiftKey  = e.shiftKey;
        k.metaKey   = e.metaKey;
        k.which     = e.which;

      // TODO: cannot be set in strict mode and most likely it is set with dispactEvent() function
      // properly
      //  k.timeStamp = e.timeStamp;
        return k;
    }

    /**
     * Clipboard support class. The class is light abstraction that helps to perform
     * textual data exchange via system (browser) clipboard. Browsers have different approaches
     * and features regarding clipboard implementation and clipboard API. This class
     * hides the native specific and provides simple way to exchange data via clipboard.
     * @param  {String} [triggerKeyCode] a key code that starts triggering clipboard copy
     * paste actions. It depends on platform. On Linux &quot;Control&quot; + &lt;xxx&gt; combination
     * should be used, but on Mac OSX &quot;MetaLeft&quot; + xxx.
     * To handle copy, paste and cut event override the following methods:
     *    - **copy**   &quot;clipCopy(focusOwnerComponent, data)&quot;
     *    - **paste**  &quot;clipPaste(focusOwnerComponent, data)&quot;
     *    - **cut**    &quot;clipCut(focusOwnerComponent, data)&quot;
     * @constructor
     * @class zebkit.web.Clipboard
     * @extends zebkit.ui.event.Clipboard
     */
    pkg.Clipboard = Class(zebkit.ui.event.Clipboard, [
        function(triggerKeyCode) {
            if (document.getElementById(this.clazz.id) !== null) {
                throw new Error(&quot;Duplicated clipboard element&quot;);
            }

            if (arguments.length &gt; 0 &amp;&amp; triggerKeyCode !== null) {
                this.triggerKeyCode = triggerKeyCode;
            } else {
                this.triggerKeyCode = zebkit.isMacOS ? &quot;MetaLeft&quot;
                                                     : &quot;Control&quot;;
            }

            if (this.triggerKeyCode !== null) {
                this.$clipboard = document.createElement(&quot;textarea&quot;);
                this.$clipboard.setAttribute(&quot;style&quot;, &quot;display:none;position:fixed;left:-99em;top:-99em;&quot;);
                this.$clipboard.setAttribute(&quot;id&quot;, this.clazz.id);

                this.$element   = null;

                var $this = this;

                window.addEventListener(&quot;keydown&quot;, function(e) {
                    var dest = $this.getDestination();
                    if (dest !== null) {
                        if (typeof dest.clipCopy !== &#x27;undefined&#x27; || typeof dest.clipPaste !== &#x27;undefined&#x27;) {
                            if (zebkit.web.$fetchKeyCode(e) === $this.triggerKeyCode) {
                                // value has to be set, otherwise some browsers (Safari) do not generate
                                // &quot;copy&quot; event
                                $this.$on(&quot;1&quot;);
                            }
                        }
                    }
                }, true);

                this.$clipboard.onkeydown = function(ee) {
                    $this.$element.dispatchEvent($dupKeyEvent(ee, &#x27;keydown&#x27;, this.$element));
                    $this.$clipboard.value = &quot;1&quot;;
                    $this.$clipboard.select();
                };

                this.$clipboard.onkeyup = function(ee) {
                    if (zebkit.web.$fetchKeyCode(ee) === $this.triggerKeyCode) {
                        $this.$clipboard.style.display = &quot;none&quot;;
                        $this.$element.focus();
                    }

                    $this.$element.dispatchEvent($dupKeyEvent(ee,&#x27;keyup&#x27;, $this.$element));
                };

                this.$clipboard.onfocus = function(e) {
                    if ($this.$element == null &amp;&amp; e.relatedTarget != null) {
                        $this.$element = e.relatedTarget;
                    }
                };

                this.$clipboard.onblur = function() {
                    this.value = &quot;&quot;;
                    this.style.display = &quot;none&quot;;

                    //!!! pass focus back to canvas
                    //    it has to be done for the case when cmd+TAB (switch from browser to
                    //    another application)
                    $this.$element.focus();
                };

                this.$clipboard.oncopy = function(ee) {
                    var dest = $this.getDestination();
                    if (dest          !== null &amp;&amp;
                        typeof dest.clipCopy !== &#x27;undefined&#x27;)
                    {
                        var v = dest.clipCopy();
                        $this.$clipboard.value = (v === null || typeof v === &#x27;undefined&#x27; ? &quot;&quot; : v);
                        $this.$clipboard.select();
                        if (typeof $this.clipCopy !== &#x27;undefined&#x27;) {
                            $this.clipCopy(v, $this.$clipboard.value);
                        }
                    }
                };

                this.$clipboard.oncut = function(ee) {
                    var dest = $this.getDestination();
                    if (dest !== null &amp;&amp; typeof dest.cut !== &#x27;undefined&#x27;) {
                        $this.$clipboard.value = dest.cut();
                        $this.$clipboard.select();
                        if (typeof $this.clipCut !== &#x27;undefined&#x27;) {
                            $this.clipCut(dest, $this.$clipboard.value);
                        }
                    }
                };

                if (zebkit.isFF === true) {
                    this.$clipboard.addEventListener(&quot;input&quot;, function(ee) {
                        var dest = $this.getDestination();
                        if (dest !== null &amp;&amp; typeof dest.clipPaste !== &#x27;undefined&#x27;) {
                            dest.clipPaste($this.$clipboard.value);
                            if (typeof $this.clipPaste !== &#x27;undefined&#x27;) {
                                $this.clipPaste(dest, $this.$clipboard.value);
                            }
                        }

                    }, false);
                } else {
                    this.$clipboard.onpaste = function(ee) {
                        var dest = $this.getDestination();
                        if (dest !== null &amp;&amp; typeof dest.clipPaste !== &#x27;undefined&#x27;) {
                            var txt = (typeof ee.clipboardData === &quot;undefined&quot;) ? window.clipboardData.getData(&#x27;Text&#x27;)  // IE
                                                                                : ee.clipboardData.getData(&#x27;text/plain&#x27;);
                            dest.clipPaste(txt);
                            if (typeof $this.clipPaste !== &#x27;undefined&#x27;) {
                                $this.clipPaste(dest, txt);
                            }
                        }
                        $this.$clipboard.value = &quot;&quot;;
                    };
                }

                document.body.appendChild(this.$clipboard);
            }
        },

        function $clazz() {
            this.id = &quot;zebkitClipboardBuffer&quot;;
        },

        function $prototype() {
            /**
             * Clipboard trigger key code.
             * @private
             * @readOnly
             * @attribute triggerKeyCode
             * @type {String}
             */
            this.triggerKeyCode = null;

            /**
             * Write the given content into clipboard. This method not necessary work on
             * all browsers by default. Many browsers issue security restrictions regarding
             * clipboard data manipulation.
             * @param  {String} txt a content
             * @method  write
             */
            this.write = function(txt) {
                try {
                    this.$on(txt);
                    if (typeof document.execCommand !== &#x27;undefined&#x27; &amp;&amp; document.execCommand(&quot;copy&quot;) !== true) {
                        throw new Error(&quot;Unsupported &#x27;copy&#x27; clipboard command&quot;);
                    }
                } finally {
                    this.$off();
                }
            };

            /**
             * Read clipboard content. This method not necessary work on
             * all browsers by default. Many browsers issue security restrictions regarding
             * clipboard data manipulation.
             * @return {String} a clipboard content.
             * @method  read
             */
            this.read = function() {
                try {
                    var clip = this.$on(&quot;&quot;);
                    if (typeof document.execCommand !== &#x27;undefined&#x27; &amp;&amp; document.execCommand(&quot;paste&quot;, null, null)) {
                        return clip.value;
                    } else {
                        throw new Error(&quot;Unsupported &#x27;paste&#x27; clipboard command&quot;);
                    }
                } finally {
                    this.$off();
                }
            };

            /**
             * Return focus from a hidden element back to initial one.
             * @private
             * @method $off
             */
            this.$off = function() {
                if (this.$clipboard.style.display !== &quot;none&quot;) {
                    this.$clipboard.value = &quot;&quot;;
                    this.$clipboard.style.display = &quot;none&quot;;

                    //!!! pass focus back to canvas
                    //    it has to be done for the case when cmd+TAB (switch from browser to
                    //    another application)
                    this.$element.focus();
                }
            };

            /**
             * Pass focus to hidden html element to catch input.
             * @private
             * @method $on
             */
            this.$on = function(txt) {
                this.$off();

                this.$element = document.activeElement;
                this.$clipboard.style.display = &quot;block&quot;;

                // value has to be set, otherwise some browsers (Safari) do not generate
                // &quot;copy&quot; event
                this.$clipboard.value = arguments.length &gt; 0 ? txt : &quot;1&quot;;
                this.$clipboard.select();
                this.$clipboard.focus();
                return this.$clipboard;
            };
        }
    ]);

    new pkg.Clipboard();


    // TODO List:
    //    [+] add pressure level field to pointer events
    //    [-] group field
    //    [+] round for pageX/pageY
    //    [+] double click
    //    [+] check if button field is required or can be removed from pointer event
    //    [+] support global status keeping and updating (ctrl/alt/shift)
    //    [+] &quot;lmouse&quot; and &quot;rmouse&quot; should be constants
    //    [-] list of active touches or pointers have to be available
    //    [-] meX/meY -&gt; (x, y) ?

    if (typeof pkg.doubleClickDelta === &#x27;undefined&#x27;) {
        pkg.doubleClickDelta = 280;
    }

    var PI4                      = Math.PI/4,  // used to calculate touch event gamma (direction
        PI4_3                    = PI4 * 3,    // in polar coordinate)
        $enteredElement          = null,
        $tmpWinMouseMoveListener = null,
        $lastPointerReleased     = null,
        $pointerPressedEvents    = {},         // collect all pointer pressed events
        LMOUSE = &quot;lmouse&quot;,
        RMOUSE = &quot;rmouse&quot;;

    /**
     * Normalized pointer event that is fired with mouse, touch, pen devices.
     * @class  zebkit.web.PointerEvent
     * @extends  zebkit.ui.event.PointerEvent
     * @constructor
     */
    pkg.PointerEvent = Class(zebkit.ui.event.PointerEvent, [
        function $prototype() {
            this.isAction = function() {
                return this.identifier !== RMOUSE &amp;&amp; this.touchCounter === 1;
            };

            this.$fillWith = function(identifier, e) {
                this.pageX      = Math.round(e.pageX);
                this.pageY      = Math.round(e.pageY);
                this.target     = e.target;
                this.identifier = identifier;
                this.altKey     = typeof e.altKey   !== &#x27;undefined&#x27; ? e.altKey   : false;
                this.shiftKey   = typeof e.shiftKey !== &#x27;undefined&#x27; ? e.shiftKey : false;
                this.ctrlKey    = typeof e.ctrlKey  !== &#x27;undefined&#x27; ? e.ctrlKey  : false;
                this.metaKey    = typeof e.metaKey  !== &#x27;undefined&#x27; ? e.metaKey  : false;
                this.pressure   = typeof e.pressure !== &#x27;undefined&#x27; ? e.pressure : 0.5;
            };

            this.getTouches = function() {
                var touches = [], i = 0;
                for(var k in pkg.$pointerPressedEvents) {
                    var pe = pkg.$pointerPressedEvents[k];
                    touches[i++] = {
                        pageX      : pe.pageX,
                        pageY      : pe.pageY,
                        identifier : pe.identifier,
                        target     : pe.target,
                        pressure   : pe.pressure,
                        pointerType: pe.stub.pointerType
                    };
                }
                return touches;
            };
        }
    ]);

    var ME_STUB      = new pkg.PointerEvent(), // instance of mouse event
        TOUCH_STUB   = new pkg.PointerEvent(), // instance of touch event
        POINTER_STUB = new pkg.PointerEvent(); // instance of pointer event

    ME_STUB.pointerType      = &quot;mouse&quot;;
    TOUCH_STUB.pointerType   = &quot;touch&quot;;
    POINTER_STUB.pointerType = &quot;unknown&quot;; // type of pointer events have to be copied from original WEB PointerEvent

    // !!!
    // global mouse move events handler (registered by drag out a canvas surface)
    // has to be removed every time a mouse button released with the given function
    function $cleanDragFix() {
        if ($tmpWinMouseMoveListener !== null      &amp;&amp;
            $pointerPressedEvents.hasOwnProperty(LMOUSE) === false &amp;&amp;
            $pointerPressedEvents.hasOwnProperty(RMOUSE) === false   )
        {
            window.removeEventListener(&quot;mousemove&quot;, $tmpWinMouseMoveListener, true);
            $tmpWinMouseMoveListener = null;
            return true;
        }
        return false;
    }

    function isIn(t, id) {
        for(var i = 0; i &lt; t.length; i++) {
            if (t[i].identifier === id) {
                return true;
            }
        }
        return false;
    }

    /**
     * Pointer event unifier is special class to normalize input events from different pointer devices (like
     * mouse, touch screen, pen etc) and various browsers. The class transform all the events to special
     * neutral pointer event.
     * @param  {DOMElement} element a DOM element to normalize pointer events
     * @param  {Object} destination a destination object that implements number of pointer events
     * handlers:
     *
     *      {
     *          $pointerPressed     : function(e) { ... },
     *          $pointerReleased    : function(e) { ... },
     *          $pointerClicked     : function(e) { ... },
     *          $pointerMoved       : function(e) { ... },
     *          $pointerDragStarted : function(e) { ... },
     *          $pointerDragged     : function(e) { ... },
     *          $pointerDragEnded   : function(e) { ... }
     *      }
     *
     *
     * @constructor
     * @class zebkit.web.PointerEventUnifier
     */
    pkg.PointerEventUnifier = Class([
        function $clazz() {
            // !!!!
            // TODO: this method works only for mouse (constant of mouse event ids is in)
            // not clear if it is ok
            //
            // the document mouse up happens when we drag outside a canvas.
            // in this case canvas doesn&#x27;t catch mouse up, so we have to do it
            // by global mouseup handler
            document.addEventListener(&quot;mouseup&quot;, function(e) {
                // ignore any mouse buttons except left
                // and right buttons
                if (e.button === 0 || e.button === 2) {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    // !!!!
                    // Check if the event target is not the canvas itself
                    // On desktop  &quot;mouseup&quot; event is generated only if
                    // you drag mouse outside a canvas and than release a mouse button
                    // At the same time in Android native browser (and may be other mobile
                    // browsers) &quot;mouseup&quot; event is fired every time you touch
                    // canvas or any other element. So check if target is not a canvas
                    // before doing releasing, otherwise it brings to error on mobile
                    if ($pointerPressedEvents.hasOwnProperty(id)) {
                        var mp = $pointerPressedEvents[id];
                        if (mp.$adapter.element !== e.target &amp;&amp; mp.$adapter.element.contains(e.target) === false) {
                            try {
                                if ($enteredElement !== null) {
                                    $enteredElement = null;
                                    mp.$adapter.destination.$pointerExited(ME_STUB);
                                }
                            } finally {
                                mp.$adapter.$UP(id, e, ME_STUB);
                            }
                        }
                    }
                }
            },  false); // false is important since if mouseUp  happens on
                        // canvas the canvas gets the event first and than stops
                        // propagating to prevent it
        },

        function $prototype() {
            this.$timer = null;
            this.$queue = [];

            this.$touchedAt = function(pageX, pageY, d) {
                var lx = pageX - d,
                    ty = pageY - d,
                    rx = pageX + d,
                    by = pageY + d;

                for(var k in $pointerPressedEvents) {
                    if (k !== LMOUSE &amp;&amp; k !== RMOUSE) {
                        var e = $pointerPressedEvents[k];
                        if (e.pageX &gt;= lx &amp;&amp; e.pageY &gt;= ty &amp;&amp; e.pageX &lt;= rx &amp;&amp; e.pageY &lt;= by) {
                            return true;
                        }
                    }
                }
                return false;
            };

            this.$DRAG = function(id, e, stub) {
                // a pointer touched has been pressed and pressed target zebkit component exists
                // emulate mouse dragging events if mouse has moved on the canvas where mouse
                // pressed event occurred
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    // get appropriate pointerPressed event that has occurred before
                    var mp = $pointerPressedEvents[id];

                    // ignore moved if there still start events that are waiting for to be fired
                    if (mp.$adapter.element === this.element) {
                        // target component exists and mouse cursor moved on the same
                        // canvas where mouse pressed occurred
                        if (this.$timer === null) {  // ignore drag for if the queue of touches is not empty
                            stub.$fillWith(id, e);

                            var dx = stub.pageX - mp.pageX,
                                dy = stub.pageY - mp.pageY,
                                d  = mp.direction;

                            // accumulate shifting of pointer
                            mp.$adx += dx;
                            mp.$ady += dy;

                            // update stored touch coordinates with a new one
                            mp.pageX  = stub.pageX;
                            mp.pageY  = stub.pageY;

                            // we can recognize direction only if move was not too small
                            if (Math.abs(mp.$adx) &gt; 4 || Math.abs(mp.$ady) &gt; 4) {
                                // compute gamma, this is corner in polar coordinate system
                                var gamma = Math.atan2(mp.$ady, mp.$adx);

                                // using gamma we can figure out direction
                                if (gamma &gt; -PI4) {
                                    d = (gamma &lt; PI4) ? &quot;right&quot; : (gamma &lt; PI4_3 ? &quot;bottom&quot; : &quot;left&quot;);
                                } else {
                                    d = (gamma &gt; -PI4_3) ? &quot;top&quot; : &quot;left&quot;;
                                }

                                mp.direction = d;

                                // clear accumulated shift
                                mp.$ady = mp.$adx = 0;

                                mp.gamma = gamma;
                            }

                            stub.direction = mp.direction;
                            stub.dx = dx;
                            stub.dy = dy;

                            try {
                                if (mp.isDragged === false) {
                                    this.destination.$pointerDragStarted(stub);
                                }

                                if (mp.isDragged === false || dx !== 0 || dy !== 0) {
                                    this.destination.$pointerDragged(stub);
                                }
                            } finally {
                                mp.isDragged = true;
                            }
                        }
                    } else {
                        mp.$adapter.$DRAG(id, e, stub);
                    }
                }
            };

            this.$fireUP = function(id, e, mp, stub, destination) {
                try {
                    // store coordinates and target
                    stub.$fillWith(id, e);

                    // TODO: uncomment it and replace with sub or so
                    //if (tt.group != null) tt.group.active = false;

                    // add press coordinates what can help to detect source
                    // of the event
                    stub.pressPageX = mp.pressPageX;
                    stub.pressPageY = mp.pressPageY;

                    // fire dragged or clicked
                    if (mp.isDragged === true) {
                        destination.$pointerDragEnded(stub);
                    } else {
                        // TODO: sometimes browser scrolls page during the click
                        // to detect it we have to check pageX / pageY coordinates with
                        // initial one to suppress not valid pointer clicked events
                        if (mp.pressPageY === stub.pageY &amp;&amp; mp.pressPageX === stub.pageX) {
                            if ($lastPointerReleased !== null &amp;&amp;
                                $lastPointerReleased.identifier === id &amp;&amp;
                                (new Date().getTime() - $lastPointerReleased.time) &lt;= pkg.doubleClickDelta)
                            {
                                destination.$pointerDoubleClicked(stub);
                            } else {
                                if (mp.group === stub.touchCounter) {  // TODO: temporary solution
                                    destination.$pointerClicked(stub);
                                }
                            }
                        }
                    }

                    // always complete pointer pressed with appropriate
                    // release event
                    destination.$pointerReleased(stub);
                } finally {
                    // clear handled pressed and dragged state
                    if (stub.touchCounter &gt; 0) {
                        stub.touchCounter--;
                    }
                    $lastPointerReleased = $pointerPressedEvents.hasOwnProperty(id) ? $pointerPressedEvents[id] : null;
                    delete $pointerPressedEvents[id];

                    // remove global move listener if necessary
                    $cleanDragFix();
                }
            };

            //  Possible cases of mouse up events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |      p--u   |          |    | p--|-u     |          |         |  p--|-u
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     p--|--u     |       |    | p---|--u  |    |       |   |  p--|-u     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            // Contract:
            //   -- handle only mouse events whose destination is the passed element
            //   -- does stop propagation if event has been handled
            //   -- clear drag  fix ?
            this.$UP = function(id, e, stub) {
                // remove timer if it has not been started yet since we already have
                // got UP event and have to fire pressed events from queue with the
                // UP handler
                if (this.$timer !== null) {
                    clearTimeout(this.$timer);
                    this.$timer = null;
                }

                // test if the pressed event for the given id has not been fired yet
                var isPressedInQ = false;
                for(var i = 0; i &lt; this.$queue.length; i++) {
                    if (this.$queue[i].identifier === id) {
                        isPressedInQ = true;
                        break;
                    }
                }

                // fire collected in queue pressed events
                this.$firePressedFromQ();

                // check if a pointer state is in pressed state
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    // get pointer pressed state for the given id
                    var mp = $pointerPressedEvents[id];

                    // mouse up can happen in another element than
                    // mouse down occurred. let the original element
                    // (where mouse down is happened) to handle it
                    if (this.element !== mp.$adapter.element) {
                        $enteredElement = null;
                        // wrap with try-catch to prevent inconsistency
                        try {
                            stub.$fillWith(id, e);
                            mp.$adapter.destination.$pointerExited(stub);
                            $enteredElement = this.element;
                            this.destination.$pointerEntered(stub);
                        } catch(ee) {
                            // keep it for exceptional cases
                            $enteredElement = this.element;
                            throw ee;
                        } finally {
                            mp.$adapter.$UP(id, e, stub);
                        }
                    } else {
                        if (isPressedInQ) {  // the mouse pressed and mouse released has happened in different
                                             // point in a time to let UI show visual state, for instance mouse
                                             // down and up
                            var $this = this;
                            setTimeout(function() {
                                $this.$fireUP(id, e, mp, stub, $this.destination);
                            }, 50);
                        } else {
                            this.$fireUP(id, e, mp, stub, this.destination);
                        }
                    }
                }
            };

            this.$indexOfQ = function(id) {
                for(var i = 0; i &lt; this.$queue.length; i++) {
                    if (id === this.$queue[i].identifier) {
                        return i;
                    }
                }
                return -1;
            };

            this.$firePressedFromQ = function() {
                // fire collected pointer pressed events
                if (this.$queue.length &gt; 0) {
                    var l = this.$queue.length;
                    for(var i = 0; i &lt; l; i++) {
                        var t = this.$queue[i];

                        try {
                            // reg the event
                            $pointerPressedEvents[t.identifier] = t;

                            t.stub.$fillWith(t.identifier, t);
                            t.group = l; // TODO: temporary solution

                            if (this.destination.$pointerPressed(t.stub) === true) {
                                if (t.stub.touchCounter &gt; 0) {
                                    t.stub.touchCounter--;
                                }
                                delete $pointerPressedEvents[t.identifier];
                            }
                        } catch(ex) {
                            // don&#x27;t forget to decrease counter
                            if (t.stub.touchCounter &gt; 0) {
                                t.stub.touchCounter--;
                            }
                            delete $pointerPressedEvents[t.identifier];
                            zebkit.dumpError(ex);
                        }
                    }
                    this.$queue.length = 0;
                }
            };

            this.$DOWN = function(id, e, stub) {
                $cleanDragFix();


                // remove not fired pointer pressed from queue if necessary
                var i = this.$indexOfQ(id);
                if (i &gt;= 0) {
                    this.$queue.splice(i, 1);
                }

                // release mouse pressed if it has not happened before
                if ($pointerPressedEvents.hasOwnProperty(id)) {
                    var mp = $pointerPressedEvents[id];
                    mp.$adapter.$UP(id, e, mp.stub);
                }

                // count pointer pressed
                stub.touchCounter++;

                try {
                    var q = {
                        target      : e.target,
                        direction   : null,
                        identifier  : id,
                        shiftKey    : e.shiftKey,
                        altKey      : e.altKey,
                        metaKey     : e.metaKey,
                        ctrlKey     : e.ctrlKey,
                        time        : (new Date()).getTime(),
                        $adapter    : this,
                        $adx        : 0,
                        $ady        : 0,
                        isDragged   : false,
                        stub        : stub
                    };

                    q.pageX = q.pressPageX = Math.round(e.pageX);
                    q.pageY = q.pressPageY = Math.round(e.pageY);

                    // put pointer pressed in queue
                    this.$queue.push(q);

                    // initiate timer to send collected new touch events
                    // if any new has appeared. the timer helps to collect
                    // events in one group
                    if (this.$queue.length &gt; 0 &amp;&amp; this.$timer === null) {
                        var $this = this;
                        this.$timer = setTimeout(function() {
                            $this.$timer = null;
                            $this.$firePressedFromQ(); // flush queue
                        }, 25);
                    }
                } catch(ee) {
                    // restore touch counter if an error has happened
                    if (stub.touchCounter &gt; 0) {
                        stub.touchCounter--;
                    }
                    throw ee;
                }
            };

            this.$MMOVE = function(e) {
                var pageX = Math.round(e.pageX),
                    pageY = Math.round(e.pageY);

                // ignore extra mouse moved event that can appear in IE
                if (this.$mousePageY !== pageY ||
                    this.$mousePageX !== pageX   )
                {

                    this.$mousePageX = pageX;
                    this.$mousePageY = pageY;

                    if ($pointerPressedEvents.hasOwnProperty(LMOUSE) ||
                        $pointerPressedEvents.hasOwnProperty(RMOUSE)   )
                    {
                        if ($pointerPressedEvents.hasOwnProperty(LMOUSE)) {
                            this.$DRAG(LMOUSE, e, ME_STUB);
                        }

                        if ($pointerPressedEvents.hasOwnProperty(RMOUSE)) {
                            this.$DRAG(RMOUSE, e, ME_STUB);
                        }
                    } else {
                        // initialize native fields
                        ME_STUB.$fillWith(&quot;mouse&quot;, e);
                        this.destination.$pointerMoved(ME_STUB);
                    }
                }
            };
        },

        function (element, destination) {
            if (element === null || typeof element === &#x27;undefined&#x27;) {
                throw new Error(&quot;Invalid DOM element&quot;);
            }

            if (destination === null || typeof destination === &#x27;undefined&#x27;) {
                throw new Error(&quot;Invalid destination&quot;);
            }

            this.destination = destination;
            this.element     = element;

            var $this = this;

            element.onmousedown = function(e) {
                // ignore any mouse buttons except left
                // and right buttons or long touch emulates mouse event what causes generations of
                // mouse down event after touch start event. Let&#x27;s suppress it
                if ((e.button !== 0 &amp;&amp; e.button !== 2) ||
                     $this.$touchedAt(e.pageX, e.pageY, 0))
                {
                    e.preventDefault();
                } else {
                    $this.$DOWN(e.button === 0 ? LMOUSE : RMOUSE, e, ME_STUB);
                    e.stopPropagation();
                }
            };


            //  Possible cases of mouse up events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |      p--u   |          |    | p--|-u     |          |         |  p--|-u
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     p--|--u     |       |    | p---|--u  |    |       |   |  p--|-u     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            // Contract:
            //   -- handle only mouse events whose destination is the passed element
            //   -- does stop propagation if event has been handled
            //   -- clear drag  fix ?
            element.onmouseup = function(e) {
                // ignore any mouse buttons except left
                // and right buttons
                if (e.button !== 0 &amp;&amp; e.button !== 2) {
                    e.preventDefault();
                } else {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    $this.$UP(id, e, ME_STUB);

                    if (typeof e.stopPropagation !== &#x27;undefined&#x27;) {
                        e.stopPropagation();
                    }
                }
            };

            // mouse over has to setup if necessary current over element variable
            // it requires to detect repeat mouse over event that happens when
            // for instance we switch between browser and other application, but
            // mouse cursor stays at the same place
            element.onmouseover = function(e) {
                // this code prevent mouse over for first touch on iOS and Android
                if ($this.$touchedAt(e.pageX, e.pageY, 0)) {
                    e.preventDefault();
                } else {
                    var id = e.button === 0 ? LMOUSE : RMOUSE;

                    // if a button has not been pressed handle mouse entered to detect
                    // zebkit component the mouse pointer entered and send appropriate
                    // mouse entered event to it
                    if ($pointerPressedEvents.hasOwnProperty(id) === false) {
                        // just for the sake of error prevention
                        // clean global move listeners
                        $cleanDragFix();

                        // if entered element is null or the target element
                        // is not a children/element of the entered element than
                        // fires pointer entered event
                        if ($enteredElement === null || ($enteredElement.contains(e.target) === false &amp;&amp; $enteredElement !== e.target)) {
                            ME_STUB.$fillWith(&quot;mouse&quot;, e);
                            $enteredElement = element;
                            destination.$pointerEntered(ME_STUB);
                        }
                    } else {
                        // remove any previously registered listener if
                        //  -- a mouse button has been pressed
                        //  -- a mouse button has been pressed on the canvas we have entered
                        if (element === e.target || element.contains(e.target)) {
                            $cleanDragFix();
                        }
                    }

                    e.stopPropagation();
                }
            };

            //  Possible cases of mouse out events:
            //
            //   a) +-------------+        b) +----------------+       c) +---------------+
            //      |  E          |           | E +----+       |          | E       +-----|
            //      |        *----|-&gt;         |   | *--|-&gt;     |          |         |  *--|-&gt;
            //      |             |           |   +----+       |          |         +-----|
            //      +-------------+           +----------------+          +---------------+
            // (out to document/body)      (out from kid to element)   (out from kid to document)
            //
            //   d) +--------+--------+    e) +----------+----------+    f) +---------+-------+
            //      | E      |        |       |  E +-----|-----+    |       | E +-----|       |
            //      |     *--|--&gt;     |       |    | *---|--&gt;  |    |       |   |  *--|-&gt;     |
            //      |        |        |       |    +-----|-----+    |       |   +-----|       |
            //      +--------+--------+       +----------+----------+       +---------+-------+
            //     (out from element to       (out from kid of element     (out from kid element
            //      other element)            to kid of another element)    to another element)
            //
            //   1) a mouse button doesn&#x27;t have to be pressed on any element
            //   2) e.target always equals to element (E), just because we register event handler
            //      for element. This guarantees element will get mouse out event only from itself
            //      and its children elements
            //   3) mouse out should trigger pointerExited event only if the relatedTarget element
            //      is not the element (E) or kid of the element (E)
            //   4) if a mouse button has been pressed than mouse out registers mouse move listener
            //      to track drag events if the listener has nor been registered yet.
            //   5) mouse out set to null $enteredElement

            element.onmouseout = function(e) {
                var id = e.button === 0 ? LMOUSE : RMOUSE;

                // no pressed button exists
                if ($pointerPressedEvents.hasOwnProperty(id) === false) {
                    // the target element is the not a kid of the element
                    if ($enteredElement !== null &amp;&amp; (e.relatedTarget != null     &amp;&amp;
                                                     e.relatedTarget !== element &amp;&amp;
                                                     element.contains(e.relatedTarget) === false))
                    {
                        $enteredElement = null;
                        ME_STUB.$fillWith(&quot;mouse&quot;, e);

                        if (zebkit.web.$isInsideElement(element, e.pageX, e.pageY) === false) {
                            destination.$pointerExited(ME_STUB);
                        }
                    }
                } else {
                    var mp = $pointerPressedEvents[id];

                    // if a button has been pressed but the mouse cursor is outside of
                    // the canvas, for a time being start listening mouse moved events
                    // of Window to emulate mouse moved events in canvas
                    if ($tmpWinMouseMoveListener === null &amp;&amp;
                        e.relatedTarget != null &amp;&amp;
                        element.contains(e.relatedTarget) === false)
                    {
                        // !!! ignore touchscreen devices
                        if (id === LMOUSE || id === RMOUSE) {
                            $tmpWinMouseMoveListener = function(ee) {
                                ee.stopPropagation();

                                if ($pointerPressedEvents.hasOwnProperty(LMOUSE)) {
                                    $this.$DRAG(LMOUSE, {
                                        pageX  : ee.pageX,
                                        pageY  : ee.pageY,
                                        target : mp.target,
                                    }, ME_STUB);
                                }

                                if ($pointerPressedEvents.hasOwnProperty(RMOUSE)) {
                                    $this.$DRAG(RMOUSE, {
                                        pageX  : ee.pageX,
                                        pageY  : ee.pageY,
                                        target : mp.target,
                                    }, ME_STUB);
                                }

                                ee.preventDefault();
                            };

                            window.addEventListener(&quot;mousemove&quot;, $tmpWinMouseMoveListener, true);
                        }
                    }
                }

                $this.$mousePageX = $this.$mousePageY = -1;
                e.stopPropagation();
            };

            if (&quot;onpointerdown&quot; in window || &quot;onmspointerdown&quot; in window) {
                var names = &quot;onpointerdown&quot; in window ? [ &quot;pointerdown&quot;,
                                                          &quot;pointerup&quot;,
                                                          &quot;pointermove&quot;,
                                                          &quot;pointerenter&quot;,
                                                          &quot;pointerleave&quot; ]
                                                      : [ &quot;MSPointerDown&quot;,
                                                          &quot;MSPointerUp&quot;,
                                                          &quot;MSPointerMove&quot;,
                                                          &quot;MSPointerEnter&quot;,
                                                          &quot;MSPointerLeave&quot; ];

                //
                // in windows 8 IE10  pointerType can be a number !!!
                // what is nit the case fo rinstanvce for Win 8.1
                //

                element.addEventListener(names[0], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = &quot;mouse&quot;;
                    } else if (pt === 2) {
                        pt = &quot;touch&quot;;
                    } else if (pt === 3) {
                        pt = &quot;pen&quot;;
                    }

                    if (pt !== &quot;mouse&quot;)  {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$DOWN(e.pointerId, e, POINTER_STUB);
                    }
                }, false);

                element.addEventListener(names[1], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = &quot;mouse&quot;;
                    } else if (pt === 2) {
                        pt = &quot;touch&quot;;
                    } else if (pt === 3) {
                        pt = &quot;pen&quot;;
                    }

                    if (pt !== &quot;mouse&quot;) {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$UP(e.pointerId, e, POINTER_STUB);
                    }
                }, false);

                element.addEventListener(names[2], function(e) {
                    var pt = e.pointerType;
                    if (pt === 4) {
                        pt = &quot;mouse&quot;;
                    } else if (pt === 2) {
                        pt = &quot;touch&quot;;
                    } else if (pt === 3) {
                        pt = &quot;pen&quot;;
                    }

                    if (pt !== &quot;mouse&quot;) {
                        POINTER_STUB.touch = e;
                        POINTER_STUB.pointerType = pt;
                        $this.$DRAG(e.pointerId, e, POINTER_STUB);
                    } else {
                        //e.pointerType = pt;
                        $this.$MMOVE(e);
                    }
                }, false);
            } else {
                element.addEventListener(&quot;touchstart&quot;, function(e) {
                    var allTouches = e.touches,
                        newTouches = e.changedTouches; // list of touch events that become
                                                       // active with the current touch start

                    // fix android bug: parasite event for multi touch
                    // or stop capturing new touches since it is already fixed
                    // TODO: have no idea what it is
                    // if (TOUCH_STUB.touchCounter &gt; e.touches.length) {
                    //     return;
                    // }

                    // android devices fire mouse move if touched but not moved
                    // let save coordinates what should prevent mouse move event
                    // generation
                    //
                    // TODO: not clear if second tap will fire mouse move or if the
                    // second tap will have any influence to first tap mouse move
                    // initiation
                    $this.$mousePageX = Math.round(e.pageX);
                    $this.$mousePageY = Math.round(e.pageY);

                    // fire touches that has not been fired yet
                    for(var i = 0; i &lt; newTouches.length; i++) {  // go through all touches
                        var newTouch = newTouches[i];
                        $this.$DOWN(newTouch.identifier, newTouch, TOUCH_STUB);
                    }

                    // clear touches that still is not in list of touches
                    for (var k in $pointerPressedEvents) {
                        if (isIn(allTouches, k) === false) {
                            var tt = $pointerPressedEvents[k];
                            if (tt.group != null) {
                                tt.group.active = false;
                            }
                            $this.$UP(tt.identifier, tt, TOUCH_STUB);
                        }
                    }

                    //!!!
                    //TODO: this calling prevents generation of phantom mouse move event
                    //but it is not clear if it will stop firing touch end/move events
                    //for some mobile browsers. Check it !
                    e.preventDefault();
                }, false);

                element.addEventListener(&quot;touchend&quot;, function(e) {
                    // update touches
                    var t = e.changedTouches;
                    for (var i = 0; i &lt; t.length; i++) {
                        var tt = t[i];
                        $this.$UP(tt.identifier, tt, TOUCH_STUB);
                    }

                    e.preventDefault();
                }, false);

                element.addEventListener(&quot;touchmove&quot;, function(e) {
                    var mt = e.changedTouches;

                    // clear dx, dy for not updated touches
                    for(var k in $this.touches) {
                        $pointerPressedEvents[k].dx = $pointerPressedEvents[k].dy = 0;
                    }

                    for(var i = 0; i &lt; mt.length; i++) {
                        var nmt = mt[i];
                        if ($pointerPressedEvents.hasOwnProperty(nmt.identifier)) {
                            var t = $pointerPressedEvents[nmt.identifier];
                            if (t.pageX !== Math.round(nmt.pageX) ||
                                t.pageY !== Math.round(nmt.pageY)   )
                            {
                                // TODO: analyzing time is not enough to generate click event since
                                // a user can put finger and wait for a long time. the best way is
                                // normalize time with movement (number of movement of dx/dy accumulation)
                                //if (t.isDragged) {// || (new Date().getTime() - t.time) &gt; 200) {
                                if (t.isDragged || Math.abs(nmt.pageX - t.pageX) + Math.abs(nmt.pageY - t.pageY) &gt; 4) {
                                    $this.$DRAG(nmt.identifier, nmt, TOUCH_STUB);
                                }
                            }
                        }
                    }

                    e.preventDefault();
                }, false);

                element.onmousemove = function(e) {
                    $this.$MMOVE(e);
                    e.stopPropagation();
                };
            }

            // TODO: not sure it has to be in pointer unifier
            element.oncontextmenu = function(e) {
                e.preventDefault();
            };
        }
    ]);


    /**
     *  Mouse wheel support class. Installs necessary mouse wheel listeners and handles mouse wheel
     *  events in zebkit UI. The mouse wheel support is plugging that is configured by a JSON
     *  configuration.
     *  @class zebkit.web.MouseWheelSupport
     *  @param  {DOMElement} element
     *  @param  {Object} destination
     *  @constructor
     */
    pkg.MouseWheelSupport = Class([
        function(element, destination) {
            var META = this.clazz.$META;
            for(var k in META) {
                if (META[k].test()) {
                    var $wheelMeta = META[k],
                        $clazz     = this.clazz;

                    element.addEventListener(k,
                        function(e) {
                            var dy = typeof e[$wheelMeta.dy] !== &#x27;undefined&#x27; ? e[$wheelMeta.dy] * $wheelMeta.dir : 0,
                                dx = typeof e[$wheelMeta.dx] !== &#x27;undefined&#x27; ? e[$wheelMeta.dx] * $wheelMeta.dir : 0;

                            // some version of FF can generates dx/dy  &lt; 1
                            if (Math.abs(dy) &lt; 1) {
                                dy *= $clazz.dyZoom;
                            }

                            if (Math.abs(dx) &lt; 1) {
                                dx *= $clazz.dxZoom;
                            }

                            dy = Math.abs(dy) &gt; $clazz.dyNorma ? dy % $clazz.dyNorma : dy;
                            dx = Math.abs(dx) &gt; $clazz.dxNorma ? dx % $clazz.dxNorma : dx;

                            // do floor since some mouse devices can fire float as
                            if (destination.$doScroll(Math.floor(dx),
                                                      Math.floor(dy), &quot;wheel&quot;))
                            {
                                e.preventDefault();
                            }
                        },
                        false);
                    break;
                }
            }
        },

        function $clazz() {
            this.dxZoom = this.dyZoom = 20;
            this.dxNorma = this.dyNorma = 80;

            this.$META = {
                wheel: {
                    dy  : &quot;deltaY&quot;,
                    dx  : &quot;deltaX&quot;,
                    dir : 1,
                    test: function() {
                        return &quot;WheelEvent&quot; in window;
                    }
                },
                mousewheel: {
                    dy  : &quot;wheelDelta&quot;,
                    dx  : &quot;wheelDeltaX&quot;,
                    dir : -1,
                    test: function() {
                        return document.onmousewheel !== undefined;
                    }
                },
                DOMMouseScroll: {
                    dy  : &quot;detail&quot;,
                    dir : 1,
                    test: function() {
                        return true;
                    }
                }
            };
        },

        function $prototype() {
            /**
             * Indicates if the wheel scrolling is done following natural
             * direction.
             * @attribute naturalDirection
             * @type {Boolean}
             * @default true
             */
            this.naturalDirection = true;
        }
    ]);


    // Key CODES meta
    // pr  - preventDefault, false if not defined
    // rp  - repeatable key, true if not defined
    // map  - map code to another code
    // ignore  - don&#x27;t fire the given event, false by default
    var CODES = {
            &quot;KeyA&quot;  : { keyCode: 65 },
            &quot;KeyB&quot;  : { keyCode: 66 },
            &quot;KeyC&quot;  : { keyCode: 67 },
            &quot;KeyD&quot;  : { keyCode: 68 },
            &quot;KeyE&quot;  : { keyCode: 69 },
            &quot;KeyF&quot;  : { keyCode: 70 },
            &quot;KeyG&quot;  : { keyCode: 71 },
            &quot;KeyH&quot;  : { keyCode: 72 },
            &quot;KeyI&quot;  : { keyCode: 73 },
            &quot;KeyJ&quot;  : { keyCode: 74 },
            &quot;KeyK&quot;  : { keyCode: 75 },
            &quot;KeyL&quot;  : { keyCode: 76 },
            &quot;KeyM&quot;  : { keyCode: 77 },
            &quot;KeyN&quot;  : { keyCode: 78 },
            &quot;KeyO&quot;  : { keyCode: 79 },
            &quot;KeyP&quot;  : { keyCode: 80 },
            &quot;KeyQ&quot;  : { keyCode: 81 },
            &quot;KeyR&quot;  : { keyCode: 82 },
            &quot;KeyS&quot;  : { keyCode: 83 },
            &quot;KeyT&quot;  : { keyCode: 84 },
            &quot;KeyU&quot;  : { keyCode: 85 },
            &quot;KeyV&quot;  : { keyCode: 86 },
            &quot;KeyW&quot;  : { keyCode: 87 },
            &quot;KeyX&quot;  : { keyCode: 88 },
            &quot;KeyY&quot;  : { keyCode: 89 },
            &quot;KeyZ&quot;  : { keyCode: 90 },
            &quot;Digit0&quot;: { keyCode: 48 },
            &quot;Digit1&quot;: { keyCode: 49 },
            &quot;Digit2&quot;: { keyCode: 50 },
            &quot;Digit3&quot;: { keyCode: 51 },
            &quot;Digit4&quot;: { keyCode: 52 },
            &quot;Digit5&quot;: { keyCode: 53 },
            &quot;Digit6&quot;: { keyCode: 54 },
            &quot;Digit7&quot;: { keyCode: 55 },
            &quot;Digit8&quot;: { keyCode: 56 },
            &quot;Digit9&quot;: { keyCode: 57 },

            &quot;F1&quot;:  { keyCode: 112, key: &quot;F1&quot;,   rp: false  },
            &quot;F2&quot;:  { keyCode: 113, key: &quot;F2&quot;,   rp: false  },
            &quot;F3&quot;:  { keyCode: 114, key: &quot;F3&quot;,   rp: false  },
            &quot;F4&quot;:  { keyCode: 115, key: &quot;F4&quot;,   rp: false  },
            &quot;F5&quot;:  { keyCode: 116, key: &quot;F5&quot;,   rp: false  },
            &quot;F6&quot;:  { keyCode: 117, key: &quot;F6&quot;,   rp: false  },
            &quot;F7&quot;:  { keyCode: 118, key: &quot;F7&quot;,   rp: false  },
            &quot;F8&quot;:  { keyCode: 119, key: &quot;F8&quot;,   rp: false  },
            &quot;F9&quot;:  { keyCode: 120, key: &quot;F9&quot;,   rp: false  },
            &quot;F10&quot;: { keyCode: 121, key: &quot;F10&quot;,  rp: false  },
            &quot;F11&quot;: { keyCode: 122, key: &quot;F11&quot;,  rp: false  },
            &quot;F12&quot;: { keyCode: 123, key: &quot;F12&quot;,  rp: false  },
            &quot;F13&quot;: { keyCode: 124, key: &quot;F13&quot;,  rp: false  },
            &quot;F14&quot;: { keyCode: 125, key: &quot;F14&quot;,  rp: false  },
            &quot;F15&quot;: { keyCode: 126, key: &quot;F15&quot;,  rp: false  },

            &quot;Numpad0&quot;       : { keyCode: 96  },
            &quot;Numpad1&quot;       : { keyCode: 97  },
            &quot;Numpad2&quot;       : { keyCode: 98  },
            &quot;Numpad3&quot;       : { keyCode: 99  },
            &quot;Numpad4&quot;       : { keyCode: 100 },
            &quot;Numpad5&quot;       : { keyCode: 101 },
            &quot;Numpad6&quot;       : { keyCode: 102 },
            &quot;Numpad7&quot;       : { keyCode: 103 },
            &quot;Numpad8&quot;       : { keyCode: 104 },
            &quot;Numpad9&quot;       : { keyCode: 105 },
            &quot;NumpadDecimal&quot; : { keyCode: 110, key: &quot;Decimal&quot;  },
            &quot;NumpadSubtract&quot;: { keyCode: 109, key: &quot;Subtract&quot; },
            &quot;NumpadDivide&quot;  : { keyCode: 111, key: &quot;Divide&quot;   },
            &quot;NumpadMultiply&quot;: { keyCode: 106, key: &quot;Multiply&quot; },
            &quot;NumpadAdd&quot;     : { keyCode: 107, key: &quot;Add&quot;      },
            &quot;NumLock&quot;       : { keyCode: (zebkit.isFF ? 144 : 12) , key: &quot;NumLock&quot;, rp: false, ignore : true },

            &quot;Comma&quot;        : { keyCode: 188 },
            &quot;Period&quot;       : { keyCode: 190 },
            &quot;Semicolon&quot;    : { keyCode: (zebkit.isFF ? 59  : 186) },
            &quot;Quote&quot;        : { keyCode: 222 },
            &quot;BracketLeft&quot;  : { keyCode: 219 },
            &quot;BracketRight&quot; : { keyCode: 221 },
            &quot;Backquote&quot;    : { keyCode: 192 },
            &quot;Backslash&quot;    : { keyCode: 220 },
            &quot;Minus&quot;        : { keyCode: (zebkit.isFF ? 173 : 189) },
            &quot;Equal&quot;        : { keyCode: (zebkit.isFF ? 61  : 187) },

            &quot;NumpadEnter&quot;  : { map: &quot;Enter&quot; },
            &quot;Enter&quot;        : { keyCode: 13, key: &quot;\n&quot; },

            &quot;Slash&quot;        : { keyCode: 191 },
            &quot;Space&quot;        : { keyCode: 32, pr: true, key: &quot; &quot; },
            &quot;Delete&quot;       : { keyCode: 46, key: &quot;Delete&quot; },

            &quot;IntlRo&quot;     : { keyCode: (zebkit.isFF ? 167 : 193), key: &quot;IntlRo&quot;},

            &quot;Backspace&quot;  :  { keyCode: 8, pr: true, key: &quot;Backspace&quot; },
            &quot;Tab&quot;:          { keyCode: 9, pr: true, key: &quot;\t&quot; },
            &quot;ContextMenu&quot;:  { keyCode: zebkit.isFF ? 93 : 0, pr: true, key: &quot;ContextMenu&quot; },

            &quot;ArrowLeft&quot;   : { keyCode: 37, pr: true,  key: &quot;ArrowLeft&quot;   },
            &quot;ArrowRight&quot;  : { keyCode: 39, pr: true,  key: &quot;ArrowRight&quot;  },
            &quot;ArrowUp&quot;     : { keyCode: 38, pr: true,  key: &quot;ArrowUp&quot;     },
            &quot;ArrowDown&quot;   : { keyCode: 40, pr: true,  key: &quot;ArrowDown&quot;   },
            &quot;PageUp&quot;      : { keyCode: 33, pr: true,  key: &quot;PaheUp&quot;      },
            &quot;PageDown&quot;    : { keyCode: 34, pr: true,  key: &quot;PageDown&quot;    },
            &quot;Home&quot;        : { keyCode: 36, pr: true,  key: &quot;Home&quot;        },
            &quot;End&quot;         : { keyCode: 35, pr: true,  key: &quot;End&quot;         },

            &quot;Escape&quot;      : { keyCode: 27,  pr: true,  key: &quot;Escape&quot;,   rp: false },
            &quot;CapsLock&quot;    : { keyCode: 20,             key: &quot;CapsLock&quot;, rp: false, ignore : true },

            &quot;Shift&quot;       : { keyCode: 16,  pr: true, key: &quot;Shift&quot;, rp: false,},
            &quot;ShiftLeft&quot;   : { map: &quot;Shift&quot; },
            &quot;ShiftRight&quot;  : { map: &quot;Shift&quot; },

            &quot;Alt&quot;         : { keyCode: 18,  pr: true,  key: &quot;Alt&quot;,  rp: false, },
            &quot;AltLeft&quot;     : { map: &quot;Alt&quot; },
            &quot;AltRight&quot;    : { map: &quot;Alt&quot; },

            &quot;Control&quot;     : { keyCode: 17,  pr: true,  key: &quot;Control&quot;,  rp: false },
            &quot;ControlRight&quot;: { map: &quot;Control&quot; },
            &quot;ControlLeft&quot; : { map: &quot;Control&quot; },

            &quot;MetaLeft&quot;    : { keyCode: 91,  pr: true,  key: &quot;Meta&quot;, rp: false },
            &quot;MetaRight&quot;   : { keyCode: 93,  pr: true,  key: &quot;Meta&quot;, rp: false },
            &quot;OSLeft&quot;      : { keyCode: 224,  map: &quot;MetaLeft&quot; },
            &quot;OSRight&quot;     : { keyCode: 224,  map: &quot;MetaRight&quot;  }
        },

        CODES_MAP = {};

    // codes to that are not the same for different browsers
    function $initializeCodesMap() {
        var k = null, code = null;

        // validate codes mapping
        for(k in CODES) {
            code = CODES[k];
            if (typeof code.map !== &quot;undefined&quot;)  {
                if (typeof CODES[code.map] === &quot;undefined&quot;) {
                    throw new Error(&quot;Invalid mapping for code = &#x27;&quot; + k + &quot;&#x27;&quot;);
                }
            } else if (typeof code.keyCode === &quot;undefined&quot;) {
                throw new Error(&quot;unknown keyCode  for code = &#x27;&quot; + k + &quot;&#x27;&quot;);
            }
        }

        // build codes map table for the cases when &quot;code&quot; property
        CODES_MAP = {};
        for(k in CODES) {
            code = CODES[k];
            if (typeof code.map !== &quot;undefined&quot;) {
                if (typeof code.keyCode !== &quot;undefined&quot;) {
                    CODES_MAP[code.keyCode] = code.map;
                }
            } else {
                CODES_MAP[code.keyCode] = k;
            }
        }
    }

    pkg.$fetchKeyCode = function(e) {
        var code = e.code;
        if (typeof code !== &quot;undefined&quot;) {
            if (CODES.hasOwnProperty(code) &amp;&amp; CODES[code].hasOwnProperty(&quot;map&quot;)) {
                code = CODES[code].map;
            }
        } else {
            code = CODES_MAP[(e.which || e.keyCode || 0)];
            if (typeof code === &quot;undefined&quot;) {
                code = null;
            }
        }
        return code;
    };

    $initializeCodesMap();

    /**
     * Input key event class.
     * @class  zebkit.web.KeyEvent
     * @extends zebkit.ui.event.KeyEvent
     * @constructor
     */
    pkg.KeyEvent = Class(zebkit.ui.event.KeyEvent, [
        function $prototype() {
            /**
             * Fulfills the given abstract event with fields from the specified native WEB key event
             * @param  {KeyboardEvent} e a native WEB event
             * @method $fillWith
             * @chainable
             * @protected
             */
            this.$fillWith = function(e) {
                // code defines integer that in a case of
                // key pressed/released is zero or equals to physical key layout integer identifier
                // but for keyTyped should depict Unicode character code
                var keyCode = (e.which || e.keyCode || 0);

                this.code = pkg.$fetchKeyCode(e);

                if (this.code === &quot;Enter&quot; || this.code === &quot;Space&quot; || this.code === &quot;Tab&quot;) {
                    this.key = CODES[this.code].key;
                } else if (e.key != null) {
                    this.key = e.key;
                } else if (e.type === &quot;keypress&quot;) {
                    this.key = e.charCode &gt; 0 &amp;&amp; keyCode &gt;= 32 ? String.fromCharCode(e.charCode)
                                                               : null;
                } else {
                    if (e.keyIdentifier != null) {
                        if (e.keyIdentifier[0] === &#x27;U&#x27; &amp;&amp;  e.keyIdentifier[1] === &#x27;+&#x27;) {
                            this.key = String.fromCharCode(parseInt(e.keyIdentifier.substring(2), 16));
                        } else {
                            this.key = e.keyIdentifier;
                        }
                    } else {
                        if (this.code != null &amp;&amp; CODES.hasOwnProperty(this.code) === true &amp;&amp; CODES[this.code].key != null) {
                            this.key = CODES[this.code].key;
                        } else {
                            this.key = e.charCode &gt; 0 &amp;&amp; keyCode &gt;= 32 ? String.fromCharCode(e.charCode)
                                                                       : null;
                        }
                    }
                }

                this.altKey   = e.altKey;
                this.shiftKey = e.shiftKey;
                this.ctrlKey  = e.ctrlKey;
                this.metaKey  = e.metaKey;
                return this;
            };
        }
    ]);


    var KEY_DOWN_EVENT  = new pkg.KeyEvent(),
        KEY_UP_EVENT    = new pkg.KeyEvent(),
        KEY_PRESS_EVENT = new pkg.KeyEvent(),
        wasMetaLeftPressed  = false,
        wasMetaRightPressed = false;

    /**
     * Class that is responsible for translating native DOM element key event into abstract event that further
     * can be transfered to zebkit UI engine (or any other destination). Browsers key events support can be
     * implemented with slight differences from the standards. The goal of the class is key events unification.
     * The class fires three types of key events to passed event destination code:
     *    - $keyPressed(e)
     *    - $keyReleased(e)
     *    - $keyTyped(e)
     *
     * For instance imagine we have a DOM Element and want to have identical sequence and parameters of key
     * events the DOM element triggers. It can be done as follow:
     *
     *      new KeyEventUnifier(domElement, {
     *          &quot;$keyPressed&quot; : function(e) {
     *              ...
     *          },
     *
     *          &quot;$keyReleased&quot; : function(e) {
     *              ...
     *          },
     *
     *          &quot;$keyTyped&quot; : function(e) {
     *              ...
     *          }
     *      });
     *
     * @param  {HTMLElement} element
     * @param  {Object} destination a destination listener that can listen
     * @constructor
     * @class  zebkit.web.KeyEventUninfier
     */
    pkg.KeyEventUnifier = Class([
        function(element, destination) {
            //   Alt + x  was pressed  (for IE11 consider sequence of execution of &quot;alt&quot; and &quot;x&quot; keys)
            //   Chrome/Safari/FF  keydown -&gt; keydown -&gt; keypressed
            // ----------------------------------------------------------------------------------------------------------------------
            //          |     which   |    keyCode   | charCode |      code        |     key        |   keyIdentifier   |  char
            // ----------------------------------------------------------------------------------------------------------------------
            //          |             |              |          |                  |                |                   |
            //  Chrome  |    unicode/ |    unicode/  |   0      |  undefined       |  undefined     | Mnemonic + Unistr |   No
            //          |     code    |     code     |          |                  |                |  &quot;Alt&quot; + &quot;U-0058&quot; |
            //          |   18 + 88   |    18 + 88   |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  IE11    |  unicode/   |  unicode/    |          |                  |                |                   |  Alt =&gt; &quot;&quot;
            //          |   code      |    code      |    0     |   undefined      |   &quot;Alt&quot;,&quot;x&quot;    |   undefined       |  x =&gt; &quot;x&quot;
            //          |    18, 88   |   18, 88     |          |                  |                |                   |
            //          |             |              |          |                  |                |                   |
            //----------+-------------|--------------|----------|------------------|----------------|-------------------|------------
            //          |   unicode/  |   unicode/   |          |                  |                |                   |
            //          |   code      |     code     |    0     |  undefined       | undefined      | Mnemonic + Unistr |   No
            //  Safari  |   18 + 88   |   18 + 88    |          |                  |                |  &quot;Alt&quot; + &quot;U-0058&quot; |
            //          |             |              |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  FF      |   unicode/  |   unicode/   |    0     |  Mnemonic        | Mnemonic/char  |                   |  No
            //          |    code     |     code     |          |(&quot;AltLeft&quot;+&quot;KeyX&quot;)|  &quot;Alt&quot;+&quot;&quot;     |   undefined       |
            //          |  18 + 88    |  18 + 88     |          |                  |                |                   |
            //
            element.onkeydown = function(e) {
                var code = KEY_DOWN_EVENT.code,
                    pts  = KEY_DOWN_EVENT.timeStamp,
                    ts   = new Date().getTime();

                // fix loosing meta left keyup event in some browsers
                var fc = pkg.$fetchKeyCode(e);

                // ignore some keys that cannot be handled properly
                if (CODES[fc] != null &amp;&amp; CODES[fc].ignore === true) {
                    return;
                }

                if (wasMetaLeftPressed === true &amp;&amp; (e.metaKey !== true ||  fc === &quot;MetaLeft&quot;)) {
                    wasMetaLeftPressed = false;
                    try {
                        KEY_DOWN_EVENT.code      = &quot;MetaLeft&quot;;
                        KEY_DOWN_EVENT.repeat    = 0;
                        KEY_DOWN_EVENT.metaKey   = true;
                        KEY_DOWN_EVENT.timeStamp = ts;
                        destination.$keyReleased(KEY_DOWN_EVENT);
                    } catch(ex) {
                        zebkit.dumpError(ex);
                    } finally {
                        KEY_DOWN_EVENT.code = null;
                        code = null;
                    }
                }

                // fix loosing meta right keyup event in some browsers
                if (wasMetaRightPressed === true &amp;&amp; (e.metaKey !== true ||  fc === &quot;MetaRight&quot;)) {
                    wasMetaRightPressed = false;
                    try {
                        KEY_DOWN_EVENT.code      = &quot;MetaRight&quot;;
                        KEY_DOWN_EVENT.repeat    = 0;
                        KEY_DOWN_EVENT.metaKey   = true;
                        KEY_DOWN_EVENT.timeStamp = ts;
                        destination.$keyReleased(KEY_DOWN_EVENT);
                    } catch(ex) {
                        zebkit.dumpError(ex);
                    } finally {
                        KEY_DOWN_EVENT.code = null;
                        code = null;
                    }
                }

                // we suppose key down object is shared with key up that means it
                // holds state of key (we can understand whether a key has been
                // still held or was released by checking if the code equals)
                KEY_DOWN_EVENT.$fillWith(e);
                KEY_DOWN_EVENT.timeStamp = ts;

                // calculate repeat counter
                if (KEY_DOWN_EVENT.code === code &amp;&amp; e.metaKey !== true &amp;&amp; (ts - pts) &lt; 1000) {
                    KEY_DOWN_EVENT.repeat++;
                } else {
                    KEY_DOWN_EVENT.repeat = 1;
                }

                //!!!!
                // Suppress some standard browser actions.
                // Since container of zCanvas catch all events from its children DOM
                // elements don&#x27;t prevent the event for the children DOM element
                var key = CODES[KEY_DOWN_EVENT.code];
                if (key != null &amp;&amp; key.pr === true &amp;&amp; e.target === element) {
                    e.preventDefault();
                }
                e.stopPropagation();

                // fire key pressed event
                try {
                    destination.$keyPressed(KEY_DOWN_EVENT);
                } catch(ex) {
                    zebkit.dumpError(ex);
                }

                if (KEY_DOWN_EVENT.code === &quot;MetaLeft&quot;) {
                    wasMetaLeftPressed = true;
                } else if (KEY_DOWN_EVENT.code === &quot;MetaRight&quot;) {
                    wasMetaRightPressed = true;
                } else {
                    // if meta key is kept than generate key released event for
                    // all none-Meta keys. it is required since Meta + &lt;a key&gt;
                    // will never fire key released for &lt;a key&gt; (except state keys
                    // like shift, control etc)
                    if (e.metaKey === true) {
                        // only repeat
                        if (key == null || key.rp !== false) {
                            try {
                                KEY_UP_EVENT.$fillWith(e);
                                KEY_UP_EVENT.repeat = 0;
                                KEY_UP_EVENT.timeStamp = ts;
                                destination.$keyReleased(KEY_UP_EVENT);
                            } catch(ex) {
                                zebkit.dumpError(ex);
                            }
                        }
                    } else if (KEY_DOWN_EVENT.code === &quot;Space&quot; ||
                               KEY_DOWN_EVENT.code === &quot;Enter&quot; ||
                               KEY_DOWN_EVENT.code === &quot;Tab&quot;     )
                    {
                        // since space and enter key press event triggers preventDefault
                        // standard key press can never happen so let&#x27;s emulate it here
                        KEY_PRESS_EVENT.$fillWith(e);
                        KEY_PRESS_EVENT.repeat = KEY_DOWN_EVENT.repeat;
                        KEY_PRESS_EVENT.timeStamp = ts;
                        destination.$keyTyped(KEY_PRESS_EVENT);
                    }
                }
            };

            element.onkeyup = function(e) {
                e.stopPropagation();

                KEY_UP_EVENT.$fillWith(e);

                // ignore some keys that cannot be handled properly
                if (CODES[KEY_UP_EVENT.code] != null &amp;&amp; CODES[KEY_UP_EVENT.code].ignore === true) {
                    return;
                }

                if (wasMetaLeftPressed === true &amp;&amp; KEY_UP_EVENT.code === &quot;MetaLeft&quot;) {
                    wasMetaLeftPressed = false;
                }

                if (wasMetaRightPressed === true &amp;&amp; KEY_UP_EVENT.code === &quot;MetaRight&quot;) {
                    wasMetaRightPressed = false;
                }

                var key = CODES[KEY_UP_EVENT.code];
                if (e.metaKey !== true || (key != null &amp;&amp; key.rp === false)) {
                    KEY_UP_EVENT.repeat    = 0;
                    KEY_UP_EVENT.timeStamp = new Date().getTime();
                    try {
                        destination.$keyReleased(KEY_UP_EVENT);
                    } finally {
                        // clean repeat counter
                        if (KEY_DOWN_EVENT.code === KEY_UP_EVENT.code) {
                            KEY_DOWN_EVENT.repeat = 0;
                        }
                    }
                }
            };

            //   Alt + x  was pressed  (for IE11 consider sequence of execution of &quot;alt&quot; and &quot;x&quot; keys)
            // ----------------------------------------------------------------------------------------------------------------------
            //          |     which   |    keyCode   | charCode |      code        |     key        |   keyIdentifier   |  char
            // ----------------------------------------------------------------------------------------------------------------------
            //          |             |              |          |                  |                |                   |
            //  Chrome  |    unicode/ |    unicode/  |   8776   |  undefined       |  undefined     | Mnemonic + Unistr |   No
            //          |     code    |     code     |   ()    |                  |                |     &quot;U-0058&quot;      |
            //          |   8776 ()  |    8776 ()  |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  IE11    |  unicode/   |  unicode/    |          |                  |                |                   |
            //          |   code      |    code      |  88 (x)  |   undefined      |     &quot;x&quot;        |   undefined       |   &quot;x&quot;
            //          |    88 (x)   |   88 (x)     |          |                  |                |                   |
            //          |             |              |          |                  |                |                   |
            //----------+-------------|--------------|----------|------------------|----------------|-------------------|------------
            //          |   unicode/  |   unicode/   |          |                  |                |                   |
            //          |   code      |     code     | 8776 () |  undefined       | undefined      |                   |   No
            //  Safari  |   8776 ()  |   8776 ()   |          |                  |                |        &quot;&quot;         |
            //          |             |              |          |                  |                |                   |
            //----------+-----------------------------------------------------------------------------------------------|------------
            //          |             |              |          |                  |                |                   |
            //  FF      |   unicode/  |    0         |   8776   |  Mnemonic        | Mnemonic/char  |                   |   No
            //          |    code     |              |   ()    |  (&quot;KeyX&quot;)        |      &quot;&quot;       |   undefined       |
            //          |  8776 ()   |              |          |                  |                |                   |
            //
            element.onkeypress = function(e) {
                e.stopPropagation();

                // pressed meta key should bring to ignorance keypress event since the event
                // is emulated in keydown event handler.
                if (e.metaKey !== true) {
                    KEY_PRESS_EVENT.$fillWith(e);

                    KEY_PRESS_EVENT.code   = KEY_DOWN_EVENT.code;      // copy code of keydown key since key press can contain undefined code
                    KEY_PRESS_EVENT.repeat = KEY_DOWN_EVENT.repeat;

                    if (KEY_PRESS_EVENT.code !== &quot;Space&quot; &amp;&amp;
                        KEY_PRESS_EVENT.code !== &quot;Enter&quot; &amp;&amp;
                        KEY_PRESS_EVENT.code !== &quot;Tab&quot;   &amp;&amp;
                        KEY_PRESS_EVENT.code !== &quot;ContextMenu&quot;)
                    {
                        // Since container of zCanvas catch all events from its children DOM
                        // elements don&#x27;t prevent the event for the children DOM element
                        KEY_PRESS_EVENT.timeStamp = new Date().getTime();
                        destination.$keyTyped(KEY_PRESS_EVENT);
                    }
                }
            };
        }
    ]);
});
zebkit.package(&quot;ui.web&quot;, function(pkg, Class) {
    &#x27;use strict&#x27;;
    /**
     * Cursor manager class. Allows developers to control pointer cursor type by implementing an own
     * getCursorType method or by specifying a cursor by cursorType field. Imagine an UI component
     * needs to change cursor type. It
     *  can be done by one of the following way:
     *
     *   - **Implement getCursorType method by the component itself if the cursor type depends on cursor location**

          var p = new zebkit.ui.Panel([
               // implement getCursorType method to set required
               // pointer cursor type
               function getCursorType(target, x, y) {
                   return zebkit.ui.Cursor.WAIT;
               }
          ]);

     *   - **Define &quot;cursorType&quot; property in component if the cursor type doesn&#x27;t depend on cursor location**

          var myPanel = new zebkit.ui.Panel();
          ...
          myPanel.cursorType = zebkit.ui.Cursor.WAIT;


     *  @class zebkit.ui.web.CursorManager
     *  @constructor
     *  @extends zebkit.ui.event.Manager
     */
    pkg.CursorManager = Class(zebkit.ui.event.CursorManager, [
        function $prototype() {
            this.$isFunc = false;
            this.source = this.target = null;

            /**
             * Define pointer moved events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerMoved
             */
            this.pointerMoved = function(e) {
                if (this.$isFunc === true) {
                    this.cursorType = this.source.getCursorType(this.source, e.x, e.y);
                    this.target.style.cursor = (this.cursorType === null) ? &quot;default&quot;
                                                                          : this.cursorType;
                }
            };

            /**
             * Define pointer entered events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerEntered
             */
            this.pointerEntered = function(e) {
                if ((typeof e.source.cursorType !== &#x27;undefined&#x27; &amp;&amp; e.source.cursorType !== null) ||
                     typeof e.source.getCursorType !== &#x27;undefined&#x27;)
                {
                    this.$isFunc = (typeof e.source.getCursorType === &#x27;function&#x27;);
                    this.target = e.target;
                    this.source = e.source;

                    this.cursorType = this.$isFunc === true ? this.source.getCursorType(this.source, e.x, e.y)
                                                            : this.source.cursorType;

                    this.target.style.cursor = (this.cursorType === null) ? &quot;default&quot;
                                                                          : this.cursorType;
                }
            };

            /**
             * Define pointer exited events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerExited
             */
            this.pointerExited  = function(e){
                if (this.source !== null) {
                    this.cursorType = &quot;default&quot;;
                    if (this.target.style.cursor != this.cursorType) {
                        this.target.style.cursor = this.cursorType;
                    }
                    this.source = this.target = null;
                    this.$isFunc = false;
                }
            };

            /**
             * Define pointer dragged events handler.
             * @param  {zebkit.ui.event.PointerEvent} e a pointer event
             * @method pointerDragged
             */
            this.pointerDragged = function(e) {
                if (this.$isFunc === true) {
                    this.cursorType = this.source.getCursorType(this.source, e.x, e.y);
                    this.target.style.cursor = (this.cursorType === null) ? &quot;default&quot;
                                                                          : this.cursorType;
                }
            };
        }
    ]);

    // TODO: make sure it should be done here, instead of json config
    pkg.cd(&quot;..&quot;).cursorManager = new pkg.CursorManager();


    var ui = pkg.cd(&quot;..&quot;);

    /**
     *  WEB based zebkit UI components.
     *
     * @class zebkit.ui.web
     * @access package
     */


    /**
     * HTML element UI component wrapper class. The class represents an HTML element as if it is standard
     * UI component. It helps to use some standard HTML element as zebkit UI components and embeds it
     * in zebkit UI application layout.
     * @class zebkit.ui.web.HtmlElement
     * @constructor
     * @param {String|HTMLElement} [element] an HTML element to be represented as a standard zebkit UI
     * component. If the passed parameter is string it denotes a name of an HTML element. In this case
     * a new HTML element will be created.
     * @extends zebkit.ui.Panel
     */
    pkg.HtmlElement = Class(ui.Panel, [
        function(e) {
            if (arguments.length === 0) {
                e = &quot;div&quot;;
            }

            if (zebkit.isString(e)) {
                e = document.createElement(e);
                e.style.border   = &quot;0px solid transparent&quot;;   // clean up border
                e.style.fontSize = this.clazz.$bodyFontSize;  // DOM element is wrapped with a container that
                                                              // has zero sized font, so let&#x27;s set body  font
                                                              // for the created element
            }

            // sync padding and margin of the DOM element with
            // what appropriate properties are set
            e.style.margin = e.style.padding = &quot;0px&quot;;

            /**
             * Reference to HTML element the UI component wraps
             * @attribute element
             * @readOnly
             * @type {HTMLElement}
             */
            this.element = e;

            // this is set to make possible to use set z-index for HTML element
            this.element.style.position = &quot;relative&quot;;

            if (e.parentNode !== null &amp;&amp; e.parentNode.getAttribute(&quot;data-zebcont&quot;) !== null) {
                throw new Error(&quot;DOM element &#x27;&quot; + e + &quot;&#x27; already has container&quot;);
            }


            /**
             * Every zebkit HTML element is wrapped with a container (div) HTML element.
             * It is required since not all HTML elements are designed to be a container
             * (for instance HTMLCanvas element), where every zebkit has to be a container.
             * @attribute $container
             * @readOnly
             * @private
             * @type {HTMLElement}
             */

            // container is a DIV element that is used as a wrapper around original one
            // it is done to make HtmlElement implementation more universal making
            // all DOM elements capable to be a container for another one
            this.$container = document.createElement(&quot;div&quot;);

            // prevent stretching to a parent container element
            this.$container.style.display = &quot;inline-block&quot;;

            // cut content
            this.$container.style.overflow = &quot;hidden&quot;;

            // it fixes problem with adding, for instance, DOM element as window what can prevent
            // showing components added to popup layer
            this.$container.style[&quot;z-index&quot;] = &quot;0&quot;;

            // coordinates have to be set to initial zero value in CSS
            // otherwise the DOM layout can be wrong !
            this.$container.style.left = this.$container.style.top = &quot;0px&quot;;

            this.$container.visibility = &quot;hidden&quot;;  // before the component will be attached
                                                    // to parent hierarchy the component has to be hidden

            // container div will always few pixel higher than its content
            // to prevent the bloody effect set font to zero
            // border and margin also have to be zero
            this.$container.style.fontSize = this.$container.style.padding = this.$container.style.padding = &quot;0px&quot;;

            // add id
            this.$container.setAttribute(&quot;id&quot;, &quot;container-&quot; + this.toString());

            // mark wrapper with a special attribute to recognize it exists later
            this.$container.setAttribute(&quot;data-zebcont&quot;, &quot;true&quot;);

            // let html element interact
            this.$container.style[&quot;pointer-events&quot;] = &quot;auto&quot;;

            // if passed DOM element already has parent
            // attach it to container first and than
            // attach the container to the original parent element
            if (e.parentNode !== null) {
                // !!!
                // Pay attention container position cannot be set to absolute
                // since how the element has to be laid out is defined by its
                // original parent
                e.parentNode.replaceChild(this.$container, e);
                this.$container.appendChild(e);
            } else {
                // to force all children element be aligned
                // relatively to the wrapper we have to set
                // position CSS to absolute or absolute
                this.$container.style.position = &quot;absolute&quot;;
                this.$container.appendChild(e);
            }

            // set ID if it has not been already defined
            if (e.getAttribute(&quot;id&quot;) === null) {
                e.setAttribute(&quot;id&quot;, this.toString());
            }

            this.$super();

            // attach listeners
            if (typeof this.$initListeners !== &quot;undefined&quot;) {
                this.$initListeners();
            }

            var fe = this.$getElementRootFocus();

            // TODO: may be this code should be moved to web place
            //
            // reg native focus listeners for HTML element that can hold focus
            if (fe !== null) {
                var $this = this;

                zebkit.web.$focusin(fe, function(e) {
                    // sync native focus with zebkit focus if necessary
                    if ($this.hasFocus() === false) {
                        $this.requestFocus();
                    }
                }, false);

                zebkit.web.$focusout(fe, function(e) {
                    // sync native focus with zebkit focus if necessary
                    if ($this.hasFocus()) {
                        ui.focusManager.requestFocus(null);
                    }
                }, false);
            }
        },

        function $clazz() {
            this.CLASS_NAME = null;
            this.$bodyFontSize = window.getComputedStyle(document.body, null).getPropertyValue(&#x27;font-size&#x27;);
        },

        function $prototype() {
            this.$blockElement = this.$container = this.$canvas = null;
            this.ePsW = this.ePsH = 0;

            /**
             * Indicates that this component is a DOM element wrapper
             * @attribute isDOMElement
             * @type {Boolean}
             * @private
             * @readOnly
             */
            this.isDOMElement = true;   // indication of the DOM element that is used by DOM element manager to track
                                        // and manage its visibility

            this.$sizeAdjusted = false;


            this.wrap = function(c) {
                this.setLayout(new zebkit.layout.StackLayout());
                this.add(c);
                return this;
            };

            /**
             * Set the CSS font of the wrapped HTML element
             * @param {String|zebkit.Font} f a font
             * @method setFont
             * @chainable
             */
            this.setFont = function(f) {
                this.setStyle(&quot;font&quot;, f.toString());
                this.vrp();
                return this;
            };

            /**
             * Set the CSS color of the wrapped HTML element
             * @param {String} c a color
             * @chainable
             * @method setColor
             */
            this.setColor = function(c) {
                this.setStyle(&quot;color&quot;, c.toString());
                return this;
            };

            /**
             * Apply the given set of CSS styles to the wrapped HTML element
             * @param {Object} styles a dictionary of CSS styles
             * @chainable
             * @method setStyles
             */
            this.setStyles = function(styles) {
                for(var k in styles) {
                    this.$setStyle(this.element, k, styles[k]);
                }
                this.vrp();
                return this;
            };

            /**
             * Apply the given CSS style to the wrapped HTML element
             * @param {String} a name of the CSS style
             * @param {String} a value the CSS style has to be set
             * @chainable
             * @method setStyle
             */
            this.setStyle = function(name, value) {
                this.$setStyle(this.element, name, value);
                this.vrp();
                return this;
            };

            this.$setStyle = function(element, name, value) {
                name = name.trim();
                var i = name.indexOf(&#x27;:&#x27;);
                if (i &gt; 0) {
                    if (zebkit[name.substring(0, i)] !== true) {
                        return;
                    }
                    name = name.substring(i + 1);
                }
                element.style[name] = value;
                return this;
            };

            /**
             * Set the specified attribute to the wrapped HTML element
             * @param {String} name  a name of attribute
             * @param {String} value a value of the attribute
             * @chainable
             * @method setAttribute
             */
            this.setAttribute = function(name, value) {
                this.element.setAttribute(name, value);
                return this;
            };

            /**
             * Set the specified attributes set to the wrapped HTML element
             * @param {Object} attrs the dictionary of attributes where name of an attribute is a key
             * of the dictionary and
             * @method  setAttributes
             * @chainable
             */
            this.setAttributes = function(attrs) {
                for(var name in attrs) {
                    this.element.setAttribute(name, attrs[name]);
                }
                return this;
            };

            /**
             * Implements &quot;paint&quot; method to be aware when the component is visible.
             * It is used to adjust wrapped HTML element visibility and size.
             * @param  {CanvasRenderingContext2D} g a 2D canvas context
             * @method paint
             */
            this.paint = function(g) {
                // this method is used as an indication that the component
                // is visible and no one of his parent is invisible
                if (this.$container.style.visibility === &quot;hidden&quot;) {
                    this.$container.style.visibility = &quot;visible&quot;;
                }

                // calling paint says that the component in DOM tree
                // that is time to correct CSS size if necessary
                if (this.$sizeAdjusted !== true) {
                    this.setSize(this.width, this.height);
                }
            };

            this.calcPreferredSize = function(target) {
                return { width: this.ePsW, height: this.ePsH };
            };

            var $store = [
                &quot;paddingTop&quot;,&quot;paddingLeft&quot;,&quot;paddingBottom&quot;,&quot;paddingRight&quot;,
                &quot;border&quot;,&quot;borderStyle&quot;,&quot;borderWidth&quot;, &quot;borderTopStyle&quot;,
                &quot;borderTopWidth&quot;, &quot;borderBottomStyle&quot;,&quot;borderBottomWidth&quot;,
                &quot;borderLeftStyle&quot;,&quot;borderLeftWidth&quot;, &quot;borderRightStyle&quot;,
                &quot;visibility&quot;, &quot;borderRightWidth&quot;, &quot;width&quot;, &quot;height&quot;, &quot;position&quot;
            ];

            // the method calculates the given HTML element preferred size
            this.recalc = function() {
                // if component has a layout set it is up to a layout manager to calculate
                // the component preferred size. In this case the HTML element is a container
                // whose preferred size is defined by its content
                if (this.layout === this) {
                    var e         = this.element,
                        vars      = {},
                        domParent = null,
                        k         = null,
                        b         = !zebkit.web.$contains(this.$container);

                    // element doesn&#x27;t have preferred size if it is not a member of
                    // an html page, so add it if for a while
                    if (b) {
                        // save previous parent node since
                        // appendChild will overwrite it
                        domParent = this.$container.parentNode;
                        document.body.appendChild(this.$container);
                    }

                    // save element metrics
                    for(var i = 0; i &lt; $store.length; i++) {
                        k = $store[i];
                        vars[k] = e.style[k];
                    }

                    // force metrics to be calculated automatically
                    this.$container.style.visibility = &quot;hidden&quot;;
                    e.style.padding  = &quot;0px&quot;;
                    e.style.border   = &quot;none&quot;;
                    e.style.position = e.style.height = e.style.width = &quot;auto&quot;;

                    // fetch preferred size
                    this.ePsW = e.offsetWidth;
                    this.ePsH = e.offsetHeight;

                    for(k in vars) {
                        var v = vars[k];
                        if (v !== null) {
                            e.style[k] = v;
                        }
                    }

                    if (b) {
                        document.body.removeChild(this.$container);
                        // restore previous parent node
                        if (domParent !== null) {
                            domParent.appendChild(this.$container);
                        }
                    }
                }
            };

            /**
             * Set the inner content of the wrapped HTML element
             * @param {String} an inner content
             * @method setContent
             * @chainable
             */
            this.setContent = function(content) {
                this.element.innerHTML = content;
                this.vrp();
                return this;
            };

            this.$getElementRootFocus = function() {
                return null;
            };

            this.canHaveFocus = function() {
                return this.$getElementRootFocus() !== null;
            };

            this.$focus = function() {
                if (this.canHaveFocus() &amp;&amp; document.activeElement !== this.$getElementRootFocus()) {
                    this.$getElementRootFocus().focus();
                }
            };

            this.$blur = function() {
                if (this.canHaveFocus() &amp;&amp; document.activeElement === this.$getElementRootFocus()) {
                    this.$getElementRootFocus().blur();
                }
            };
        },

        function toFront() {
            this.$super();
            var pnode = this.$container.parentNode;
            if (pnode !== null &amp;&amp; pnode.lastChild !== this.$container) {
                pnode.removeChild(this.$container);
                pnode.appendChild(this.$container);
            }
        },

        function toBack() {
            this.$super();
            var pnode = this.$container.parentNode;
            if (pnode !== null &amp;&amp; pnode.firstChild !== this.$container) {
                pnode.removeChild(this.$container);
                pnode.insertBefore(this.$container, pnode.firstChild);
            }
        },

        function setEnabled(b) {
            if (this.isEnabled !== b) {
                if (b) {
                    this.$container.removeChild(this.$blockElement);
                } else {
                    if (this.$blockElement === null) {
                        this.$blockElement = zebkit.web.$createBlockedElement();
                    }
                    this.$container.appendChild(this.$blockElement);
               }
            }
            return this.$super(b);
        },

        function setSize(w, h) {
            // by the moment the method setSize is called the DOM element can be not a part of
            // HTML layout. In this case offsetWidth/offsetHeihght are always zero what prevents
            // us from proper calculation of CSS width and height. Postpone
            if (zebkit.web.$contains(this.$container)) {
                var prevVisibility = this.$container.style.visibility;
                this.$container.style.visibility = &quot;hidden&quot;; // could make sizing smooth

                // HTML element size is calculated as sum of CSS &quot;width&quot;/&quot;height&quot;, paddings, border
                // So the passed width and height has to be corrected (before it will be applied to
                // an HTML element) by reduction of extra HTML gaps. For this we firstly set the
                // width and size
                this.element.style.width  = &quot;&quot; + w + &quot;px&quot;;
                this.element.style.height = &quot;&quot; + h + &quot;px&quot;;

                var ww = 2 * w - this.element.offsetWidth,
                    hh = 2 * h - this.element.offsetHeight;

                if (ww !== w || hh !== h) {
                    // than we know the component metrics and can compute necessary reductions
                    this.element.style.width   = &quot;&quot; + ww + &quot;px&quot;;
                    this.element.style.height  = &quot;&quot; + hh + &quot;px&quot;;
                }

                this.$sizeAdjusted = true;

                // visibility correction is done by HTML elements manager
                this.$container.style.visibility = prevVisibility;
            } else {
                this.$sizeAdjusted = false;
            }

            return this.$super(w, h);
        },

        function setPadding(t,l,b,r) {
            if (arguments.length === 1) {
                l = b = r = t;
            }

            this.setStyles({
                paddingTop    : &#x27;&#x27; + t + &quot;px&quot;,
                paddingLeft   : &#x27;&#x27; + l + &quot;px&quot;,
                paddingRight  : &#x27;&#x27; + r + &quot;px&quot;,
                paddingBottom : &#x27;&#x27; + b + &quot;px&quot;
            });

            if (this.top !== t || this.left !== l || this.right !== r || this.bottom !== b) {
                // changing padding has influence to CSS size the component has to have
                // so we have to request CSS size recalculation
                this.$sizeAdjusted = false;
            }

            this.$super.apply(this, arguments);
            return this;
        },

        function setBorder(b) {
            b = zebkit.draw.$view(b);

            if (b === null) {
               this.setStyle(&quot;border&quot;, &quot;none&quot;);
            } else {
                this.setStyles({
                    //!!!! bloody FF fix, the border can be made transparent
                    //!!!! only via &quot;border&quot; style
                    border : &quot;0px solid transparent&quot;,

                    //!!! FF understands only decoupled border settings
                    borderTopStyle : &quot;solid&quot;,
                    borderTopColor : &quot;transparent&quot;,
                    borderTopWidth : &quot;&quot; + b.getTop() + &quot;px&quot;,

                    borderLeftStyle : &quot;solid&quot;,
                    borderLeftColor : &quot;transparent&quot;,
                    borderLeftWidth : &quot;&quot; + b.getLeft() + &quot;px&quot;,

                    borderBottomStyle : &quot;solid&quot;,
                    borderBottomColor : &quot;transparent&quot;,
                    borderBottomWidth : &quot;&quot; + b.getBottom() + &quot;px&quot;,

                    borderRightStyle : &quot;solid&quot;,
                    borderRightColor : &quot;transparent&quot;,
                    borderRightWidth : &quot;&quot; + b.getRight() + &quot;px&quot;
                });
            }

            // changing border can have influence to
            // CSS size, so request recalculation of the CSS
            // size
            if (this.border != b) {
                this.$sizeAdjusted = false;
            }

            return this.$super(b);
        },

        function validate() {
            // lookup root canvas
            if (this.$canvas === null &amp;&amp; this.parent !== null) {
                this.$canvas = this.getCanvas();
            }

            this.$super();
        },

        function focused() {
            this.$super();

            // sync state of zebkit focus with native focus of the HTML Element
            if (this.hasFocus()) {
                this.$focus();
            } else {
                this.$blur();
            }
        }
    ]).hashable();

    /**
     *  This special private manager that plays key role in integration of HTML ELement into zebkit UI hierarchy.
     *  Description to the class contains technical details of implementation that should not be interested for
     *  end users.
     *
     *  HTML element integrated into zebkit layout has to be tracked regarding:
     *    1) DOM hierarchy. A new added into zebkit layout DOM element has to be attached to the first found
     *       parent DOM element
     *    2) Visibility. If a zebkit UI component change its visibility state it has to have side effect to all
     *       children HTML elements on any subsequent hierarchy level
     *    3) Moving a zebkit UI component has to correct location of children HTML element on any subsequent
     *       hierarchy level.
     *
     *  The implementation of HTML element component has the following specific:
     *    1) Every original HTML is wrapped with &quot;div&quot; element. It is necessary since not all HTML element has been
     *       designed to be a container for another HTML element. By adding extra div we can consider the wrapper as
     *       container. The wrapper element is used to control visibility, location, enabled state
     *    2) HTML element has &quot;isDOMElement&quot; property set to true
     *    3) HTML element visibility depends on an ancestor component visibility. HTML element is visible if:
     *       - the element isVisible property is true
     *       - the element has a parent DOM element set
     *       - all his ancestors are visible
     *       - size of element is more than zero
     *       - getCanvas() != null
     *
     *  The visibility state is controlled with &quot;e.style.visibility&quot;
     *
     *  To support effective DOM hierarchy tracking a zebkit UI component defines &quot;$domKid&quot; property that contains
     *  direct DOM element the UI component hosts and other UI components that host DOM element. This is sort of tree:
     *
     *  &lt;pre&gt;
     *    +---------------------------------------------------------
     *    |  p1 (zebkit component)
     *    |   +--------------------------------------------------
     *    |   |  p2 (zebkit component)
     *    |   |    +---------+      +-----------------------+
     *    |   |    |   h1    |      | p3 zebkit component   |
     *    |   |    +---------+      |  +---------------+    |
     *    |   |                     |  |    h3         |    |
     *    |   |    +---------+      |  |  +---------+  |    |
     *    |   |    |   h2    |      |  |  |   p4    |  |    |
     *    |   |    +---------+      |  |  +---------+  |    |
     *    |   |                     |  +---------------+    |
     *    |   |                     +-----------------------+
     *
     *     p1.$domKids : {
     *         p2.$domKids : {
     *             h1,    * leaf elements are always DOM element
     *             h2,
     *             p3.$domKids : {
     *                h3
     *             }
     *         }
     *     }
     *   &lt;/pre&gt;
     *
     *  @constructor
     *  @private
     *  @class zebkit.ui.web.HtmlElementMan
     *  @extends zebkit.ui.event.Manager
     */
    pkg.HtmlElementMan = Class(zebkit.ui.event.Manager, [
        function $prototype() {
            /**
             * Evaluates if the given zebkit HTML UI component is invisible state.
             * @param  {zebkit.ui.HtmlElement}  c  an UI HTML element wrapper
             * @private
             * @method $isInInvisibleState
             * @return {Boolean} true if the HTML element wrapped with zebkit UI is in invisible state
             */
            function $isInInvisibleState(c) {
                if (c.isVisible === false            ||
                    c.$container.parentNode === null ||
                    c.width       &lt;= 0               ||
                    c.height      &lt;= 0               ||
                    c.parent      === null           ||
                    zebkit.web.$contains(c.$container) === false)
                {
                    return true;
                }

                var p = c.parent;
                while (p !== null &amp;&amp; p.isVisible === true &amp;&amp; p.width &gt; 0 &amp;&amp; p.height &gt; 0) {
                    p = p.parent;
                }

                return p !== null || ui.$cvp(c) === null;
            }

            // attach to appropriate DOM parent if necessary
            // c parameter has to be DOM element
            function $resolveDOMParent(c) {
                // try to find an HTML element in zebkit (pay attention, in zebkit hierarchy !)
                // hierarchy that has to be a DOM parent for the given component
                var parentElement = null;
                for(var p = c.parent; p !== null; p = p.parent) {
                    if (p.isDOMElement === true) {
                        parentElement = p.$container;
                        break;
                    }
                }

                // parentElement is null means the component has
                // not been inserted into DOM hierarchy
                if (parentElement !== null &amp;&amp; c.$container.parentNode === null) {
                    // parent DOM element of the component is null, but a DOM container
                    // for the element has been detected. We need to add it to DOM
                    // than we have to add the DOM to the found DOM parent element
                    parentElement.appendChild(c.$container);

                    // adjust location of just attached DOM component
                    $adjustLocation(c);
                } else {
                    // test consistency whether the DOM element already has
                    // parent node that doesn&#x27;t match the discovered
                    if (parentElement           !== null &amp;&amp;
                        c.$container.parentNode !== null &amp;&amp;
                        c.$container.parentNode !== parentElement)
                    {
                        throw new Error(&quot;DOM parent inconsistent state &quot;);
                    }
                }
            }

            //    +----------------------------------------
            //    |             ^      DOM1
            //    |             .
            //    |             .  (x,y) -&gt; (xx,yy) than correct left
            //                  .  and top of DOM2 relatively to DOM1
            //    |    +--------.--------------------------
            //    |    |        .       zebkit1
            //    |    |        .
            //    |    |  (left, top)
            //    |&lt;............+-------------------------
            //    |    |        |           DOM2
            //    |    |        |
            //
            //  Convert DOM (x, y) zebkit coordinates into appropriate CSS top and left
            //  locations relatively to its immediate DOM element. For instance if a
            //  zebkit component contains DOM component every movement of zebkit component
            //  has to bring to correction of the embedded DOM elements
            function $adjustLocation(c) {
                if (c.$container.parentNode !== null) {
                    // hide DOM component before move
                    // makes moving more smooth
                    var prevVisibility = null;
                    if (c.$container.style.visibility !== &quot;hidden&quot;) {
                        prevVisibility = c.$container.style.visibility;
                        c.$container.style.visibility = &quot;hidden&quot;;
                    }

                    // find a location relatively to the first parent HTML element
                    var p = c, xx = c.x, yy = c.y;
                    while (((p = p.parent) !== null) &amp;&amp; p.isDOMElement !== true) {
                        xx += p.x;
                        yy += p.y;
                    }

                    c.$container.style.left = &quot;&quot; + xx + &quot;px&quot;;
                    c.$container.style.top  = &quot;&quot; + yy + &quot;px&quot;;
                    if (prevVisibility !== null) {
                        c.$container.style.visibility = prevVisibility;
                    }
                }
            }

            // iterate over all found children HTML elements
            // !!! pay attention you have to check existence
            // of &quot;$domKids&quot; field before the method calling
            function $domElements(c, callback) {
                for (var k in c.$domKids) {
                    var e = c.$domKids[k];
                    if (e.isDOMElement === true) {
                        callback.call(this, e);
                    } else if (typeof e.$domKids !== &#x27;undefined&#x27;) { // prevent unnecessary method call by condition
                        $domElements(e, callback);
                    }
                }
            }

            this.compShown = function(e) {
                // 1) if c is DOM element than we have make it is visible if
                //      -- c.isVisible == true : the component visible  AND
                //      -- all elements in parent chain is visible      AND
                //      -- the component is in visible area
                //
                // 2) if c is not a DOM component his visibility state can have
                //    side effect to his children HTML elements (on any level)
                //    In this case we have to do the following:
                //      -- go through all children HTML elements
                //      -- if c.isVisible == false: make invisible every children element
                //      -- if c.isVisible != false: make visible every children element whose
                //         visibility state satisfies the following conditions:
                //          -- kid.isVisible == true
                //          -- all parent to c are in visible state
                //          -- the kid component is in visible area
                var c = e.source;
                if (c.isDOMElement === true) {
                    c.$container.style.visibility = c.isVisible === false || $isInInvisibleState(c) ? &quot;hidden&quot;
                                                                                                    : &quot;visible&quot;;
                } else if (typeof c.$domKids !== &#x27;undefined&#x27;) {
                    $domElements(c, function(e) {
                        e.$container.style.visibility = e.isVisible === false || $isInInvisibleState(e) ? &quot;hidden&quot; : &quot;visible&quot;;
                    });
                }
            };

            this.compMoved = function(e) {
                var c = e.source;

                // if we move a zebkit component that contains
                // DOM element(s) we have to correct the DOM elements
                // locations relatively to its parent DOM
                if (c.isDOMElement === true) {
                    // root canvas location cannot be adjusted since it is up to DOM tree to do it
                    if (c.$isRootCanvas !== true) {
                        var dx   = e.prevX - c.x,
                            dy   = e.prevY - c.y,
                            cont = c.$container;

                        cont.style.left = ((parseInt(cont.style.left, 10) || 0) - dx) + &quot;px&quot;;
                        cont.style.top  = ((parseInt(cont.style.top,  10) || 0) - dy) + &quot;px&quot;;
                    }
                } else if (typeof c.$domKids !== &#x27;undefined&#x27;) {
                    $domElements(c, function(e) {
                        $adjustLocation(e);
                    });
                }
            };

            function isLeaf(c) {
                if (typeof c.$domKids !== &#x27;undefined&#x27;) {
                    for(var k in c.$domKids) {
                        if (c.$domKids.hasOwnProperty(k)) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function detachFromParent(p, c) {
                // DOM parent means the detached element doesn&#x27;t
                // have upper parents since it is relative to the
                // DOM element
                if (p.isDOMElement !== true &amp;&amp; typeof p.$domKids !== &#x27;undefined&#x27;) {
                    // delete from parent
                    delete p.$domKids[c.$hash$];

                    // parent is not DOM and doesn&#x27;t have kids anymore
                    // what means the parent has to be also detached
                    if (isLeaf(p)) {
                        // parent of parent is not null and is not a DOM element
                        if (p.parent !== null &amp;&amp; p.parent.isDOMElement !== true) {
                            detachFromParent(p.parent, p);
                        }

                        // remove $domKids from parent since the parent is leaf
                        delete p.$domKids;
                    }
                }
            }

            function removeDOMChildren(c) {
                // DOM element cannot have children dependency tree
                if (c.isDOMElement !== true &amp;&amp; typeof c.$domKids !== &#x27;undefined&#x27;) {
                    for(var k in c.$domKids) {
                        if (c.$domKids.hasOwnProperty(k)) {
                            var kid = c.$domKids[k];

                            // DOM element
                            if (kid.isDOMElement === true) {
                                kid.$container.parentNode.removeChild(kid.$container);
                                kid.$container.parentNode = null;
                            } else {
                                removeDOMChildren(kid);
                            }
                        }
                    }
                    delete c.$domKids;
                }
            }

            this.compRemoved = function(e) {
                var c = e.kid;

                // if detached element is DOM element we have to
                // remove it from DOM tree
                if (c.isDOMElement === true) {
                    c.$container.parentNode.removeChild(c.$container);
                    c.$container.parentNode = null;
                } else {
                    removeDOMChildren(c);
                }

                detachFromParent(e.source, c);
            };

            this.compAdded = function(e) {
                var p = e.source,  c = e.kid;
                if (c.isDOMElement === true) {
                    $resolveDOMParent(c);
                } else {
                    if (typeof c.$domKids !== &#x27;undefined&#x27;) {
                        $domElements(c, function(e) {
                            $resolveDOMParent(e);
                        });
                    } else {
                        return;
                    }
                }

                if (p.isDOMElement !== true) {
                    // we come here if parent is not a DOM element and
                    // inserted children is DOM element or an element that
                    // embeds DOM elements
                    while (p !== null &amp;&amp; p.isDOMElement !== true) {
                        if (typeof p.$domKids === &#x27;undefined&#x27;) {
                            // if reference to kid DOM element or kid DOM elements holder
                            // has bot been created we have to continue go up to parent of
                            // the parent to register the whole chain of DOM and DOM holders
                            p.$domKids = {};
                            p.$domKids[c.$genHash()] = c;
                            c = p;
                            p = p.parent;
                        } else {
                            var id = c.$genHash();
                            if (p.$domKids.hasOwnProperty(id)) {
                                throw new Error(&quot;Inconsistent state for &quot; + c + &quot;, &quot; + c.clazz.$name);
                            }
                            p.$domKids[id] = c;
                            break;
                        }
                    }
                }
            };
        }
    ]);

    // instantiate manager
    pkg.$htmlElementMan = new pkg.HtmlElementMan();

    if (typeof zebkit.ui.event.FocusManager !== &#x27;undefined&#x27;) {
        zebkit.ui.event.FocusManager.extend([
            function requestFocus(c) {
                this.$super(c);

                var canvas = null;

                // if the requested for the focus UI componet doesn&#x27;t belong to a canvas that holds a native
                // focus then let&#x27;s give native focus to the canvas
                if (c !== null &amp;&amp; c !== this.focusOwner &amp;&amp; (c.isDOMElement !== true || c.$getElementRootFocus() === null)) {
                    canvas = c.getCanvas();
                    if (canvas !== null &amp;&amp; document.activeElement !== canvas.element) {
                        canvas.element.focus();
                    }

                    // if old focus onwer sits on canvas that doesn&#x27;t hold the native focus
                    // let&#x27;s clear it
                    if (this.focusOwner !== null &amp;&amp; this.focusOwner.getCanvas() !== canvas) {
                        this.requestFocus(null);
                    }
                } else if (this.focusOwner !== null &amp;&amp; this.focusOwner.isDOMElement !== true) {
                    // here we check if focus owner belongs to a canvas that has native focus
                    // and if it is not true we give native focus to the canvas
                    canvas = this.focusOwner.getCanvas();
                    if (canvas !== null &amp;&amp; document.activeElement !== canvas.element) {
                        canvas.element.focus();
                    }
                }
            },

            function pointerPressed(e){
                if (e.isAction()) {
                    // the problem is a target canvas element get mouse pressed
                    // event earlier than it gets focus what is inconsistent behavior
                    // to fix it a timer is used
                    if (document.activeElement !== e.source.getCanvas().element) {
                        var $this = this;
                        setTimeout(function() {
                            $this.requestFocus(e.source);
                        });
                    } else {
                        this.$$super(e);
                    }
                }
            }
        ]);
    }


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * HTML Canvas native DOM element wrapper.
     * @constructor
     * @param  {HTMLCanvas} [e] HTML canvas element to be wrapped as a zebkit UI
     * component or nothing to create a new canvas element
     * @class zebkit.ui.web.HtmlCanvas
     * @extends zebkit.ui.web.HtmlElement
     */
    pkg.HtmlCanvas = Class(pkg.HtmlElement,  [
        function(e) {
            if (arguments.length &gt; 0 &amp;&amp; e !== null &amp;&amp; e.tagName !== &quot;CANVAS&quot;) {
                throw new Error(&quot;Invalid element &#x27;&quot; + e + &quot;&#x27;&quot;);
            }

            /**
             * Keeps rectangular &quot;dirty&quot; area of the canvas component
             * @private
             * @attribute $da
             * @type {Object}
             *       { x:Integer, y:Integer, width:Integer, height:Integer }
             */
            this.$da = { x: 0, y: 0, width: -1, height: 0 };

            this.$super(arguments.length === 0  || e === null ? &quot;canvas&quot; : e);

            // let HTML Canvas be WEB event transparent
            this.$container.style[&quot;pointer-events&quot;] = &quot;none&quot;;

            // check if this element has been created
            if (arguments.length === 0 || e === null) {
                // prevent canvas selection
                this.element.onselectstart = function() { return false; };
            }
        },

        function $clazz() {
            this.$ContextMethods = {
                reset : function(w, h) {
                    this.$curState = 0;
                    var s = this.$states[0];
                    s.srot = s.rotateVal = s.x = s.y = s.width = s.height = s.dx = s.dy = 0;
                    s.crot = s.sx = s.sy = 1;
                    s.width = w;
                    s.height = h;
                    this.setFont(ui.font);
                    this.setColor(&quot;white&quot;);
                },

                $init : function() {
                    // pre-allocate canvas save $states stack
                    this.$states = Array(70);
                    for(var i=0; i &lt; this.$states.length; i++) {
                        var s = {};
                        s.srot = s.rotateVal = s.x = s.y = s.width = s.height = s.dx = s.dy = 0;
                        s.crot = s.sx = s.sy = 1;
                        this.$states[i] = s;
                    }
                },

                translate : function(dx, dy) {
                    if (dx !== 0 || dy !== 0) {
                        var c = this.$states[this.$curState];
                        c.x  -= dx;
                        c.y  -= dy;
                        c.dx += dx;
                        c.dy += dy;
                        this.$translate(dx, dy);
                    }
                },

                rotate : function(v) {
                    var c = this.$states[this.$curState];
                    c.rotateVal += v;
                    c.srot = Math.sin(c.rotateVal);
                    c.crot = Math.cos(c.rotateVal);
                    this.$rotate(v);
                },

                scale : function(sx, sy) {
                    var c = this.$states[this.$curState];
                    c.sx = c.sx * sx;
                    c.sy = c.sy * sy;
                    this.$scale(sx, sy);
                },

                save : function() {
                    this.$curState++;
                    var c = this.$states[this.$curState], cc = this.$states[this.$curState - 1];
                    c.x = cc.x;
                    c.y = cc.y;
                    c.width = cc.width;
                    c.height = cc.height;

                    c.dx = cc.dx;
                    c.dy = cc.dy;
                    c.sx = cc.sx;
                    c.sy = cc.sy;
                    c.srot = cc.srot;
                    c.crot = cc.crot;
                    c.rotateVal = cc.rotateVal;

                    this.$save();
                    return this.$curState - 1;
                },

                restoreAll : function() {
                    while(this.$curState &gt; 0) {
                        this.restore();
                    }
                },

                restore : function() {
                    if (this.$curState === 0) {
                        throw new Error(&quot;Context restore history is empty&quot;);
                    }

                    this.$curState--;
                    this.$restore();
                    return this.$curState;
                },

                clipRect : function(x,y,w,h){
                    var c = this.$states[this.$curState];
                    if (c.x !== x || y !== c.y || w !== c.width || h !== c.height) {
                        var xx = c.x, yy = c.y,
                            ww = c.width,
                            hh = c.height,
                            xw = x + w,
                            xxww = xx + ww,
                            yh = y + h,
                            yyhh = yy + hh;

                        c.x      = x &gt; xx ? x : xx;
                        c.width  = (xw &lt; xxww ? xw : xxww) - c.x;
                        c.y      = y &gt; yy ? y : yy;
                        c.height = (yh &lt; yyhh ? yh : yyhh) - c.y;

                        if (c.x !== xx || yy !== c.y || ww !== c.width || hh !== c.height) {
                            // begin path is very important to have proper clip area
                            this.beginPath();
                            this.rect(x, y, w, h);
                            this.closePath();
                            this.clip();
                        }
                    }
                }
            };
        },

        function $prototype(clazz) {
            this.$rotateValue = 0;
            this.$scaleX = 1;
            this.$scaleY = 1;

            /**
             *  Canvas context
             *  @attribute $context
             *  @private
             *  @type {CanvasRenderingContext2D}
             */
            this.$context = null;


            // set border for canvas has to be set as zebkit border, since canvas
            // is DOM component designed for rendering, so setting DOM border
            // doesn&#x27;t allow us to render zebkit border
            this.setBorder = function(b) {
                return ui.Panel.prototype.setBorder.call(this, b);
            };

            this.rotate = function(r) {
                this.$rotateValue += r;
                if (this.$context !== null) {
                    this.$context.rotate(r);
                }

                this.vrp();
                return this;
            };

            this.scale = function(sx, sy) {
                if (this.$context !== null) {
                    this.$context.scale(sx, sy);
                }
                this.$scaleX = this.$scaleX * sx;
                this.$scaleY = this.$scaleY * sy;
                this.vrp();
                return this;
            };

            this.clearTransformations = function() {
                this.$scaleX = 1;
                this.$scaleY = 1;
                this.$rotateValue = 0;
                if (this.$context !== null) {
                    this.$context = zebkit.web.$canvas(this.element, this.width, this.height, true);
                    this.$context.reset(this.width, this.height);
                }
                this.vrp();
                return this;
            };

            // set passing for canvas has to be set as zebkit padding, since canvas
            // is DOM component designed for rendering, so setting DOM padding
            // doesn&#x27;t allow us to hold painting area proper
            this.setPadding = function() {
                return ui.Panel.prototype.setPadding.apply(this, arguments);
            };

            this.setSize = function(w, h) {
                if (this.width !== w || h !== this.height) {
                    var pw  = this.width,
                        ph  = this.height;

                    this.$context = zebkit.web.$canvas(this.element, w, h);

                    // canvas has one instance of context, the code below
                    // test if the context has been already full filled
                    // with necessary methods and if it is not true
                    // fill it
                    if (typeof this.$context.$states === &quot;undefined&quot;) {
                        zebkit.web.$extendContext(this.$context, clazz.$ContextMethods);
                    }

                    this.$context.reset(w, h);

                    // if canvas has been rotated apply the rotation to the context
                    if (this.$rotateValue !== 0) {
                        this.$context.rotate(this.$rotateValue);
                    }

                    // if canvas has been scaled apply it to it
                    if (this.$scaleX !== 1 || this.$scaleY !== 1) {
                        this.$context.scale(this.$scaleX, this.$scaleY);
                    }

                    this.width  = w;
                    this.height = h;

                    // sync state of visibility
                    // TODO: probably it should e in html element manager, manager has
                    // to catch resize event and if size is not 0 correct visibility
                    // now manager doesn&#x27;t set style visibility to &quot;visible&quot; state
                    // if component size is zero
                    if (this.$container.style.visibility === &quot;hidden&quot;) {
                        if (this.isVisible) {
                            this.$container.style.visibility = &quot;visible&quot;;
                        }
                    }

                    this.invalidate();

                    // TODO: think to replace it with vrp()
                    this.validate();
                    this.repaint();

                    if (w !== pw || h !== ph) {
                        this.resized(pw, ph);
                    }
                }
                return this;
            };
        }
    ]);

    /**
     * Class that wrapped window component with own HTML Canvas.
     * @param  {zebkit.ui.Window} [target] a window component. If target is not defined
     * it will be instantiated automatically. If the component is not passed the new
     * window component (zebkit.ui.Window) will be created.
     * @constructor
     * @extends zebkit.ui.web.HtmlCanvas
     * @class zebkit.ui.web.HtmlWinCanvas
     */
    pkg.HtmlWinCanvas = Class(pkg.HtmlCanvas, [
        function $prototype() {
            this.winOpened = function(e) {
                this.target.winOpened(e);
            };

            this.winActivated = function(e){
                this.target.winActivated(e);
            };
        },

        function(target) {
            this.$super();

            /**
             * Target window
             * @attribute target
             * @type {zebkit.ui.Window}
             * @readOnly
             */
            this.target = (arguments.length === 0 ? new ui.Window() : target);

            var $this = this;
            target.getWinContainer = function() {
                return $this;
            };

            this.setLayout(new zebkit.layout.BorderLayout());
            this.add(&quot;center&quot;, target);
        }
    ]);

    /**
     * WEB based HTML components wrapped with as zebkit components.
     * @class zebkit.ui.web.HtmlFocusableElement
     * @constructor
     * @extends zebkit.ui.web.HtmlElement
     */
    pkg.HtmlFocusableElement = Class(pkg.HtmlElement, [
        function $prototype() {
            this.$getElementRootFocus = function() {
                return this.element;
            };
        }
    ]);

    /**
     * HTML input element wrapper class. The class can be used as basis class
     * to wrap HTML elements that can be used to enter a textual information.
     * @constructor
     * @param {String} text a text the text input component has to be filled with
     * @param {String} element an input element name
     * @class zebkit.ui.web.HtmlTextInput
     * @extends zebkit.ui.web.HtmlElement
     */
    pkg.HtmlTextInput = Class(pkg.HtmlFocusableElement, [
        function(text, e) {
            if (text === null) {
                text = &quot;&quot;;
            }
            this.$super(e);
            this.setAttribute(&quot;tabindex&quot;, 0);
            this.setValue(text);
        },

        function $prototype() {
            this.cursorType = ui.Cursor.TEXT;

            /**
             * Get a text of the text input element
             * @return {String} a text of the  text input element
             * @method getValue
             */
            this.getValue = function() {
                return this.element.value.toString();
            };

            /**
             * Set the text
             * @param {String} t a text
             * @method setValue
             * @chainable
             */
            this.setValue = function(t) {
                if (this.element.value !== t) {
                    this.element.value = t;
                    this.vrp();
                }
                return this;
            };
        }
    ]);

    /**
     * HTML input text element wrapper class. The class wraps standard HTML text field
     * and represents it as zebkit UI component.
     * @constructor
     * @class zebkit.ui.web.HtmlTextField
     * @param {String} [text] a text the text field component has to be filled with
     * @extends zebkit.ui.web.HtmlTextInput
     */
    pkg.HtmlTextField = Class(pkg.HtmlTextInput, [
        function(text) {
            this.$super(text, &quot;input&quot;);
            this.element.setAttribute(&quot;type&quot;,  &quot;text&quot;);
        }
    ]);

    /**
     * HTML input text area element wrapper class. The class wraps standard HTML text area
     * element and represents it as zebkit UI component.
     * @constructor
     * @param {String} [text] a text the text area component has to be filled with
     * @class zebkit.ui.web.HtmlTextArea
     * @extends zebkit.ui.web.HtmlTextInput
     */
    pkg.HtmlTextArea = Class(pkg.HtmlTextInput, [
        function(text) {
            this.$super(text, &quot;textarea&quot;);
            this.element.setAttribute(&quot;rows&quot;, 10);
        },

        /**
         * Set the text area resizeable or not resizeable.
         * @param {Boolean} b true to make the text area component resizeable
         * @method setResizeable
         * @chainable
         */
        function setResizeable(b) {
            this.setStyle(&quot;resize&quot;, b === false ? &quot;none&quot; : &quot;both&quot;);
            return this;
        }
    ]);

    /**
     * HTML Link component.
     * @param  {String} text  a text of link
     * @param  {String} [href] an href of the link
     * @extends zebkit.ui.web.HtmlElement
     * @class zebkit.ui.web.HtmlLink
     * @constructor
     * @event fired
     * @param {zebkit.ui.web.Link} src a link that has been pressed
     */
    pkg.HtmlLink = Class(pkg.HtmlElement, [
        function(text, href) {
            this.$super(&quot;a&quot;);
            this.setContent(text);
            this.setAttribute(&quot;href&quot;, arguments.length &lt; 2 ? &quot;#&quot;: href);
            this._ = new zebkit.util.Listeners();
            var $this = this;
            this.element.onclick = function(e) {
                $this._.fired($this);
            };
        }
    ]);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * The base class for HTML developing HTML layers.
     * @class zebkit.ui.web.HtmlLayer
     * @constructor
     * @extends zebkit.ui.web.HtmlCanvas
     */
    pkg.HtmlLayer = Class(pkg.HtmlCanvas, []);

    /**
     *  Root layer implementation. This is the simplest UI layer implementation
     *  where the layer always try grabbing all input event
     *  @class zebkit.ui.web.RootLayer
     *  @constructor
     *  @extends zebkit.ui.web.HtmlLayer
     *  @uses zebkit.ui.RootLayerMix
     */
    pkg.RootLayer = Class(pkg.HtmlLayer, ui.RootLayerMix, [
        function $clazz() {
            this.layout = new zebkit.layout.RasterLayout();
        }
    ]);

    /**
     *  Window layer implementation.
     *  @class zebkit.ui.web.WinLayer
     *  @constructor
     *  @extends zebkit.ui.web.HtmlLayer
     *  @uses zebkit.ui.WinLayerMix
     */
    pkg.WinLayer = Class(pkg.HtmlLayer, ui.WinLayerMix, [
        function() {
            this.$super();

            // TODO: why 1000 and how to avoid z-index manipulation
            // the layer has to be placed above other elements that are virtually
            // inserted in the layer
            this.element.style[&quot;z-index&quot;] = 10000;
        },

        function $clazz() {
            this.layout = new zebkit.layout.RasterLayout();
        }
    ]);

    /**
     *  Popup layer implementation.
     *  @class zebkit.ui.web.PopupLayer
     *  @constructor
     *  @extends zebkit.ui.web.HtmlLayer
     *  @uses zebkit.ui.PopupLayerMix
     */
    pkg.PopupLayer = Class(pkg.HtmlLayer, ui.PopupLayerMix, [
        function $clazz() {
            this.layout = new ui.PopupLayerLayout([
                function doLayout(target){
                    // TODO:
                    // prove of concept. if layer is active don&#x27;t allow WEB events comes to upper layer
                    // since there can be another HtmlElement that should not be part of interaction
                    if (target.kids.length &gt; 0) {
                        if (target.$container.style[&quot;pointer-events&quot;] !== &quot;auto&quot;) {
                            target.$container.style[&quot;pointer-events&quot;] = &quot;auto&quot;;
                        }
                    } else if (target.$container.style[&quot;pointer-events&quot;] !== &quot;none&quot;) {
                        target.$container.style[&quot;pointer-events&quot;] = &quot;none&quot;;  // make the layer transparent for pointer events
                    }

                    this.$super(target);
                }
            ]);
        }
    ]);


    // TODO: dependencies to remove
    //     -- taskSets (util.js)

    pkg.CanvasEvent = Class(zebkit.util.Event, []);

    var ui = pkg.cd(&quot;..&quot;),
        COMP_EVENT = new ui.event.CompEvent();

    // keep pointer owners (the component where cursor/finger placed in)
    pkg.$pointerOwner        = {};
    pkg.$pointerPressedOwner = {};

    /**
     *  zCanvas zebkit UI component class. This is starting point for building zebkit UI. The class is a wrapper
     *  for HTML5 Canvas element. The main goals of the class is catching all native HTML5 Canvas element  events
     *  and translating its into Zebkit UI events.
     *
     *  zCanvas instantiation can trigger a new HTML Canvas will be created and added to HTML DOM tree.
     *  It happens if developer doesn&#x27;t pass an HTML Canvas element reference or an ID of existing HTML
     *  Canvas element. To re-use an existent in DOM tree HTML5 canvas element pass an id of the canvas
     *  element:

            // a new HTML canvas element is created and added into HTML DOM tree
            var canvas = zebkit.ui.zCanvas();

            // a new HTML canvas element is created into HTML DOM tree
            var canvas = zebkit.ui.zCanvas(400,500);  // pass canvas size

            // stick to existent HTML canvas element
            var canvas = zebkit.ui.zCanvas(&quot;ExistentCanvasID&quot;);

     *  zCanvas has layered structure. Every layer is responsible for showing and controlling a dedicated
     *  type of UI elements like windows pop-up menus, tool tips and so on. To start building UI use root layer.
     *  The layer is standard zebkit UI panel that is accessible via &quot;root&quot; zCanvas field:

            // create canvas
            var canvas = zebkit.ui.zCanvas(400,500);

            // save reference to canvas root layer where
            // hierarchy of UI components have to be hosted
            var root = canvas.root;

            // fill root with UI components
            var label = new zebkit.ui.Label(&quot;Label&quot;);
            label.setBounds(10,10,100,50);
            root.add(label);

     *  @class zebkit.ui.zCanvas
     *  @extends zebkit.ui.web.HtmlCanvas
     *  @constructor
     *  @param {String|Canvas} [element] an ID of a HTML canvas element or reference to an HTML Canvas element.
     *  @param {Integer} [width] a width of an HTML canvas element
     *  @param {Integer} [height] a height of an HTML canvas element
     */

    /**
     * Implement the event handler method  to catch canvas initialized event. The event is triggered once the
     * canvas has been initiated and all properties listeners of the canvas are set upped. The event can be
     * used to load saved data.

         var p = new zebkit.ui.zCanvas(300, 300, [
              function canvasInitialized() {
                  // do something
              }
         ]);

     * @event  canvasInitialized
     */
    ui.zCanvas = pkg.zCanvas = Class(pkg.HtmlCanvas, [
        function(element, w, h) {
            // no arguments
            if (arguments.length === 0) {
                w = 400;
                h = 400;
                element = null;
            } else if (arguments.length === 1) {
                w = -1;
                h = -1;
            } else if (arguments.length === 2) {
                h = w;
                w = element;
                element = null;
            }

            // if passed element is string than consider it as
            // an ID of an element that is already in DOM tree
            if (element !== null &amp;&amp; zebkit.isString(element)) {
                var id = element;
                element = document.getElementById(id);

                // no canvas can be detected
                if (element === null) {
                    throw new Error(&quot;Canvas id=&#x27;&quot; + id + &quot;&#x27; element cannot be found&quot;);
                }
            }

            /**
             * Dictionary to track layers by its ids.
             * @attribute $layers
             * @private
             * @type {Object}
             */
            this.$layers = {};

            this.$super(element);


            // since zCanvas is top level element it doesn&#x27;t have to have
            // absolute position
            this.$container.style.position = &quot;relative&quot;;

            // let canvas zCanvas listen WEB event
            this.$container.style[&quot;pointer-events&quot;] = &quot;auto&quot;;

            // if canvas is not yet part of HTML let&#x27;s attach it to
            // body.
            if (this.$container.parentNode === null) {
                document.body.appendChild(this.$container);
            }

            // force canvas to have a focus
            if (this.element.getAttribute(&quot;tabindex&quot;) === null) {
                this.element.setAttribute(&quot;tabindex&quot;, &quot;1&quot;);
            }

            if (w &lt; 0) {
                w = this.element.offsetWidth;
            }

            if (h &lt; 0) {
                h = this.element.offsetHeight;
            }

            // !!!
            // save canvas in list of created Zebkit canvases
            // do it before calling setSize(w,h) method
            this.clazz.$canvases.push(this);

            this.setSize(w, h);

            // sync canvas visibility with what canvas style says
            var cvis = (this.element.style.visibility === &quot;hidden&quot; ? false : true);
            if (this.isVisible !== cvis) {
                this.setVisible(cvis);
            }

            // call event method if it is defined
            if (typeof this.canvasInitialized !== &#x27;undefined&#x27;) {
                this.canvasInitialized();
            }

            //var $this = this;

            // this method should clean focus if
            // one of of a child DOM element gets focus
            zebkit.web.$focusin(this.$container, function(e) {
                // TODO: fix and uncomment
                // if (e.target !== $this.$container &amp;&amp;
                //     e.target.parentNode !== null &amp;&amp;
                //     e.target.parentNode.getAttribute(&quot;data-zebcont&quot;) === null) // TODO: BUG, data-zebcont is not set anymore, use $canvases instead
                // {
                //     ui.focusManager.requestFocus(null);
                // } else {
                //     // clear focus if a focus owner component is hosted with another zCanvas
                //     if (e.target === $this.$container &amp;&amp;
                //         ui.focusManager.focusOwner !== null &amp;&amp;
                //         ui.focusManager.focusOwner.getCanvas() !== $this)
                //     {
                //         ui.focusManager.requestFocus(null);
                //     }
                // }
            }, true);
        },

        function $clazz () {
            this.CLASS_NAME = &quot;zebcanvas&quot;;
            this.$canvases  = [];

            this.$getCanvasByElement = function(e) {
                for (var i = 0; i &lt; this.$canvases.length; i++) {
                    if (this.$canvases[i] === e) {
                        return this.$canvases[i];
                    }
                }
                return null;
            };
        },

        function $prototype() {
            /**
             * Indicates this the root canvas element
             * @attribute $isRootCanvas
             * @type {Boolean}
             * @private
             * @default true
             * @readOnly
             */
            this.$isRootCanvas = true;

            /**
             * Indicate if the canvas has to be stretched to fill the whole view port area.
             * @type {Boolean}
             * @attribute isSizeFull
             * @readOnly
             */
            this.isSizeFull = false;


            this.offx = this.offy = 0;

            /**
             * Transforms the pageX coordinate into relatively to the canvas origin
             * coordinate taking in account the canvas transformation
             * @param  {Number} pageX a pageX coordinate
             * @param  {Number} pageY a pageY coordinate
             * @return {Integer} an x coordinate that is relative to the canvas origin
             * @method $toElementX
             * @protected
             */
            this.$toElementX = function(pageX, pageY) {
                // offset has to be added here since &quot;calcOffset&quot; can called (for instance page reloading)
                // to early

                pageX -= (this.offx);
                pageY -= (this.offy);

                var c = this.$context.$states[this.$context.$curState];
                return ((c.sx !== 1 || c.sy !== 1 || c.rotateVal !== 0) ? Math.round((c.crot * pageX + pageY * c.srot)/c.sx)
                                                                        : pageX) - c.dx;
            };

            /**
             * Transforms the pageY coordinate into relatively to the canvas origin
             * coordinate taking in account the canvas transformation
             * @param  {Number} pageX a pageX coordinate
             * @param  {Number} pageY a pageY coordinate
             * @return {Integer} an y coordinate that is relative to the canvas origin
             * @method $toElementY
             * @protected
             */
            this.$toElementY = function(pageX, pageY) {
                // offset has to be added here since &quot;calcOffset&quot; can called (for instance page reloading)
                // to early
                pageX -= (this.offx);
                pageY -= (this.offy);

                var c = this.$context.$states[this.$context.$curState];
                return ((c.sx !== 1 || c.sy !== 1 || c.rotateVal !== 0) ? Math.round((pageY * c.crot - c.srot * pageX)/c.sy)
                                                                        : pageY) - c.dy;
            };

            this.load = function(jsonPath){
                return this.root.load(jsonPath);
            };

            // TODO: may be rename to dedicated method $doWheelScroll
            this.$doScroll = function(dx, dy, src) {
                if (src === &quot;wheel&quot; &amp;&amp; pkg.$pointerOwner.mouse != null) {
                    var owner = pkg.$pointerOwner.mouse;
                    while (owner !== null &amp;&amp; typeof owner.doScroll === &#x27;undefined&#x27;) {
                        owner = owner.parent;
                    }

                    if (owner !== null) {
                        return owner.doScroll(dx, dy, src);
                    }
                }
                return false;
            };

            /**
             * Catches key typed events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.event.KeyEvent} e an event
             * @private
             * @method $keyTyped
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyTyped = function(e) {
                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire(&quot;keyTyped&quot;, e);
                } else {
                    return false;
                }
            };

            /**
             * Catches key pressed events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.event.KeyEvent} e an event
             * @private
             * @method $keyPressed
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyPressed = function(e) {
                for(var i = this.kids.length - 1;i &gt;= 0; i--){
                    var l = this.kids[i];
                    if (typeof l.layerKeyPressed !== &#x27;undefined&#x27; &amp;&amp; l.layerKeyPressed(e) === true) {
                        return true;
                    }
                }

                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire(&quot;keyPressed&quot;, e);
                } else {
                    e.source = this;
                    return ui.events.fire(&quot;keyPressed&quot;, e);
                }
            };

            /**
             * Catches key released events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.event.KeyEvent} e an event
             * @private
             * @method $keyReleased
             * @return {Boolean}  true if the event has been processed
             */
            this.$keyReleased = function(e){
                if (ui.focusManager.focusOwner !== null) {
                    e.source = ui.focusManager.focusOwner;
                    return ui.events.fire(&quot;keyReleased&quot;, e);
                } else {
                    return false;
                }
            };

            /**
             * Catches pointer entered events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerEntered
             */
            this.$pointerEntered = function(e) {
                // TODO: review it quick and dirty fix try to track a situation
                //       when the canvas has been moved
                this.recalcOffset();

                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y),
                    o = pkg.$pointerOwner[e.identifier];

                // also correct current component on that  pointer is located
                if (d !== o) {
                    // if pointer owner is not null but doesn&#x27;t match new owner
                    // generate pointer exit and clean pointer owner
                    if (o != null) {
                        pkg.$pointerOwner[e.identifier] = null;
                        ui.events.fire(&quot;pointerExited&quot;, e.update(o, x, y));
                    }

                    // if new pointer owner is not null and enabled
                    // generate pointer entered event ans set new pointer owner
                    if (d !== null &amp;&amp; d.isEnabled === true){
                        pkg.$pointerOwner[e.identifier] = d;
                        ui.events.fire(&quot;pointerEntered&quot;, e.update(d, x, y));
                    }
                }
            };

            /**
             * Catches pointer exited events, adjusts and distributes it to UI hierarchy
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerExited
             */
            this.$pointerExited = function(e) {
                var o = pkg.$pointerOwner[e.identifier];
                if (o != null) {
                    pkg.$pointerOwner[e.identifier] = null;
                    return ui.events.fire(&quot;pointerExited&quot;, e.update(o,
                                                                          this.$toElementX(e.pageX, e.pageY),
                                                                          this.$toElementY(e.pageX, e.pageY)));
                }
            };

            /**
             * Catches pointer moved events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerMoved
             */
            this.$pointerMoved = function(e){
                // if a pointer button has not been pressed handle the normal pointer moved event
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y),
                    o = pkg.$pointerOwner[e.identifier],
                    b = false;

                // check if pointer already inside a component
                if (o != null) {
                    if (d !== o) {
                        pkg.$pointerOwner[e.identifier] = null;
                        b = ui.events.fire(&quot;pointerExited&quot;, e.update(o, x, y));

                        if (d != null &amp;&amp; d.isEnabled === true) {
                            pkg.$pointerOwner[e.identifier] = d;
                            b = ui.events.fire(&quot;pointerEntered&quot;, e.update(d, x, y)) || b;
                        }
                    } else {
                        if (d !== null &amp;&amp; d.isEnabled === true) {
                            b = ui.events.fire(&quot;pointerMoved&quot;, e.update(d, x, y));
                        }
                    }
                } else {
                    if (d !== null &amp;&amp; d.isEnabled === true) {
                        pkg.$pointerOwner[e.identifier] = d;
                        b = ui.events.fire(&quot;pointerEntered&quot;, e.update(d, x, y));
                    }
                }

                return b;
            };

            /**
             * Catches pointer drag started events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerDragStarted
             */
            this.$pointerDragStarted = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                // if target component can be detected fire pointer start dragging and
                // pointer dragged events to the component
                if (d !== null &amp;&amp; d.isEnabled === true) {
                    return ui.events.fire(&quot;pointerDragStarted&quot;, e.update(d, x, y));
                }

                return false;
            };

            /**
             * Catches pointer dragged events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerDragged
             */
            this.$pointerDragged = function(e){
                if (pkg.$pointerOwner[e.identifier] != null) {
                    return ui.events.fire(&quot;pointerDragged&quot;, e.update(pkg.$pointerOwner[e.identifier],
                                                                           this.$toElementX(e.pageX, e.pageY),
                                                                           this.$toElementY(e.pageX, e.pageY)));
                }

                return false;
            };

            /**
             * Catches pointer drag ended events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerDragEnded
             */
            this.$pointerDragEnded = function(e) {
                if (pkg.$pointerOwner[e.identifier] != null) {
                    return ui.events.fire(&quot;pointerDragEnded&quot;, e.update(pkg.$pointerOwner[e.identifier],
                                                                             this.$toElementX(e.pageX, e.pageY),
                                                                             this.$toElementY(e.pageX, e.pageY)));
                }
                return false;
            };

            this.$isBlockedByLayer = function(id, method, e) {
                // adjust event for passing it to layers
                // e.x = x;
                // e.y = y;

                for(var i = this.kids.length - 1; i &gt;= 0; i--){
                    var layer = this.kids[i];
                    if (typeof layer[method] !== &#x27;undefined&#x27;) {
                        e.id = id;
                        if (layer[method](e) === true) {
                            return true;
                        }
                    }
                }
                return false;
            };

            /**
             * Catches pointer clicked events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerClicked
             */
            this.$pointerClicked = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                // zoom inn zoom out can bring to a situation
                // d is null, in this case offset should be recalculated
                // TODO: the cause of the issue has to be investigated deeper
                if (d === null) {
                    this.recalcOffset();
                    x = this.$toElementX(e.pageX, e.pageY);
                    y = this.$toElementY(e.pageX, e.pageY);
                    d = this.getComponentAt(x, y);
                }

                if (d !== null) {
                    e = e.update(d, x, y);
                    if (this.$isBlockedByLayer(&quot;pointerClicked&quot;, &quot;layerPointerClicked&quot;, e)) {
                        return true;
                    } else {
                        return ui.events.fire(&quot;pointerClicked&quot;, e);
                    }
                } else {
                    return false;
                }
            };

            this.$pointerDoubleClicked = function(e) {
                var x = this.$toElementX(e.pageX, e.pageY),
                    y = this.$toElementY(e.pageX, e.pageY),
                    d = this.getComponentAt(x, y);

                return d !== null ? ui.events.fire(&quot;pointerDoubleClicked&quot;, e.update(d, x, y))
                                  : false;
            };

            /**
             * Catches pointer released events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerReleased
             */
            this.$pointerReleased = function(e) {
                var x  = this.$toElementX(e.pageX, e.pageY),
                    y  = this.$toElementY(e.pageX, e.pageY),
                    pp = pkg.$pointerPressedOwner[e.identifier];

                // release pressed state
                if (pp != null) {
                    try {
                        e = e.update(pp, x, y);
                        if (this.$isBlockedByLayer(&quot;pointerReleased&quot;, &quot;layerPointerReleased&quot;, e) !== true) {
                            ui.events.fire(&quot;pointerReleased&quot;, e);
                        }
                    } finally {
                        delete pkg.$pointerPressedOwner[e.identifier];
                    }
                }

                // mouse released can happen at new location, so move owner has to be corrected
                // and mouse exited entered event has to be generated.
                // the correction takes effect if we have just completed dragging or mouse pressed
                // event target doesn&#x27;t match pkg.$pointerOwner
                if (e.pointerType === &quot;mouse&quot; &amp;&amp; (e.pressPageX !== e.pageX || e.pressPageY !== e.pageY)) {
                    var nd = this.getComponentAt(x, y),
                        po = this.getComponentAt(this.$toElementX(e.pressPageX, e.pressPageY),
                                                 this.$toElementY(e.pressPageX, e.pressPageY));

                    if (nd !== po) {
                        if (po !== null) {
                            pkg.$pointerOwner[e.identifier] = null;
                            ui.events.fire(&quot;pointerExited&quot;, e.update(po, x, y));
                        }

                        if (nd !== null &amp;&amp; nd.isEnabled === true){
                            pkg.$pointerOwner[e.identifier] = nd;
                            ui.events.fire(&quot;pointerEntered&quot;, e.update(nd, x, y));
                        }
                    }
                }
            };

            /**
             * Catches pointer pressed events, adjusts and distributes it to UI hierarchy.
             * @param  {zebkit.ui.event.PointerEvent} e an event
             * @private
             * @method $pointerPressed
             */
            this.$pointerPressed = function(e) {
                var x  = this.$toElementX(e.pageX, e.pageY),
                    y  = this.$toElementY(e.pageX, e.pageY),
                    pp = pkg.$pointerPressedOwner[e.identifier];

                // free pointer prev pressed if any
                if (pp != null) {
                    try {
                        ui.events.fire(&quot;pointerReleased&quot;, e.update(pp, x, y));
                    } finally {
                        delete pkg.$pointerPressedOwner[e.identifier];
                    }
                }

                e.source = null;
                e.x = x;
                e.y = y;
                if (this.$isBlockedByLayer(&quot;pointerPressed&quot;, &quot;layerPointerPressed&quot;, e)) {
                    return true;
                }

                var d = this.getComponentAt(x, y);
                if (d !== null &amp;&amp; d.isEnabled === true) {
                    if (pkg.$pointerOwner[e.identifier] !== d) {
                        pkg.$pointerOwner[e.identifier] = d;
                        ui.events.fire(&quot;pointerEntered&quot;,  e.update(d, x, y));
                    }

                    pkg.$pointerPressedOwner[e.identifier] = d;

                    // TODO: prove the solution (return true) !?
                    if (ui.events.fire(&quot;pointerPressed&quot;, e.update(d, x, y)) === true) {
                        delete pkg.$pointerPressedOwner[e.identifier];
                        return true;
                    }
                }

                return false;
            };

            this.getComponentAt = function(x, y) {
                for(var i = this.kids.length; --i &gt;= 0; ){
                    var c = this.kids[i].getComponentAt(x, y);
                    if (c !== null) {
                        var p = c;
                        while ((p = p.parent) !== null) {
                            if (typeof p.catchInput !== &#x27;undefined&#x27; &amp;&amp; (p.catchInput === true || (p.catchInput !== false &amp;&amp; p.catchInput(c)))) {
                                c = p;
                            }
                        }
                        return c;
                    }
                }
                return null;
            };

            this.recalcOffset = function() {
                // calculate the DOM element offset relative to window taking in account scrolling
                var poffx = this.offx,
                    poffy = this.offy,
                    ba    = this.$container.getBoundingClientRect();

                this.offx = Math.round(ba.left + zebkit.web.$measure(this.$container, &quot;border-left-width&quot;) +
                                                 zebkit.web.$measure(this.$container, &quot;padding-left&quot;) + window.pageXOffset);
                this.offy = Math.round(ba.top +  zebkit.web.$measure(this.$container, &quot;padding-top&quot; ) +
                                                 zebkit.web.$measure(this.$container, &quot;border-top-width&quot;) + window.pageYOffset);

                if (this.offx !== poffx || this.offy !== poffy) {
                    // force to fire component re-located event
                    this.relocated(this, poffx, poffy);
                }
            };

            /**
             * Get the canvas layer by the specified layer ID. Layer is a children component
             * of the canvas UI component. Every layer has an ID assigned to it the method
             * actually allows developers to get the canvas children component by its ID
             * @param  {String} id a layer ID
             * @return {zebkit.ui.Panel} a layer (children) component
             * @method getLayer
             */
            this.getLayer = function(id) {
                return this.$layers[id];
            };

            // override relocated and resized
            // to prevent unnecessary repainting
            this.relocated = function(px,py) {
                COMP_EVENT.source = this;
                COMP_EVENT.px     = px;
                COMP_EVENT.py     = py;
                ui.events.fire(&quot;compMoved&quot;, COMP_EVENT);
            };

            this.resized = function(pw,ph) {
                COMP_EVENT.source = this;
                COMP_EVENT.prevWidth  = pw;
                COMP_EVENT.prevHeight = ph;
                ui.events.fire(&quot;compSized&quot;, COMP_EVENT);
                // don&#x27;t forget repaint it
                this.repaint();
            };

            this.$initListeners = function() {
                // TODO: hard-coded
                new zebkit.web.PointerEventUnifier(this.$container, this);
                new zebkit.web.KeyEventUnifier(this.element, this); // element has to be used since canvas is
                                                             // styled to have focus and get key events
                new zebkit.web.MouseWheelSupport(this.$container, this);
            };

            /**
             * Force the canvas to occupy the all available view port area
             * @param {Boolean} b true to force the canvas be stretched over all
             * available view port area
             * @chainable
             * @method setSizeFull
             */
            this.setSizeFull = function(b) {
                if (this.isSizeFull !== b) {
                    this.isSizeFull = b;

                    if (b === true) {
                        if (zebkit.web.$contains(this.$container) !== true) {
                            throw new Error(&quot;zCanvas is not a part of DOM tree&quot;);
                        }

                        this.setLocation(0, 0);

                        // adjust body to kill unnecessary gap for inline-block zCanvas element
                        // otherwise body size will be slightly horizontally bigger than visual
                        // viewport height what causes scroller appears
                        document.body.style[&quot;font-size&quot;] = &quot;0px&quot;;

                        var ws = zebkit.web.$viewPortSize();
                        this.setSize(ws.width, ws.height);
                    }
                }
            };
        },

        function setSize(w, h) {
            if (this.width !== w || h !== this.height) {
                this.$super(w, h);

                // let know to other zebkit canvases that
                // the size of an element on the page has
                // been updated and they have to correct
                // its anchor.
                pkg.$elBoundsUpdated();
            }
            return this;
        },

        function setVisible(b) {
            var prev = this.isVisible;
            this.$super(b);

            // Since zCanvas has no parent component calling the super
            // method above doesn&#x27;t trigger repainting. So, do it here.
            if (b !== prev) {
                this.repaint();
            }
            return this;
        },

        function vrp() {
            this.$super();
            if (zebkit.web.$contains(this.element) &amp;&amp; this.element.style.visibility === &quot;visible&quot;) {
                this.repaint();
            }
        },

        function kidAdded(i,constr,c){
            if (this.$layers.hasOwnProperty(c.id)) {
                throw new Error(&quot;Layer &#x27;&quot; + c.id + &quot;&#x27; already exist&quot;);
            }

            this.$layers[c.id] = c;
            if (c.id === &quot;root&quot;) {
                this.root = c;
            }

            this.$super(i, constr, c);
        },

        function kidRemoved(i, c){
            delete this.$layers[c.id];
            if (c.id === &quot;root&quot;) {
                this.root = null;
            }
            this.$super(i, c);
        }
    ]);

    // canvases location has to be corrected if document layout is invalid
    pkg.$elBoundsUpdated = function() {
        for(var i = pkg.zCanvas.$canvases.length - 1; i &gt;= 0; i--) {
            var c = pkg.zCanvas.$canvases[i];
            if (c.isSizeFull === true) {
                //c.setLocation(window.pageXOffset, -window.pageYOffset);

                var ws = zebkit.web.$viewPortSize();

                // browser (mobile) can reduce size of browser window by
                // the area a virtual keyboard occupies. Usually the
                // content scrolls up to the size the VK occupies, so
                // to leave zebkit full screen content in the window
                // with the real size (not reduced) size take in account
                // scrolled metrics
                c.setSize(ws.width  + window.pageXOffset,
                          ws.height + window.pageYOffset);
            }
            c.recalcOffset();
        }
    };

    var $wrt = null, $winSizeUpdated = false, $wpw = -1, $wph = -1;
    window.addEventListener(&quot;resize&quot;, function(e) {
        if ($wpw !== window.innerWidth || $wph !== window.innerHeight) {
            $wpw = window.innerWidth;
            $wph = window.innerHeight;

            if ($wrt !== null) {
                $winSizeUpdated = true;
            } else {
                $wrt = zebkit.util.tasksSet.run(
                    function() {
                        if ($winSizeUpdated === false) {
                            pkg.$elBoundsUpdated();
                            this.shutdown();
                            $wrt = null;
                        }
                        $winSizeUpdated = false;
                    }, 200, 150
                );
            }
        }
    }, false);

    window.onbeforeunload = function(e) {
        var msgs = [];
        for(var i = pkg.zCanvas.$canvases.length - 1; i &gt;= 0; i--) {
            if (typeof pkg.zCanvas.$canvases[i].saveBeforeLeave !== &#x27;undefined&#x27;) {
                var m = pkg.zCanvas.$canvases[i].saveBeforeLeave();
                if (m != null) {
                    msgs.push(m);
                }
            }
        }

        if (msgs.length &gt; 0) {
            var message = msgs.join(&quot;  &quot;);
            if (typeof e === &#x27;undefined&#x27;) {
                e = window.event;
            }

            if (e) {
                e.returnValue = message;
            }

            return message;
        }
    };

    // TODO: this is depricated events that can have significant impact to
    // page performance. That means it has to be removed and replace with soemting
    // else
    //
    // bunch of handlers to track HTML page metrics update
    // it is necessary since to correct zebkit canvases anchor
    // and track when a canvas has been removed
    document.addEventListener(&quot;DOMNodeInserted&quot;, function(e) {
        pkg.$elBoundsUpdated();
    }, false);

    document.addEventListener(&quot;DOMNodeRemoved&quot;, function(e) {
        // remove canvas from list
        for(var i = pkg.zCanvas.$canvases.length - 1; i &gt;= 0; i--) {
            var canvas = pkg.zCanvas.$canvases[i];
            if (zebkit.web.$contains(canvas.element) !== true) {
                pkg.zCanvas.$canvases.splice(i, 1);
                if (typeof canvas.saveBeforeLeave !== &#x27;undefined&#x27;) {
                    canvas.saveBeforeLeave();
                }
            }
        }

        pkg.$elBoundsUpdated();
    }, false);


    var ui = pkg.cd(&quot;..&quot;);

    /**
     * Simple video panel that can be used to play a video:
     *

            // create canvas, add video panel to the center and
            // play video
            var canvas = zebkit.ui.zCanvas(500,500).root.properties({
                layout: new zebkit.layout.BorderLayout(),
                center: new zebkit.ui.web.VideoPan(&quot;trailer.mpg&quot;)
            });

     *
     * @param {String} url an URL to a video
     * @class zebkit.ui.web.VideoPan
     * @extends zebkit.ui.Panel
     * @constructor
     */
    pkg.VideoPan = Class(ui.Panel,  [
        function(src) {
            var $this = this;

            /**
             * Original video DOM element that is created
             * to play video
             * @type {Video}
             * @readOnly
             * @attribute video
             */
            this.video  = document.createElement(&quot;video&quot;);
            this.source = document.createElement(&quot;source&quot;);
            this.source.setAttribute(&quot;src&quot;, src);
            this.video.appendChild(this.source);

            this.$super();

            // canplaythrough is video event
            this.video.addEventListener(&quot;canplaythrough&quot;, function() {
                $this._.playbackStateUpdated($this, &quot;ready&quot;);
                $this.repaint();
                $this.$continuePlayback();
            }, false);

            this.video.addEventListener(&quot;ended&quot;, function() {
                $this._.playbackStateUpdated($this, &quot;end&quot;);
                $this.$interruptCancelTask();
            }, false);

            this.video.addEventListener(&quot;pause&quot;, function() {
                $this._.playbackStateUpdated($this, &quot;pause&quot;);
                $this.$interruptCancelTask();
            }, false);

            this.video.addEventListener(&quot;play&quot;, function() {
                $this.$continuePlayback();
                $this._.playbackStateUpdated($this, &quot;play&quot;);
            }, false);

            // progress event indicates a loading progress
            // the event is useful to detect recovering from network
            // error
            this.video.addEventListener(&quot;progress&quot;, function() {
                // if playback has been postponed due to an error
                // let&#x27;s say that problem seems fixed and delete
                // the cancel task
                if ($this.$cancelTask !== null) {
                    $this.$interruptCancelTask();

                    // detect if progress event has to try to start animation that has not been
                    // started yet or has been canceled for a some reason
                    if ($this.video.paused === false) {
                        $this.$continuePlayback();
                        $this._.playbackStateUpdated($this, &quot;continue&quot;);
                    }
                }
            }, false);

            this.source.addEventListener(&quot;error&quot;, function(e) {
                $this.$interruptCancelTask();
                $this.$lastError = e.toString();
                $this._.playbackStateUpdated($this, &quot;error&quot;);
                $this.repaint();
                $this.pause();
            }, false);

            this.video.addEventListener(&quot;stalled&quot;, function() {
                $this.$cancelPlayback();
            }, false);

            this.video.addEventListener(&quot;loadedmetadata&quot;, function (e) {
                $this.videoWidth   = this.videoWidth;
                $this.videoHeight  = this.videoHeight;
                $this.$aspectRatio = $this.videoHeight &gt; 0 ? $this.videoWidth / $this.videoHeight : 0;
                $this.vrp();
            }, false);
        },

        function $clazz() {
            this.Listeners = zebkit.util.ListenersClass(&quot;playbackStateUpdated&quot;);

            this.SignLabel = Class(ui.Panel, [
                function $clazz() {
                    this.font = new zebkit.Font(&quot;bold&quot;, 18);
                },

                function setColor(c) {
                    this.kids[0].setColor(c);
                    return this;
                },

                function(title) {
                    this.$super(new zebkit.layout.FlowLayout(&quot;center&quot;, &quot;center&quot;));
                    this.add(new ui.Label(title).setFont(this.clazz.font));
                    this.setBorder(new zebkit.draw.Border(&quot;gray&quot;, 1, 8));
                    this.setPadding(6);
                    this.setBackground(&quot;white&quot;);
                    this.setColor(&quot;black&quot;);
                }
            ]);
        },

        function $prototype(clazz) {
            this.videoWidth = this.videoHeight = 0;

            this.cancelationTimeout = 20000; // 20 seconds

            this.showSign = true;

            this.$animStallCounter = this.$aspectRatio = 0;
            this.$adjustProportions = true;
            this.$lastError = this.$videoBound = this.$cancelTask = null;
            this.$animCurrentTime = -1;

            this._ = new this.clazz.Listeners();

            this.views = {
                pause  : new clazz.SignLabel(&quot;Pause, press to continue&quot;).toView(),
                replay : new clazz.SignLabel(&quot;Press to re-play&quot;).toView(),
                play   : new clazz.SignLabel(&quot;Press to play&quot;).toView(),
                error  : new clazz.SignLabel(&quot;Failed, press to re-try&quot;).setColor(&quot;red&quot;).toView(),
                waiting: new clazz.SignLabel(&quot;Waiting ...&quot;).setColor(&quot;orange&quot;).toView()
            };

            this.paint = function(g) {
                if (this.video.paused === false &amp;&amp;
                    this.video.ended  === false &amp;&amp;
                    this.$cancelTask  === null    )
                {
                    if (this.video.currentTime !== this.$animCurrentTime) {
                        this.$animStallCounter = 0;
                        this.repaint();
                    } else {
                        if (this.$animStallCounter &gt; 180) {
                            this.$cancelPlayback();
                        } else {
                            this.$animStallCounter++;
                            this.repaint();
                        }
                    }
                }

                this.$animCurrentTime = this.video.currentTime;

                if (this.$videoBound === null) {
                    this.calcVideoBound();
                }

                g.drawImage(this.video, this.$videoBound.x,
                                        this.$videoBound.y,
                                        this.$videoBound.width,
                                        this.$videoBound.height);

                // draw status sign
                if (this.showSign) {
                    var sign = null;

                    if (this.$lastError !== null) {
                        sign = this.views.error;
                    } else {
                        if (this.$cancelTask !== null) {
                            sign =  this.views.waiting;
                        } else if (this.video.ended) {
                            sign = this.views.replay;
                        } else if (this.video.paused) {
                            if (this.video.currentTime === 0) {
                                sign = this.views.play;
                            } else {
                                sign = this.views.pause;
                            }
                        }
                    }

                    if (sign !== null) {
                        this.paintViewAt(g, &quot;center&quot;, &quot;center&quot;,  sign);
                    }
                }
            };

            /**
             * Set autoplay for video
             * @param  {Boolean} b an autoplay flag
             * @method autoplay
             * @chainable
             */
            this.autoplay = function(b) {
                this.video.autoplay = b;
                return this;
            };

            /**
             * Pause video
             * @method pause
             * @chainable
             */
            this.pause = function() {
                if (this.video.paused === false) {
                    this.video.pause();
                    this.repaint();
                }
                return this;
            };

            /**
             * Mute sound
             * @param  {Boolean} b true to mute the video sound
             * @method mute
             * @chainable
             */
            this.mute = function(b) {
                this.video.muted = b;
                return this;
            };

            /**
             * Start or continue playing video
             * @method play
             * @chainable
             */
            this.play = function() {
                if (this.video.paused === true) {
                    if (this.$lastError !== null) {
                        this.$lastError = null;
                        this.video.load();
                    }

                    this.video.play();
                    this.repaint();
                }
                return this;
            };

            /**
             * Adjust video proportion to fill maximal space with correct ratio
             * @param  {Boolean} b true if the video proportion has to be adjusted
             * @method adjustProportions
             * @chainable
             */
            this.adjustProportions = function(b) {
                if (this.$adjustProportions !== b) {
                    this.$adjustProportions = b;
                    this.vrp();
                }
                return this;
            };

            this.calcPreferredSize = function(target) {
                return {
                    width  : this.videoWidth,
                    height : this.videoHeight
                };
            };

            this.pointerClicked = function(e) {
                if (this.isPaused()) {
                    this.play();
                } else {
                    this.pause();
                }
            };

            /**
             * Check if the video is paused
             * @method isPaused
             * @return {Boolean} true if the video has been paused
             */
            this.isPaused = function() {
                return this.video.paused;
            };

            /**
             * Check if the video is ended
             * @method isEnded
             * @return {Boolean} true if the video has been ended
             */
            this.isEnded = function() {
                return this.video.ended;
            };

            this.getDuration = function() {
                return this.video.duration;
            };

            this.compSized = function(e) {
                this.$calcVideoBound();
            };

            this.recalc = function() {
                this.$calcVideoBound();
            };

            this.$calcVideoBound = function() {
                this.$videoBound = {
                    x      : this.getLeft(),
                    y      : this.getTop(),
                    width  : this.width  - this.getLeft() - this.getBottom(),
                    height : this.height - this.getTop()  - this.getBottom()
                };

                if (this.$adjustProportions === true &amp;&amp; this.$aspectRatio !== 0) {
                    var ar = this.$videoBound.width / this.$videoBound.height;

                    //    ar = 3:1       ar&#x27; = 10:3      ar&#x27; &gt; ar
                    //   +-------+   +--------------+
                    //   | video |   |    canvas    |   =&gt;  decrease canvas width proportionally ar/ar&#x27;
                    //   +-------+   +--------------+
                    //
                    //    ar = 3:1       ar&#x27; = 2:1       ar&#x27; &lt; ar
                    //   +-----------+   +------+
                    //   |  video    |   |canvas|   =&gt;  decrease canvas height proportionally ar&#x27;/ar
                    //   +-----------+   +------+
                    if (ar &lt; this.$aspectRatio) {
                        this.$videoBound.height = Math.floor((this.$videoBound.height * ar) / this.$aspectRatio);
                    } else {
                        this.$videoBound.width = Math.floor((this.$videoBound.width * this.$aspectRatio)/ ar);
                    }

                    this.$videoBound.x = Math.floor((this.width  - this.$videoBound.width )/2);
                    this.$videoBound.y = Math.floor((this.height - this.$videoBound.height)/2);
                }
            };

            this.$continuePlayback = function() {
                this.$interruptCancelTask();
                if (this.video.paused === false &amp;&amp; this.video.ended === false) {
                    this.$animCurrentTime  = this.video.currentTime;
                    this.$animStallCounter = 0;
                    this.repaint();
                }
            };

            this.$cancelPlayback = function() {
                if (this.video.paused === true || this.video.ended === true) {
                    this.$interruptCancelTask();
                } else {
                    if (this.$cancelTask === null) {
                        var $this = this;
                        this.$postponedTime = new Date().getTime();

                        this.$cancelTask = zebkit.environment.setInterval(function() {
                            var dt = new Date().getTime() - $this.$postponedTime;
                            if (dt &gt; $this.cancelationTimeout) {
                                try {
                                    if ($this.video.paused === false) {
                                        $this.$lastError = &quot;Playback failed&quot;;
                                        $this.pause();
                                        $this.repaint();
                                        $this._.playbackStateUpdated($this, &quot;error&quot;);
                                    }
                                } finally {
                                    $this.$interruptCancelTask();
                                }
                            } else {
                                $this._.playbackStateUpdated($this, &quot;wait&quot;);
                            }
                        }, 200);
                    }
                }
            };

            this.$interruptCancelTask = function() {
                if (this.$cancelTask !== null) {
                    zebkit.environment.clearInterval(this.$cancelTask);
                    this.$postponedTime = this.$cancelTask = null;
                }
            };
        }
    ]);


    zebkit.ui.$configWith(pkg);

    //!!!
    // IE9 has an error: first mouse press formally pass focus to
    // canvas, but actually it doesn&#x27;t get key events. To fix it
    // it is necessary to pass focus explicitly to window
    if (zebkit.isIE) {
        window.focus();
    }
});
</pre>

</div>
                    </div>
                </td>
            </tr>
        </table>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>

</body>
</html>
