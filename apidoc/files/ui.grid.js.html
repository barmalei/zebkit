<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ui.grid.js - Zebra API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1>Zebra API: ui.grid.js</a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 07/2013</em>
        </div>
    </div>
    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Packages</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../modules/data.html">data</a>
                
                </li>
            
                <li><a href="../modules/io.html">io</a>
                
                </li>
            
                <li><a href="../modules/layout.html">layout</a>
                
                </li>
            
                <li><a href="../modules/ui.html">ui</a>
                
                </li>
            
                <li><a href="../modules/ui.designer.html">ui.designer</a>
                
                </li>
            
                <li><a href="../modules/ui.grid.html">ui.grid</a>
                
                </li>
            
                <li><a href="../modules/ui.tree.html">ui.tree</a>
                
                </li>
            
                <li><a href="../modules/util.html">util</a>
                
                </li>
            
                <li><a href="../modules/zebra.html">zebra</a>
                
                </li>
            
        </ul>
    </div>
</div>

<div id="classes" class="sidebox">
    <div class="hd">
        <h2 class="no-toc">Classes and interfaces</h2>
    </div>
    <div class="bd">
        <ul>
            
                <li><a href="../classes/zebra.Class().html">zebra.Class()</a></li>
            
                <li><a href="../classes/zebra.data.Item.html">zebra.data.Item</a></li>
            
                <li><a href="../classes/zebra.data.ListModel.html">zebra.data.ListModel</a></li>
            
                <li><a href="../classes/zebra.data.Matrix.html">zebra.data.Matrix</a></li>
            
                <li><a href="../classes/zebra.data.SingleLineTxt.html">zebra.data.SingleLineTxt</a></li>
            
                <li><a href="../classes/zebra.data.Text.html">zebra.data.Text</a></li>
            
                <li><a href="../classes/zebra.data.TextModel.html">zebra.data.TextModel</a></li>
            
                <li><a href="../classes/zebra.data.TreeModel.html">zebra.data.TreeModel</a></li>
            
                <li><a href="../classes/zebra.Dummy.html">zebra.Dummy</a></li>
            
                <li><a href="../classes/zebra.forName().html">zebra.forName()</a></li>
            
                <li><a href="../classes/zebra.instanceOf().html">zebra.instanceOf()</a></li>
            
                <li><a href="../classes/zebra.Interface().html">zebra.Interface()</a></li>
            
                <li><a href="../classes/zebra.io.b64decode().html">zebra.io.b64decode()</a></li>
            
                <li><a href="../classes/zebra.io.b64encode().html">zebra.io.b64encode()</a></li>
            
                <li><a href="../classes/zebra.io.GET().html">zebra.io.GET()</a></li>
            
                <li><a href="../classes/zebra.io.HTTP.html">zebra.io.HTTP</a></li>
            
                <li><a href="../classes/zebra.io.ID().html">zebra.io.ID()</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.html">zebra.io.JRPC</a></li>
            
                <li><a href="../classes/zebra.io.JRPC.invoke().html">zebra.io.JRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.io.POST().html">zebra.io.POST()</a></li>
            
                <li><a href="../classes/zebra.io.QS.html">zebra.io.QS</a></li>
            
                <li><a href="../classes/zebra.io.Service.html">zebra.io.Service</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.html">zebra.io.XRPC</a></li>
            
                <li><a href="../classes/zebra.io.XRPC.invoke().html">zebra.io.XRPC.invoke()</a></li>
            
                <li><a href="../classes/zebra.layout.BorderLayout.html">zebra.layout.BorderLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Constraints.html">zebra.layout.Constraints</a></li>
            
                <li><a href="../classes/zebra.layout.FlowLayout.html">zebra.layout.FlowLayout</a></li>
            
                <li><a href="../classes/zebra.layout.getAbsLocation().html">zebra.layout.getAbsLocation()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectAt().html">zebra.layout.getDirectAt()</a></li>
            
                <li><a href="../classes/zebra.layout.getDirectChild().html">zebra.layout.getDirectChild()</a></li>
            
                <li><a href="../classes/zebra.layout.getTopParent().html">zebra.layout.getTopParent()</a></li>
            
                <li><a href="../classes/zebra.layout.GridLayout.html">zebra.layout.GridLayout</a></li>
            
                <li><a href="../classes/zebra.layout.Layout.html">zebra.layout.Layout</a></li>
            
                <li><a href="../classes/zebra.layout.Layoutable.html">zebra.layout.Layoutable</a></li>
            
                <li><a href="../classes/zebra.layout.ListLayout.html">zebra.layout.ListLayout</a></li>
            
                <li><a href="../classes/zebra.layout.PercentLayout.html">zebra.layout.PercentLayout</a></li>
            
                <li><a href="../classes/zebra.layout.RasterLayout.html">zebra.layout.RasterLayout</a></li>
            
                <li><a href="../classes/zebra.layout.StackLayout.html">zebra.layout.StackLayout</a></li>
            
                <li><a href="../classes/zebra.ready().html">zebra.ready()</a></li>
            
                <li><a href="../classes/zebra.ui.BaseLayer.html">zebra.ui.BaseLayer</a></li>
            
                <li><a href="../classes/zebra.ui.BaseList.html">zebra.ui.BaseList</a></li>
            
                <li><a href="../classes/zebra.ui.BoldLabel.html">zebra.ui.BoldLabel</a></li>
            
                <li><a href="../classes/zebra.ui.Border.html">zebra.ui.Border</a></li>
            
                <li><a href="../classes/zebra.ui.BorderPan.html">zebra.ui.BorderPan</a></li>
            
                <li><a href="../classes/zebra.ui.Button.html">zebra.ui.Button</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.html">zebra.ui.Checkbox</a></li>
            
                <li><a href="../classes/zebra.ui.Checkbox.Box.html">zebra.ui.Checkbox.Box</a></li>
            
                <li><a href="../classes/zebra.ui.ChildrenListener.html">zebra.ui.ChildrenListener</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.html">zebra.ui.Combo</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ContentPan.html">zebra.ui.Combo.ContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.EditableContentPan.html">zebra.ui.Combo.EditableContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.Combo.ReadonlyContentPan.html">zebra.ui.Combo.ReadonlyContentPan</a></li>
            
                <li><a href="../classes/zebra.ui.ComboArrowView.html">zebra.ui.ComboArrowView</a></li>
            
                <li><a href="../classes/zebra.ui.CommandManager.html">zebra.ui.CommandManager</a></li>
            
                <li><a href="../classes/zebra.ui.CompList.html">zebra.ui.CompList</a></li>
            
                <li><a href="../classes/zebra.ui.ComponentListener.html">zebra.ui.ComponentListener</a></li>
            
                <li><a href="../classes/zebra.ui.Composite.html">zebra.ui.Composite</a></li>
            
                <li><a href="../classes/zebra.ui.CompositeView.html">zebra.ui.CompositeView</a></li>
            
                <li><a href="../classes/zebra.ui.CompRender.html">zebra.ui.CompRender</a></li>
            
                <li><a href="../classes/zebra.ui.CopyCutPaste.html">zebra.ui.CopyCutPaste</a></li>
            
                <li><a href="../classes/zebra.ui.Cursorable.html">zebra.ui.Cursorable</a></li>
            
                <li><a href="../classes/zebra.ui.CursorManager.html">zebra.ui.CursorManager</a></li>
            
                <li><a href="../classes/zebra.ui.designer.ShaperPan.html">zebra.ui.designer.ShaperPan</a></li>
            
                <li><a href="../classes/zebra.ui.Dotted.html">zebra.ui.Dotted</a></li>
            
                <li><a href="../classes/zebra.ui.Etched.html">zebra.ui.Etched</a></li>
            
                <li><a href="../classes/zebra.ui.EventManager.html">zebra.ui.EventManager</a></li>
            
                <li><a href="../classes/zebra.ui.findCanvas().html">zebra.ui.findCanvas()</a></li>
            
                <li><a href="../classes/zebra.ui.FocusListener.html">zebra.ui.FocusListener</a></li>
            
                <li><a href="../classes/zebra.ui.FocusManager.html">zebra.ui.FocusManager</a></li>
            
                <li><a href="../classes/zebra.ui.Font.html">zebra.ui.Font</a></li>
            
                <li><a href="../classes/zebra.ui.Gradient.html">zebra.ui.Gradient</a></li>
            
                <li><a href="../classes/zebra.ui.grid.DefEditors.html">zebra.ui.grid.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Grid.html">zebra.ui.grid.Grid</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridCaption.html">zebra.ui.grid.GridCaption</a></li>
            
                <li><a href="../classes/zebra.ui.grid.GridStretchPan.html">zebra.ui.grid.GridStretchPan</a></li>
            
                <li><a href="../classes/zebra.ui.grid.Metrics.html">zebra.ui.grid.Metrics</a></li>
            
                <li><a href="../classes/zebra.ui.Group.html">zebra.ui.Group</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlElement.html">zebra.ui.HtmlElement</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextArea.html">zebra.ui.HtmlTextArea</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextField.html">zebra.ui.HtmlTextField</a></li>
            
                <li><a href="../classes/zebra.ui.HtmlTextInput.html">zebra.ui.HtmlTextInput</a></li>
            
                <li><a href="../classes/zebra.ui.ImageLabel.html">zebra.ui.ImageLabel</a></li>
            
                <li><a href="../classes/zebra.ui.ImagePan.html">zebra.ui.ImagePan</a></li>
            
                <li><a href="../classes/zebra.ui.InputEvent.html">zebra.ui.InputEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyEvent.html">zebra.ui.KeyEvent</a></li>
            
                <li><a href="../classes/zebra.ui.KeyListener.html">zebra.ui.KeyListener</a></li>
            
                <li><a href="../classes/zebra.ui.Label.html">zebra.ui.Label</a></li>
            
                <li><a href="../classes/zebra.ui.List.html">zebra.ui.List</a></li>
            
                <li><a href="../classes/zebra.ui.List.ViewProvider.html">zebra.ui.List.ViewProvider</a></li>
            
                <li><a href="../classes/zebra.ui.loadImage().html">zebra.ui.loadImage()</a></li>
            
                <li><a href="../classes/zebra.ui.Manager.html">zebra.ui.Manager</a></li>
            
                <li><a href="../classes/zebra.ui.Menu.html">zebra.ui.Menu</a></li>
            
                <li><a href="../classes/zebra.ui.Menunbar.html">zebra.ui.Menunbar</a></li>
            
                <li><a href="../classes/zebra.ui.MLabel.html">zebra.ui.MLabel</a></li>
            
                <li><a href="../classes/zebra.ui.MouseEvent.html">zebra.ui.MouseEvent</a></li>
            
                <li><a href="../classes/zebra.ui.MouseListener.html">zebra.ui.MouseListener</a></li>
            
                <li><a href="../classes/zebra.ui.MouseWheelSupport.html">zebra.ui.MouseWheelSupport</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManager.html">zebra.ui.PaintManager</a></li>
            
                <li><a href="../classes/zebra.ui.PaintManImpl.html">zebra.ui.PaintManImpl</a></li>
            
                <li><a href="../classes/zebra.ui.Panel.html">zebra.ui.Panel</a></li>
            
                <li><a href="../classes/zebra.ui.PasswordText.html">zebra.ui.PasswordText</a></li>
            
                <li><a href="../classes/zebra.ui.Pattern.html">zebra.ui.Pattern</a></li>
            
                <li><a href="../classes/zebra.ui.Picture.html">zebra.ui.Picture</a></li>
            
                <li><a href="../classes/zebra.ui.PopupInfo.html">zebra.ui.PopupInfo</a></li>
            
                <li><a href="../classes/zebra.ui.PopupLayer.html">zebra.ui.PopupLayer</a></li>
            
                <li><a href="../classes/zebra.ui.PopupManager.html">zebra.ui.PopupManager</a></li>
            
                <li><a href="../classes/zebra.ui.Progress.html">zebra.ui.Progress</a></li>
            
                <li><a href="../classes/zebra.ui.Radial.html">zebra.ui.Radial</a></li>
            
                <li><a href="../classes/zebra.ui.Radiobox.html">zebra.ui.Radiobox</a></li>
            
                <li><a href="../classes/zebra.ui.RadioView.html">zebra.ui.RadioView</a></li>
            
                <li><a href="../classes/zebra.ui.Raised.html">zebra.ui.Raised</a></li>
            
                <li><a href="../classes/zebra.ui.Render.html">zebra.ui.Render</a></li>
            
                <li><a href="../classes/zebra.ui.RootLayer.html">zebra.ui.RootLayer</a></li>
            
                <li><a href="../classes/zebra.ui.RoundBorder.html">zebra.ui.RoundBorder</a></li>
            
                <li><a href="../classes/zebra.ui.Scroll.html">zebra.ui.Scroll</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollManager.html">zebra.ui.ScrollManager</a></li>
            
                <li><a href="../classes/zebra.ui.ScrollPan.html">zebra.ui.ScrollPan</a></li>
            
                <li><a href="../classes/zebra.ui.Slider.html">zebra.ui.Slider</a></li>
            
                <li><a href="../classes/zebra.ui.SplitPan.html">zebra.ui.SplitPan</a></li>
            
                <li><a href="../classes/zebra.ui.StatePan.html">zebra.ui.StatePan</a></li>
            
                <li><a href="../classes/zebra.ui.Sunken.html">zebra.ui.Sunken</a></li>
            
                <li><a href="../classes/zebra.ui.SwitchManager.html">zebra.ui.SwitchManager</a></li>
            
                <li><a href="../classes/zebra.ui.Tabs.html">zebra.ui.Tabs</a></li>
            
                <li><a href="../classes/zebra.ui.TextArea.html">zebra.ui.TextArea</a></li>
            
                <li><a href="../classes/zebra.ui.TextField.html">zebra.ui.TextField</a></li>
            
                <li><a href="../classes/zebra.ui.TextRender.html">zebra.ui.TextRender</a></li>
            
                <li><a href="../classes/zebra.ui.Toolbar.html">zebra.ui.Toolbar</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipInfo.html">zebra.ui.TooltipInfo</a></li>
            
                <li><a href="../classes/zebra.ui.TooltipManager.html">zebra.ui.TooltipManager</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefEditors.html">zebra.ui.tree.DefEditors</a></li>
            
                <li><a href="../classes/zebra.ui.tree.DefViews.html">zebra.ui.tree.DefViews</a></li>
            
                <li><a href="../classes/zebra.ui.tree.Tree.html">zebra.ui.tree.Tree</a></li>
            
                <li><a href="../classes/zebra.ui.View.html">zebra.ui.View</a></li>
            
                <li><a href="../classes/zebra.ui.ViewPan.html">zebra.ui.ViewPan</a></li>
            
                <li><a href="../classes/zebra.ui.ViewSet.html">zebra.ui.ViewSet</a></li>
            
                <li><a href="../classes/zebra.ui.Window.html">zebra.ui.Window</a></li>
            
                <li><a href="../classes/zebra.ui.WinLayer.html">zebra.ui.WinLayer</a></li>
            
                <li><a href="../classes/zebra.ui.WinListener.html">zebra.ui.WinListener</a></li>
            
                <li><a href="../classes/zebra.ui.zCanvas.html">zebra.ui.zCanvas</a></li>
            
                <li><a href="../classes/zebra.URL.html">zebra.URL</a></li>
            
                <li><a href="../classes/zebra.util.Bag.html">zebra.util.Bag</a></li>
            
                <li><a href="../classes/zebra.util.findInTree().html">zebra.util.findInTree()</a></li>
            
                <li><a href="../classes/zebra.util.Listeners.html">zebra.util.Listeners</a></li>
            
                <li><a href="../classes/zebra.util.newInstance().html">zebra.util.newInstance()</a></li>
            
                <li><a href="../classes/zebra.util.Position.html">zebra.util.Position</a></li>
            
                <li><a href="../classes/zebra.util.Position.Metric.html">zebra.util.Position.Metric</a></li>
            
                <li><a href="../classes/zebra.util.rgb.html">zebra.util.rgb</a></li>
            
        </ul>
    </div>
</div>












        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>ui.grid.js</h4>

<pre class="code prettyprint linenums">
(function(pkg, Class, ui) {
/**
 * @module ui.grid
 * @namespace zebra.ui.grid
 */

var Matrix = zebra.data.Matrix, L = zebra.layout, WinLayer = ui.WinLayer, MB = zebra.util, 
    Cursor = ui.Cursor, Position = zebra.util.Position, KE = ui.KeyEvent, 
    Listeners = zebra.util.Listeners;

//!!! crappy function
function arr(l, v) {
    var a = Array(l);
    for(var i=0; i&lt;l; i++) a[i] = v;
    return a;
}

pkg.START_EDITING  = 1;
pkg.FINISH_EDITING = 2;
pkg.CANCEL_EDITING = 3;

function CellsVisibility() {
    this.hasVisibleCells = function(){
        return this.fr != null &amp;&amp; this.fc != null &amp;&amp; this.lr != null &amp;&amp; this.lc != null;
    };
    // first visible row (row and y), first visible col, last visible col and row
    this.fr = this.fc = this.lr = this.lc = null;
}

/**
 *  Interface that describes a grid component metrics 
 *  @class Metrics
 */
pkg.Metrics = zebra.Interface();

/**
 * Get the given column width of a grid component 
 * @param {Integer} col a column index 
 * @method getColWidth
 * @return {Integer} a column width 
 */

/**
 * Get the given row height of a grid component 
 * @param {Integer} row a row index 
 * @method getRowHeight
 * @return {Integer} a row height
 */

/**
 * Get the given row preferred height of a grid component 
 * @param {Integer} row a row index 
 * @method getPSRowHeight
 * @return {Integer} a row preferred height 
 */

/**
 * Get the given column preferred width of a grid component 
 * @param {Integer} col a column index 
 * @method getPSColWidth
 * @return {Integer} a column preferred width
 */

 /**
  * Get a x origin of a grid component. Origin indicates how 
  * the grid component content has been scrolled
  * @method getXOrigin
  * @return {Integer} a x origin
  */

/**
  * Get a y origin of a grid component. Origin indicates how 
  * the grid component content has been scrolled
  * @method getYOrigin
  * @return {Integer} a y origin
  */

  /**
   * Set the given column width of a grid component 
   * @param {Integer} col a column index 
   * @param {Integer} w a column width 
   * @method setColWidth
   */

  /**
   * Set the given row height of a grid component 
   * @param {Integer} row a row index 
   * @param {Integer} h a row height
   * @method setRowHeight
   */

  /**
   * Get number of columns in a grid component 
   * @return {Integer} a number of columns 
   * @method getGridCols
   */

  /**
   * Get number of rows in a grid component 
   * @return {Integer} a number of rows 
   * @method getGridRows
   */

   /**
    * Get a structure that describes a grid component 
    * columns and rows visibility  
    * @return {zebra.ui.grid.CellsVisibility} a grid cells visibility
    * @method getCellsVisibility 
    */
  
  /**
   * Grid line size
   * @attribute lineSize
   * @type {Integer}
   * @readOnly
   */

  /**
   * Indicate if a grid sizes its rows and cols basing on its preferred sizes
   * @attribute isUsePsMetric
   * @type {Boolean}
   * @readOnly
   */


pkg.DefViews = Class([
    function(){
        this.render = new ui.TextRender(new zebra.data.SingleLineTxt(&quot;&quot;));
    },

    function $prototype() {
        this.getXAlignment = function(row,col){ return L.CENTER; },
        this.getYAlignment = function(row,col){ return L.CENTER; },
        this.getCellColor  = function(row,col){ return pkg.DefViews.cellBackground;},

        this.getView = function(row,col,obj){
            if (obj != null){
                if (obj &amp;&amp; obj.paint) return obj;
                this.render.target.setValue(obj.toString());
                return this.render;
            }
            return null;
        };
    }
]);

/**
 * Simple grid cells editors provider implementation. The editors provider
 * always use a text field component to edit a cell content.   
 * @constructor
 * @class DefEditors
 */
pkg.DefEditors = Class([
    function() {
        this.editors = {};
        this.editors[&#x27;&#x27;] = new ui.TextField(&quot;&quot;, 150);
    },

    function $prototype() {
        /**
         * Fetch an edited value from the given UI editor component. 
         * @param  {Integer} row a grid cell row that has been edited
         * @param  {Integer} col a grid cell column that has been edited
         * @param  {Object} data an original cell content
         * @param  {zebra.ui.Panel} editor an editor that has been used to 
         * edit the given cell
         * @return {Object} a value that has to be applied as a new content of 
         * the edited cell content
         * @method  fetchEditedValue 
         */
        this.fetchEditedValue = function(row,col,data,editor) {
            return editor.getValue();
        };

        /**
         * Fetch an edited value from the given UI editor component. 
         * @param  {Integer} row a grid cell row that has been edited
         * @param  {Integer} col a grid cell column that has been edited
         * @param  {Object} data an original cell content
         * @param  {zebra.ui.Panel} editor an editor that has been used to 
         * edit the given cell
         * @return {Object} a value that has to be applied as a new content of 
         * the edited cell content
         * @method  fetchEditedValue 
         */
        this.getEditor = function(t, row, col, v){
            var editor = this.editors[col] ? this.editors[col] : this.editors[&#x27;&#x27;]; 
            if (editor == null) return;

            editor.setBorder(null);
            editor.setPadding(0);
            editor.setValue((v == null ? &quot;&quot; : v.toString()));

            var ah = (t.getRowHeight(row) - editor.getPreferredSize().height)/2;
            editor.setPaddings(ah, t.cellInsetsLeft, ah, t.cellInsetsRight);
            return editor;
        };

        this.shouldDo = function(a,row,col,e){
            //!!! if (action == pkg.START_EDITING) return e.ID == MouseEvent.CLICKED &amp;&amp; e.clicks == 1;
            // !!!else return (action == pkg.CANCEL_EDITING) ? e.ID == KE.PRESSED &amp;&amp; KE.ESCAPE == e.code: false;
            var b = (a == pkg.START_EDITING  &amp;&amp; e.ID == ui.MouseEvent.CLICKED &amp;&amp; e.clicks == 1) ||
                    (a == pkg.CANCEL_EDITING &amp;&amp; e.ID == KE.PRESSED &amp;&amp; KE.ESCAPE == e.code) ||
                    (a == pkg.FINISH_EDITING &amp;&amp; e.ID == KE.PRESSED &amp;&amp; KE.ENTER  == e.code);
            return b;
        };

        this.editingCanceled = function(row,col,data,editor) {};
    }
]);

var GridCaptionListeners = new Listeners.Class(&quot;captionResized&quot;);

/**
 * Grid caption UI component class.
 * @class  GridCaption
 * @extends {zebra.ui.Panel}
 * @constructor 
 * @param {zebra.ui.grid.Metrics} [m]  a grid metrics the caption is set for
 * @param {Integer} [o] an orientation of caption: &quot;zebra.layout.VERTICAL&quot; or 
 * &quot;zebra.layout.HORIZONTAL&quot;
 */
pkg.GridCaption = Class(ui.Panel, ui.MouseListener, ui.Cursorable, [
    function $clazz() {
        this.Label = Class(ui.BoldLabel, []);
    },

    function $prototype() {
        /**
         * Minimal possible grid cell size
         * @type {Number}
         * @default 10
         * @attribute minSize
         */
        this.minSize = 10;

        /**
         * Size of the active area where cells size can be changed by mouse dragging event 
         * @attribute activeAreaSize
         * @type {Number}
         * @default 20
         */
        this.activeAreaSize = 20;

        /**
         * Indicate if the grid cell size has to be adjusted according 
         * to the cell preferred size by mouse double click event.
         * @attribute isAutoFit
         * @default true
         * @type {Boolean}
         */
        
        /**
         * Indicate if the grid cells are resize-able. 
         * to the cell preferred size by mouse double click event.
         * @attribute isResizable
         * @default true
         * @type {Boolean}
         */
        this.isAutoFit = this.isResizable = true;


        this.getCursorType = function (target,x,y){
            return this.metrics != null &amp;&amp; this.selectedColRow &gt;= 0 &amp;&amp; this.isResizable &amp;&amp;
                  !this.metrics.isUsePsMetric ? ((this.orient == L.HORIZONTAL) ? Cursor.W_RESIZE
                                                                               : Cursor.S_RESIZE)
                                              : -1;
        };

        this.mouseDragged = function(e){
            if (this.pxy != null){
                var b  = (this.orient == L.HORIZONTAL), m = this.metrics, rc = this.selectedColRow,
                    ns = (b ? m.getColWidth(rc) + e.x : m.getRowHeight(rc) + e.y) - this.pxy;

                if (ns &gt; this.minSize) {
                    if (b) {
                        var pw = m.getColWidth(rc);
                        m.setColWidth (rc, ns);
                        this._.captionResized(this, rc, pw);
                    }
                    else  {
                        var ph = m.getRowHeight(rc);
                        m.setRowHeight(rc, ns);
                        this._.captionResized(this, rc, ph);
                    }
                    this.pxy = b ? e.x : e.y;
                }
            }
        };

        this.mouseDragStarted = function(e){
            if (this.metrics != null &amp;&amp;
                this.isResizable &amp;&amp;
                !this.metrics.isUsePsMetric)
            {
                this.calcRowColAt(e.x, e.y);
                if (this.selectedColRow &gt;= 0) {
                    this.pxy = (this.orient == L.HORIZONTAL) ? e.x : e.y;
                }
            }
        };

        this.mouseDragEnded = function (e){
            if (this.pxy != null) {
                this.pxy = null;
            }
            if (this.metrics != null) this.calcRowColAt(e.x, e.y);
        };

        this.mouseMoved = function(e) {
            if (this.metrics != null) {
                this.calcRowColAt(e.x, e.y);
            }
        };

        this.mouseClicked = function (e){
            if (this.pxy == null &amp;&amp; this.metrics != null &amp;&amp; e.clicks &gt; 1 &amp;&amp;
                this.selectedColRow &gt;= 0 &amp;&amp; this.isAutoFit)
            {
                var b = (this.orient == L.HORIZONTAL), add = 0, m = this.metrics, bv = this.borderView,
                    size = b ? m.getColPSWidth(this.selectedColRow) : m.getRowPSHeight(this.selectedColRow);

                if (bv != null) add = (b ? (bv.getLeft() + bv.getRight()) : (bv.getTop() + bv.getBottom()));

                var v = this.getTitleView(this.selectedColRow);
                if (v != null) size = Math.max(size, add + (b ? v.getPreferredSize().width : v.getPreferredSize().height));

                if (b) m.setColWidth (this.selectedColRow, size);
                else   m.setRowHeight(this.selectedColRow, size);
            }
        };

        this.calcRowColAt = function(x, y){
            var isHor = (this.orient == L.HORIZONTAL), cv = this.metrics.getCellsVisibility();

            if ((isHor &amp;&amp; cv.fc != null) || (!isHor &amp;&amp; cv.fr != null)){
                var m = this.metrics, g = m.lineSize, xy = isHor ? x : y,
                    xxyy = isHor ? cv.fc[1] - this.x + m.getXOrigin() - g
                                 : cv.fr[1] - this.y + m.getYOrigin() - g;

                for(var i = (isHor ? cv.fc[0] : cv.fr[0]);i &lt;= (isHor ? cv.lc[0] : cv.lr[0]); i ++ )
                {
                    var wh = isHor ? m.getColWidth(i) : m.getRowHeight(i);
                    xxyy += (wh + g);
                    if (xy &lt; xxyy + this.activeAreaSize &amp;&amp; xy &gt; xxyy - this.activeAreaSize){
                        this.selectedColRow = i;
                        this.selectedXY = xy - wh;
                        return ;
                    }
                }
            }
            this.selectedColRow = -1;
        };

        this.getTitleProps = function(i){
            return this.titles != null &amp;&amp; i &lt; this.titles.length / 2 ? this.titles[i * 2 + 1]
                                                                     : null;
        };

        /**
         * Get a grid caption column or row title view
         * @param  {Integer} i a row (if the caption is vertical) or 
         * column (if the caption is horizontal) index
         * @return {zebra.ui.View} a view to be used as the given 
         * row or column title view 
         * @method getTitleView
         */
        this.getTitleView = function(i){
            var data = this.getTitle(i);
            if (data == null || data.paint) return data;
            this.render.target.setValue(data.toString());
            return this.render;
        };

        this.calcPreferredSize = function (l) {
            return { width:this.psW, height:this.psH };
        };

        this.recalc = function(){
            this.psW = this.psH = 0;
            if (this.metrics != null){
                var m = this.metrics, isHor = (this.orient == L.HORIZONTAL), size = isHor ? m.getGridCols() : m.getGridRows();
                for(var i = 0;i &lt; size; i++){
                    var v = this.getTitleView(i);
                    if(v != null){
                        var ps = v.getPreferredSize();
                        if(isHor){
                            if(ps.height &gt; this.psH) this.psH = ps.height;
                            this.psW += ps.width;
                        }
                        else{
                            if(ps.width &gt; this.psW) this.psW = ps.width;
                            this.psH += ps.height;
                        }
                    }
                }
               
                if (this.psH === 0) this.psH = pkg.Grid.DEF_ROWHEIGHT;
                if (this.psW === 0) this.psW = pkg.Grid.DEF_COLWIDTH;
               
                if (this.borderView != null){
                    this.psW += (this.borderView.getLeft() + this.borderView.getRight()) * (isHor ? size : 1);
                    this.psH += (this.borderView.getTop() + this.borderView.getBottom()) * (isHor ? 1 : size);
                }
            }
        };

        this.paint = function(g){
            if(this.metrics != null){
                var cv = this.metrics.getCellsVisibility();
                if (cv.hasVisibleCells() === false) return;

                var m = this.metrics, 
                    isHor = (this.orient == L.HORIZONTAL), gap = m.lineSize,
                    top = 0, left = 0, bottom = 0, right = 0;
                
                if (this.borderView != null){
                    top    += this.borderView.getTop();
                    left   += this.borderView.getLeft();
                    bottom += this.borderView.getBottom();
                    right  += this.borderView.getRight();
                }

                var x = isHor ? cv.fc[1] - this.x + m.getXOrigin() - gap : this.getLeft(),
                    y = isHor ? this.getTop() : cv.fr[1] - this.y + m.getYOrigin() - gap,
                    size = isHor ? m.getGridCols() : m.getGridRows();

                for(var i = (isHor ? cv.fc[0] : cv.fr[0]);i &lt;= (isHor ? cv.lc[0] : cv.lr[0]); i ++ )
                {
                    var wh1 = isHor ? m.getColWidth(i) + gap + (((size - 1) == i) ? gap : 0) : this.psW,
                        wh2 = isHor ? this.psH : m.getRowHeight(i) + gap + (((size - 1) == i) ? gap : 0),
                        v = this.getTitleView(i);

                    if (this.borderView != null) this.borderView.paint(g, x, y, wh1, wh2, this);

                    if (v != null) {
                        var props = this.getTitleProps(i), ps = v.getPreferredSize();
                        if(props != null &amp;&amp; props[2] != 0){
                            g.setColor(props[2]);
                            g.fillRect(x, y, wh1 - 1, wh2 - 1);
                        }

                        g.save();
                        if (this.borderView &amp;&amp; this.borderView.outline &amp;&amp; this.borderView.outline(g, x, y, wh1, wh2, this)) {
                            g.clip();
                        }
                        else {
                            g.clipRect(x, y, wh1, wh2);
                        }

                        var vx = x + L.xAlignment(ps.width, props != null ? props[0] : L.CENTER, wh1 - left - right) + left,
                            vy = y + L.yAlignment(ps.height, props != null ? props[1] : L.CENTER, wh2 - top - bottom) + top;

                        v.paint(g, vx, vy, ps.width, ps.height, this);
                        g.restore();
                    }

                    if (isHor) x += wh1;
                    else       y += wh2;
                }
            }
        };

        this.getCaptionAt = function (x,y){
            if(this.metrics != null &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; this.width &amp;&amp; y &lt; this.height){
                var m = this.metrics, cv = m.getCellsVisibility(), isHor = (this.orient == L.HORIZONTAL);
                if((isHor &amp;&amp; cv.fc != null) || ( !isHor &amp;&amp; cv.fr != null)){
                    var gap = m.lineSize, xy = isHor ? x : y,
                        xxyy = isHor ? cv.fc[1] - this.x - gap + m.getXOrigin() : cv.fr[1] - this.y - gap + m.getYOrigin();

                    for(var i = (isHor ? cv.fc[0] : cv.fr[0]);i &lt;= (isHor ? cv.lc[0] : cv.lr[0]); i ++ ){
                        var wh = isHor ? m.getColWidth(i) : m.getRowHeight(i);
                        if(xy &gt; xxyy &amp;&amp; xy &lt; xxyy + wh) return i;
                        xxyy += wh + gap;
                    }
                }
            }
            return -1;
        };

        this.getTitle = function(rowcol){
            return this.titles == null || this.titles.length / 2 &lt;= rowcol ? null
                                                                           : this.titles[rowcol*2];
        };
    },

    function (){ this.$this(null, L.HORIZONTAL); },
    function (m){ this.$this(m, L.HORIZONTAL); },

    function (m,o){
        this._ = new GridCaptionListeners();

        this.pxy = this.titles = this.metrics = this.render = null;
        this.psW = this.psH = this.orient = this.selectedXY = 0;
        this.selectedColRow = -1;

        this.setup(m, o);
        this.render = new ui.TextRender(&quot;&quot;);
        this.render.setFont(pkg.GridCaption.font);
        this.render.setColor(pkg.GridCaption.fontColor);
        this.$super();
    },

    function setup(m,o){
        if(this.metrics != m || o != this.orient){
            if (o != L.HORIZONTAL &amp;&amp; o != L.VERTICAL) throw new Error(&quot;Invalid args&quot;);
            this.metrics = m;
            this.orient = o;
            this.vrp();
        }
    },

    /**
     * Set grid caption border view. The border view is used to render every cell 
     * of the grid caption. 
     * @param {zebra.ui.View} v a view
     * @method setBorderView
     */
    function setBorderView(v){
        if (v != this.borderView){
            this.borderView = ui.$view(v);
            this.vrp();
        }
    },

    /**
     * Put the given title for the given caption cell. 
     * @param  {Integer} rowcol a grid caption cell index
     * @param  {String|zebra.ui.View} title a title of the given grid caption cell.
     * Can be a string or zbra.ui.View class instance
     * @method putTitle
     */
    function putTitle(rowcol,title){
        var old = this.getTitle(rowcol);
        if (old != title)
        {
            if (this.titles == null) {
                this.titles = arr((rowcol + 1) * 2, null);
            }
            else {
                if (Math.floor(this.titles.length / 2) &lt;= rowcol){
                    var nt = arr((rowcol + 1) * 2, null);
                    zebra.util.arraycopy(this.titles, 0, nt, 0, this.titles.length);
                    this.titles = nt;
                }
            }
            var index = rowcol * 2;
            this.titles[index] = title;
            if (title == null &amp;&amp; index + 2 == this.titles.length) {
                var nt = arr(this.titles.length - 2, null);
                zebra.util.arraycopy(this.titles, 0, nt, 0, index);
                this.titles = nt;
            }
            this.vrp();
        }
    },

    /**
     * Set the given grid caption cell title properties such as: vertical and 
     * horizontal alignment, background color. 
     * @param {Integer} rowcol a grid caption cell index
     * @param {Integer} ax     a horizontal alignment of the given cell title. Can
     * be: zebra.layout.LEFT, zebra.layout.CENTER, zebra.layout.RIGHT
     * @param {Integer} ay     a vertical alignment of the given cell title. Can
     * be: zebra.layout.TOP, zebra.layout.CENTER, zebra.layout.BOTTOM
     * @param {String} bg a background color
     * @method  setTitleProps
     */
    function setTitleProps(rowcol,ax,ay,bg){
        var p = this.getTitleProps(rowcol);
        if (p == null) p = [];
        p[0] = ax;
        p[1] = ay;
        p[2] = bg == null ? 0 : bg.getRGB();
        this.titles[rowcol*2 + 1] = p;
        this.repaint();
    }
]);

/**
 * Grid UI component class. The grid component visualizes &quot;zebra.data.Matrix&quot; data model.
 * Grid cell visualization can be customized by defining and setting an own view provider.
 * Grid component supports cell editing. Every existent UI component can be configured 
 * as a cell editor by defining an own editor provider. 
 *
 * Grid can have top and left captions.
 * @class  Grid
 * @constructor
 * @param {zebra.data.Matrix|Array} [model] a matrix model to be visualized with the grid 
 * component. It can be an instance of zebra.data.Matrix class or an array that contains 
 * embedded arrays. Every embedded array is a grid row. 
 * @param {Integer} [rows]  a number of rows 
 * @param {Integer} [columns] a number of columns
 * @extends {zebra.ui.Panel} 
 * @uses zebra.ui.grid.Metrics
 */

/**
 * Fire when a grid row selection state has been changed
 
        grid._.add(function(grid, row, count, status) {
            ... 
        });

 * @event rowSelected
 * @param  {zebra.ui.grid.Grid} grid a grid that triggers the event
 * @param  {Integer} row a first row whose selection state has been updated. The row is 
 * -1 if all selected rows have been unselected
 * @param  {Integer} count a number of rows whose selection state has been updated
 * @param {Boolean} status a status. true means rows have been selected 
 */
pkg.Grid = Class(ui.Panel, ui.MouseListener, ui.KeyListener,
                 Position.Metric, ui.ChildrenListener,
                 ui.WinListener, pkg.Metrics, [
      
        function $clazz() {
            this.DEF_COLWIDTH  = 80;
            this.DEF_ROWHEIGHT = 25;
            this.CornerPan = Class(ui.Panel, []);
        },

        function $prototype() {
            /**
             * Grid line size
             * @attribute lineSize
             * @default 1
             * @type {Integer}
             */

            /**
             * Grid cell top padding
             * @attribute cellInsetsTop
             * @default 1
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell left padding
             * @attribute cellInsetsLeft
             * @default 2
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell bottom padding
             * @attribute cellInsetsBottom
             * @default 1
             * @type {Integer}
             * @readOnly
             */

            /**
             * Grid cell right padding
             * @attribute cellInsetsRight
             * @default 2
             * @type {Integer}
             * @readOnly
             */
            this.lineSize = this.cellInsetsTop = this.cellInsetsBottom = 1;
            this.cellInsetsLeft = this.cellInsetsRight = 2;

            /**
             * Indicate if vertical lines have to be rendered
             * @attribute drawVerLines
             * @type {Boolean}
             * @readOnly
             * @default true
             */
            
            /**
             * Indicate if horizontal lines have to be rendered
             * @attribute drawHorLines
             * @type {Boolean}
             * @readOnly
             * @default true
             */
            this.drawVerLines = this.drawHorLines = true;

            /**
             * Line color
             * @attribute lineColor
             * @type {String}
             * @default gray
             * @readOnly
             */
            this.lineColor = &quot;gray&quot;;

            /**
             * Indicate if size of grid cells have to be calculated 
             * automatically basing on its preferred heights and widths
             * @attribute isUsePsMetric
             * @type {Boolean}
             * @default false
             * @readOnly
             */
            this.isUsePsMetric = false;

            this.getColX_ = function (col){
                var start = 0, d = 1, x = this.getLeft() + this.getLeftCaptionWidth() + this.lineSize, v = this.visibility;
                if (v.hasVisibleCells()){
                    start = v.fc[0];
                    x = v.fc[1];
                    d = (col &gt; v.fc[0]) ? 1 :  - 1;
                }
                for(var i = start;i != col; x += ((this.colWidths[i] + this.lineSize) * d),i += d);
                return x;
            };

            this.getRowY_ = function (row){
                var start = 0, d = 1, y = this.getTop() + this.getTopCaptionHeight() + this.lineSize, v = this.visibility;
                if (v.hasVisibleCells()){
                    start = v.fr[0];
                    y = v.fr[1];
                    d = (row &gt; v.fr[0]) ? 1 :  - 1;
                }
                for(var i = start;i != row; y += ((this.rowHeights[i] + this.lineSize) * d),i += d);
                return y;
            };

            this.rPs = function(){
                var cols = this.getGridCols(), rows = this.getGridRows();
                this.psWidth_ = this.lineSize * (cols + 1);
                this.psHeight_ = this.lineSize * (rows + 1);
                for(var i = 0;i &lt; cols; i ++ ) this.psWidth_ += this.colWidths[i];
                for(var i = 0;i &lt; rows; i ++ ) this.psHeight_ += this.rowHeights[i];
            };

            this.colVisibility = function(col,x,d,b){
                var cols = this.getGridCols();
                if(cols === 0) return null;
                var left = this.getLeft(), dx = this.scrollManager.getSX(),
                    xx1 = Math.min(this.visibleArea.x + this.visibleArea.width, this.width - this.getRight()),
                    xx2 = Math.max(left, this.visibleArea.x + this.getLeftCaptionWidth());

                for(; col &lt; cols &amp;&amp; col &gt;= 0; col += d){
                    if(x + dx &lt; xx1 &amp;&amp; (x + this.colWidths[col] + dx) &gt; xx2){
                        if (b) return [col, x];
                    }
                    else {
                        if (b === false) return this.colVisibility(col, x, (d &gt; 0 ?  -1 : 1), true);
                    }
                    if (d &lt; 0){
                        if (col &gt; 0) x -= (this.colWidths[col - 1] + this.lineSize);
                    }
                    else {
                        if (col &lt; cols - 1) x += (this.colWidths[col] + this.lineSize);
                    }
                }
                return b ? null : ((d &gt; 0) ? [col -1, x] : [0, left + this.getLeftCaptionWidth() + this.lineSize]);
            };

            this.rowVisibility = function(row,y,d,b){
                var rows = this.getGridRows();

                if (rows === 0) return null;
                var top = this.getTop(), dy = this.scrollManager.getSY(),
                    yy1 = Math.min(this.visibleArea.y + this.visibleArea.height, this.height - this.getBottom()),
                    yy2 = Math.max(this.visibleArea.y, top + this.getTopCaptionHeight());

                for(; row &lt; rows &amp;&amp; row &gt;= 0; row += d){
                    if(y + dy &lt; yy1 &amp;&amp; (y + this.rowHeights[row] + dy) &gt; yy2){
                        if(b) return [row, y];
                    }
                    else{
                        if(b === false) return this.rowVisibility(row, y, (d &gt; 0 ?  -1 : 1), true);
                    }
                    if(d &lt; 0){
                        if(row &gt; 0) y -= (this.rowHeights[row - 1] + this.lineSize);
                    }
                    else{
                        if(row &lt; rows - 1) y += (this.rowHeights[row] + this.lineSize);
                    }
                }
                return b ? null : ((d &gt; 0) ? [row - 1, y] : [0, top + this.getTopCaptionHeight() + this.lineSize]);
            };

            this.vVisibility = function(){
                var va = ui.$cvp(this, {});
                if(va == null){
                    this.visibleArea = null;
                    this.visibility.cancelVisibleCells();
                    return ;
                }
                else {
                    if (this.visibleArea == null           ||
                        va.x != this.visibleArea.x         ||
                        va.y != this.visibleArea.y         ||
                        va.width != this.visibleArea.width ||
                        va.height != this.visibleArea.height  )
                    {
                        this.iColVisibility(0);
                        this.iRowVisibility(0);
                        this.visibleArea = va;
                    }
                }

                var v = this.visibility, b = v.hasVisibleCells();
                if (this.colOffset != 100){
                    if (this.colOffset &gt; 0 &amp;&amp; b){
                        v.lc = this.colVisibility(v.lc[0], v.lc[1],  -1, true);
                        v.fc = this.colVisibility(v.lc[0], v.lc[1],  -1, false);
                    }
                    else {
                        if (this.colOffset &lt; 0 &amp;&amp; b){
                            v.fc = this.colVisibility(v.fc[0], v.fc[1], 1, true);
                            v.lc = this.colVisibility(v.fc[0], v.fc[1], 1, false);
                        }
                        else {
                            v.fc = this.colVisibility(0, this.getLeft() + this.lineSize + this.getLeftCaptionWidth(), 1, true);
                            v.lc = (v.fc != null) ? this.colVisibility(v.fc[0], v.fc[1], 1, false) : null;
                        }
                    }
                    this.colOffset = 100;
                }

                if (this.rowOffset != 100){
                    if (this.rowOffset &gt; 0 &amp;&amp; b) {
                        v.lr = this.rowVisibility(v.lr[0], v.lr[1],  -1, true);
                        v.fr = this.rowVisibility(v.lr[0], v.lr[1],  -1, false);
                    }
                    else {
                        if(this.rowOffset &lt; 0 &amp;&amp; b){
                            v.fr = this.rowVisibility(v.fr[0], v.fr[1], 1, true);
                            v.lr = (v.fr != null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                        }
                        else {
                            v.fr = this.rowVisibility(0, this.getTop() + this.getTopCaptionHeight() + this.lineSize, 1, true);
                            v.lr = (v.fr != null) ? this.rowVisibility(v.fr[0], v.fr[1], 1, false) : null;
                        }
                    }
                    this.rowOffset = 100;
                }
            };

            this.calcOrigin = function(off,y){
                var top = this.getTop() + this.getTopCaptionHeight(), left = this.getLeft() + this.getLeftCaptionWidth(),
                    o = ui.calcOrigin(this.getColX(0) - this.lineSize, y - this.lineSize, this.psWidth_,
                                      this.rowHeights[off] + 2 * this.lineSize, this.scrollManager.getSX(), this.scrollManager.getSY(),
                                      this, top, left, this.getBottom(), this.getRight());
                this.scrollManager.scrollTo(o[0], o[1]);
            };

            this.$se = function(row,col,e){
                if (row &gt;= 0){
                    this.stopEditing(true);
                    if (this.editors != null &amp;&amp; this.editors.shouldDo(pkg.START_EDITING, row, col, e)) {
                        return this.startEditing(row, col);
                    }
                }
                return false;
            };

            this.getXOrigin = function () { return this.scrollManager.getSX(); };
            this.getYOrigin = function () { return this.scrollManager.getSY(); };
            
            /**
             * Get a preferred width the given column wants to have
             * @param  {Integer} col a column 
             * @return {Integer} a preferred width of the given column
             * @method getColPSWidth 
             */
            this.getColPSWidth =  function (col){
                return this.getPSSize(col, false);
            };
            
            /**
             * Get a preferred height the given row wants to have
             * @param  {Integer} col a row 
             * @return {Integer} a preferred height of the given row
             * @method getRowPSHeight 
             */
            this.getRowPSHeight = function (row){
                return this.getPSSize(row, true);
            };

            this.recalc = function(){
                if(this.isUsePsMetric) this.rPsMetric();
                else this.rCustomMetric();
                this.rPs();
            };

            /**
             * Get number of rows in the given grid
             * @return {Integer} a number of rows
             * @method getGridRows
             */
            this.getGridRows = function (){ return this.model != null ? this.model.rows : 0; };

            /**
             * Get number of columns in the given grid
             * @return {Integer} a number of columns
             * @method getGridColumns
             */
            this.getGridCols = function (){ return this.model != null ? this.model.cols : 0; };

            /**
             * Get the  given grid row height
             * @param  {Integer} row a grid row
             * @return {Integer} a height of the given row
             * @method getRowHeight
             */
            this.getRowHeight = function(row){
                this.validate();
                return this.rowHeights[row];
            };

            /**
             * Get the given grid column width
             * @param  {Integer} col a grid column
             * @return {Integer} a width of the given column
             * @method getColWidth
             */
            this.getColWidth = function(col){
                this.validate();
                return this.colWidths[col];
            };

            this.getCellsVisibility = function(){
                this.validate();
                return this.visibility;
            };

            /**
             * Get the given column top-left corner x coordinate
             * @param  {Integer} col a column
             * @return {Integer} a top-left corner x coordinate of the given column
             * @method getColX
             */
            this.getColX = function (col){
                this.validate();
                return this.getColX_(col);
            };

            /**
             * Get the given row top-left corner y coordinate
             * @param  {Integer} row a row
             * @return {Integer} a top-left corner y coordinate of the given column
             * @method getColX
             */
            this.getRowY = function (row){
                this.validate();
                return this.getRowY_(row);
            };

            this.childInputEvent = function(e){
                if (this.editingRow &gt;= 0) {
                    if (this.editors.shouldDo(pkg.CANCEL_EDITING, this.editingRow, this.editingCol, e)) {
                        this.stopEditing(false);
                    }
                    else {
                        if (this.editors.shouldDo(pkg.FINISH_EDITING, this.editingRow, this.editingCol, e)) {
                            this.stopEditing(true);
                        }
                    }
                }
            };

            this.dataToPaint = function(row,col){
                return this.model.get(row, col);
            };

            this.iColVisibility = function(off){
                this.colOffset = (this.colOffset == 100) ? this.colOffset = off 
                                                         : ((off != this.colOffset) ? 0 : this.colOffset);
            };

            this.iRowVisibility = function(off){
                this.rowOffset = (this.rowOffset == 100) ? off 
                                                         : (((off + this.rowOffset) === 0) ? 0 : this.rowOffset);
            };

            /**
             * Get top grid caption height. Return zero if no top caption element has been defined
             * @return {Integer} a top caption height
             * @protected
             * @method  getTopCaptionHeight
             */
            this.getTopCaptionHeight = function(){
                return (this.topCaption != null &amp;&amp; this.topCaption.isVisible) ? this.topCaption.height : 0;
            };

            /**
             * Get left grid caption width. Return zero if no left caption element has been defined
             * @return {Integer} a left caption width
             * @protected
             * @method  getLeftCaptionWidth
             */
            this.getLeftCaptionWidth = function(){
                return (this.leftCaption != null &amp;&amp; this.leftCaption.isVisible) ? this.leftCaption.width : 0;
            };

            this.paint = function(g){
                this.vVisibility();
                if (this.visibility.hasVisibleCells()) {
                    var dx = this.scrollManager.getSX(), dy = this.scrollManager.getSY(), 
                        th = this.getTopCaptionHeight(),
                        tw = this.getLeftCaptionWidth();

                    try {
                        g.save();
                        g.translate(dx, dy);
                        
                        if (th &gt; 0 || tw &gt; 0) {
                            g.clipRect(tw - dx, th - dy, this.width  - tw, this.height - th);
                        }

                        this.paintSelection(g);
                        this.paintData(g);
                        if (this.drawHorLines || this.drawVerLines) this.paintNet(g);
                        this.paintMarker(g);
                    }
                    finally {
                        g.restore();
                    }
                }
            };

            this.catchScrolled = function (psx, psy){
                var offx = this.scrollManager.getSX() - psx, offy = this.scrollManager.getSY() - psy;
                if (offx !== 0) this.iColVisibility(offx &gt; 0 ? 1 :  - 1);
                if (offy !== 0) this.iRowVisibility(offy &gt; 0 ? 1 :  - 1);
                this.stopEditing(false);
                this.repaint();
            };

            this.isInvalidatedByChild = function (c){ return c != this.editor || this.isUsePsMetric; };

            /**
             * Stop editing a grid cell.
             * @param  {Boolean} applyData true if the edited data has to be applied as a new 
             * grid cell content
             * @protected
             * @method stopEditing
             */
            this.stopEditing = function(applyData){
                if (this.editors != null &amp;&amp; this.editingRow &gt;= 0 &amp;&amp; this.editingCol &gt;= 0){
                    try {
                        if (zebra.instanceOf(this.editor, pkg.Grid)) this.editor.stopEditing(applyData);
                        var data = this.getDataToEdit(this.editingRow, this.editingCol);
                        if(applyData){
                            this.setEditedData(this.editingRow, this.editingCol, 
                                               this.editors.fetchEditedValue(this.editingRow, 
                                                                             this.editingCol, 
                                                                             data, this.editor));
                        }
                        else { 
                            this.editors.editingCanceled(this.editingRow, this.editingCol, data, this.editor);
                        }
                        this.repaintRows(this.editingRow, this.editingRow);
                    }
                    finally {
                        this.editingCol = this.editingRow =  -1;
                        if (this.indexOf(this.editor) &gt;= 0) this.remove(this.editor);
                        this.editor = null;
                        this.requestFocus();
                    }
                }
            };

            /**
             * Set if horizontal and vertical lines have to be painted
             * @param {Boolean} hor true if horizontal lines have to be painted
             * @param {Boolean} ver true if vertical lines have to be painted
             * @method setDrawLines
             */
            this.setDrawLines = function(hor, ver){
                if (this.drawVerLines != hor || this.drawHorLines != ver) {
                    this.drawHorLines = hor;
                    this.drawVerLines = ver;
                    this.repaint();
                }
            };

            this.getLines = function (){ return this.getGridRows(); };
            this.getLineSize = function (line){ return 1; };
            this.getMaxOffset = function (){ return this.getGridRows() - 1; };

            this.posChanged = function (target,prevOffset,prevLine,prevCol){
                var off = this.position.currentLine;
                if (off &gt;= 0) {
                    this.calcOrigin(off, this.getRowY(off));
                    this.select(off, true);
                    this.repaintRows(prevOffset, off);
                }
            };

            this.keyPressed = function(e){
                if (this.position != null){
                    var cl = this.position.currentLine;
                    switch(e.code) {
                        case KE.LEFT: this.position.seek( - 1);break;
                        case KE.UP: this.position.seekLineTo(Position.UP);break;
                        case KE.RIGHT: this.position.seek(1);break;
                        case KE.DOWN: this.position.seekLineTo(Position.DOWN);break;
                        case KE.PAGEUP: this.position.seekLineTo(Position.UP, this.pageSize(-1));break;
                        case KE.PAGEDOWN: this.position.seekLineTo(Position.DOWN, this.pageSize(1));break;
                        case KE.END:  if(e.isControlPressed()) this.position.setOffset(this.getLines() - 1);break;
                        case KE.HOME: if(e.isControlPressed()) this.position.setOffset(0);break;
                    }
                    this.$se(this.position.currentLine, this.position.currentCol, e);
                    if (cl != this.position.currentLine &amp;&amp; cl &gt;= 0){
                        for(var i = 0;i &lt; this.getGridRows(); i++){
                            if(i != this.position.currentLine) this.select(i, false);
                        }
                    }
                }
            };

            /**
             * Checks if the given grid row is selected
             * @param  {Inetger}  row a grid row
             * @return {Boolean}  true if the given row is selected
             * @method isSelected
             */
            this.isSelected = function(row){ 
                return (this.selected == null) ? row == this.selectedIndex : this.selected[row] &gt; 0; 
            };

            /**
             * Repaint range of grid rows
             * @param  {Integer} r1 the first row to be repainted
             * @param  {Integer} r2 the last row to be repainted
             * @method repaintRows
             */
            this.repaintRows = function (r1,r2){
                if (r1 &lt; 0) r1 = r2;
                if (r2 &lt; 0) r2 = r1;
                if (r1 &gt; r2){
                    var i = r2;
                    r2 = r1;
                    r1 = i;
                }
                var rows = this.getGridRows();
                if (r1 &lt; rows){
                    if (r2 &gt;= rows) r2 = rows - 1;
                    var y1 = this.getRowY(r1), y2 = ((r1 == r2) ? y1 : this.getRowY(r2)) + this.rowHeights[r2];
                    this.repaint(0, y1 + this.scrollManager.getSY(), this.width, y2 - y1);
                }
            };

            /**
             * Detect a cell by the given location
             * @param  {Integer} x a x coordinate relatively the grid component
             * @param  {Integer} y a y coordinate relatively the grid component
             * @return {Array} an array that contains detected grid cell row as 
             * the first element and a grid column as the second element. The 
             * row and column values are set to -1 if no grid cell can be found 
             * at the given location
             * @method cellByLocation
             */
            this.cellByLocation = function(x,y){
                this.validate();
                var dx = this.scrollManager.getSX(), dy = this.scrollManager.getSY(), v = this.visibility,
                    ry1 = v.fr[1] + dy, rx1 = v.fc[1] + dx, row =  -1, col =  -1,
                    ry2 = v.lr[1] + this.rowHeights[v.lr[0]] + dy,
                    rx2 = v.lc[1] + this.colWidths[v.lc[0]] + dx;

                if (y &gt; ry1 &amp;&amp; y &lt; ry2) {
                    for(var i = v.fr[0];i &lt;= v.lr[0]; ry1 += this.rowHeights[i] + this.lineSize,i ++ ){
                        if(y &gt; ry1 &amp;&amp; y &lt; ry1 + this.rowHeights[i]) {
                            row = i;
                            break;
                        }
                    }
                }
                if (x &gt; rx1 &amp;&amp; x &lt; rx2){
                    for(var i = v.fc[0];i &lt;= v.lc[0]; rx1 += this.colWidths[i] + this.lineSize, i++ ){
                        if(x &gt; rx1 &amp;&amp; x &lt; rx1 + this.colWidths[i]) {
                            col = i;
                            break;
                        }
                    }
                }
                return (col &gt;= 0 &amp;&amp; row &gt;= 0) ? [row, col] : null;
            };

            this.doLayout = function(target){
                var topHeight = (this.topCaption != null &amp;&amp; this.topCaption.isVisible) ? this.topCaption.getPreferredSize().height : 0,
                    leftWidth = (this.leftCaption != null &amp;&amp; this.leftCaption.isVisible) ? this.leftCaption.getPreferredSize().width : 0;

                if (this.topCaption != null){
                    this.topCaption.setLocation(this.getLeft() + leftWidth, this.getTop());
                    this.topCaption.setSize(Math.min(target.width - this.getLeft() - this.getRight() - leftWidth, this.psWidth_), topHeight);
                }

                if(this.leftCaption != null){
                    this.leftCaption.setLocation(this.getLeft(), this.getTop() + topHeight);
                    this.leftCaption.setSize(leftWidth, Math.min(target.height - this.getTop() - this.getBottom() - topHeight, this.psHeight_));
                }

                if (this.stub != null &amp;&amp; this.stub.isVisible)
                {
                    if (this.topCaption  != null &amp;&amp; this.topCaption.isVisible &amp;&amp; 
                        this.leftCaption != null &amp;&amp; this.leftCaption.isVisible   ) 
                    {
                        this.stub.setLocation(this.getLeft(), this.getTop());
                        this.stub.setSize(this.topCaption.x - this.stub.x, this.leftCaption.y - this.stub.y);
                    }
                    else {
                        this.stub.setSize(0, 0);   
                    }
                }

                if (this.editors != null &amp;&amp; this.editor != null &amp;&amp; 
                    this.editor.parent == this &amp;&amp; this.editor.isVisible)
                {
                    var w = this.colWidths[this.editingCol], h = this.rowHeights[this.editingRow],
                        x = this.getColX_(this.editingCol), y = this.getRowY_(this.editingRow);

                    if (this.isUsePsMetric){
                        x += this.cellInsetsLeft;
                        y += this.cellInsetsTop;
                        w -= (this.cellInsetsLeft + this.cellInsetsRight);
                        h -= (this.cellInsetsTop + this.cellInsetsBottom);
                    }
                    this.editor.setLocation(x + this.scrollManager.getSX(), y + this.scrollManager.getSY());
                    this.editor.setSize(w, h);
                }
            };

            this.canHaveFocus = function (){ return this.editor == null; };

            /**
             * Clear grid row or rows selection
             * @method clearSelect
             */
            this.clearSelect = function (){
                if(this.selectedIndex &gt;= 0){
                    var prev = this.selectedIndex;
                    this.selectedIndex =  - 1;
                    this._.fired(this, -1, 0, false);
                    this.repaintRows(-1, prev);
                }
            };

            /**
             * Mark as selected or unselected the given grid row.
             * @param  {Integer} row a grid row
             * @param  {boolean} b   a selection status
             * @method select
             */
            this.select = function (row, b){
                if(this.isSelected(row) != b){
                    if(this.selectedIndex &gt;= 0) this.clearSelect();
                    if (b) {
                        this.selectedIndex = row;
                        this._.fired(this, row, 1, b);
                    }
                }
            };

            this.laidout = function () { this.vVisibility(); };

            this.mouseClicked  = function(e) { 
                this.pressedRow =  -1;
                if (this.visibility.hasVisibleCells()){
                    this.stopEditing(true);

                    if (e.isActionMask()){
                        var p = this.cellByLocation(e.x, e.y);
                        if (p != null){
                            if(this.position != null){
                                var off = this.position.currentLine;
                                if (off == p[0]) this.calcOrigin(off, this.getRowY(off));
                                else {
                                    this.clearSelect();
                                    this.position.setOffset(p[0]);
                                }
                            }

                            if (this.$se(p[0], p[1], e) === false){
                                this.pressedRow = p[0];
                                this.pressedCol = p[1];
                            }
                        }
                    }
                }

                // !!! most likely it is buggy !
                // if (this.$se(this.pressedRow, this.pressedCol, e)) {
                //     this.pressedRow =  -1; 
                // }
            };
            
            this.calcPreferredSize = function (target){
                return { width : this.psWidth_  + ((this.leftCaption != null &amp;&amp; this.leftCaption.isVisible) ? this.leftCaption.getPreferredSize().width : 0),
                         height: this.psHeight_ + ((this.topCaption != null &amp;&amp; this.topCaption.isVisible)   ? this.topCaption.getPreferredSize().height : 0) };
            };

            /**
             * Paint vertical and horizontal grid component lines
             * @param  {2DContext} g a HTML5 canvas 2d context 
             * @method paintNet
             * @protected
             */
            this.paintNet = function(g){
                var v = this.visibility, topX = v.fc[1] - this.lineSize, topY = v.fr[1] - this.lineSize,
                    botX = v.lc[1] + this.colWidths[v.lc[0]], botY = v.lr[1] + this.rowHeights[v.lr[0]],
                    prevWidth = g.lineWidth;

                g.setColor(this.lineColor);
                g.lineWidth = this.lineSize;
                g.beginPath();

                if (this.drawHorLines) {
                    var y = topY + this.lineSize/2;
                    for(var i = v.fr[0];i &lt;= v.lr[0]; i ++ ){
                        g.moveTo(topX, y)
                        g.lineTo(botX, y);
                        y += this.rowHeights[i] + this.lineSize;
                    }
                    g.moveTo(topX, y);
                    g.lineTo(botX, y);
                }

                if (this.drawVerLines) {
                    topX += this.lineSize/2;
                    for(var i = v.fc[0];i &lt;= v.lc[0]; i ++ ){
                        g.moveTo(topX, topY);
                        g.lineTo(topX, botY);
                        topX += this.colWidths[i] + this.lineSize;
                    }
                    g.moveTo(topX, topY);
                    g.lineTo(topX, botY);
                }
                g.stroke();
                g.lineWidth = prevWidth;
            };

            /**
             * Paint grid data
             * @param  {2DContext} g a HTML5 canvas 2d context 
             * @method paintData
             * @protected
             */
            this.paintData = function(g){
                var y = this.visibility.fr[1] + this.cellInsetsTop, addW = this.cellInsetsLeft + this.cellInsetsRight,
                    addH = this.cellInsetsTop + this.cellInsetsBottom, ts = g.getTopStack(), cx = ts.x, cy = ts.y,
                    cw = ts.width, ch = ts.height, res = {};

                //!!!!
                //var desk = zebra.ui.findCanvas(this);
                // var can  = document.createElement(&quot;canvas&quot;)
                // var gg   = can.getContext(&quot;2d&quot;), ggg = g, g = gg;
                // gg.init();
                // can.width  = this.visibility.lc[1] - this.visibility.fc[1];
                // can.height = this.visibility.lr[1] - y;
                // gg.fillStyle = &quot;red&quot;;
                // gg.fillRect(0, 0, can.width, can.height);

                for(var i = this.visibility.fr[0];i &lt;= this.visibility.lr[0] &amp;&amp; y &lt; cy + ch; i++){
                    if(y + this.rowHeights[i] &gt; cy){
                        var x = this.visibility.fc[1] + this.cellInsetsLeft, notSelectedRow = this.isSelected(i) === false;

                        for(var j = this.visibility.fc[0];j &lt;= this.visibility.lc[0]; j ++ ){
                            if (notSelectedRow){
                                var bg = this.provider.getCellColor(i, j);
                                if (bg != null){
                                    g.setColor(bg);
                                    g.fillRect(x - this.cellInsetsLeft, y - this.cellInsetsTop, 
                                               this.colWidths[j], this.rowHeights[i]);
                                }
                            }

                            var v = (i == this.editingRow &amp;&amp; 
                                     j == this.editingCol    ) ? null
                                                               : this.provider.getView(i, j, 
                                                                                       this.model.get(i, j)); //!!! tree grid dataToPaint has to be called 
                            if (v != null){
                                var w = this.colWidths[j] - addW, h = this.rowHeights[i] - addH;
                                MB.intersection(x, y, w, h, cx, cy, cw, ch, res);
                                if (res.width &gt; 0 &amp;&amp; res.height &gt; 0) {
                                    if (this.isUsePsMetric) v.paint(g, x, y, w, h, this);
                                    else 
                                    {
                                        var ax = this.provider.getXAlignment(i, j), 
                                            ay = this.provider.getYAlignment(i, j),
                                            vw = w, vh = h, xx = x, yy = y, id = -1,
                                            ps = (ax != L.NONE || ay != L.NONE) ? v.getPreferredSize()
                                                                                : null;
                                        if (ax != L.NONE){
                                            xx = x + L.xAlignment(ps.width, ax, w);
                                            vw = ps.width;
                                        }

                                        if (ay != L.NONE){
                                            yy = y + L.yAlignment(ps.height, ay, h);
                                            vh = ps.height;
                                        }

                                        if (xx &lt; res.x || yy &lt; res.y || (xx + vw) &gt; (x + w) ||  (yy + vh) &gt; (y + h)) {
                                            id = g.save();
                                            g.clipRect(res.x, res.y, res.width, res.height);
                                        }

                                        v.paint(g, xx, yy, vw, vh, this);

                                        if (id &gt;= 0) {
                                           g.restore();
                                        }
                                     }
                                }
                            }
                            x += (this.colWidths[j] + this.lineSize);
                        }
                    }
                    y += (this.rowHeights[i] + this.lineSize);
                }
            };

            this.paintMarker = function(g){
                var markerView = this.views[&quot;marker&quot;];
                if (markerView != null &amp;&amp; this.position != null &amp;&amp; this.position.offset &gt;= 0 &amp;&amp; this.hasFocus()){
                    var offset = this.position.offset, v = this.visibility;
                    if (offset &gt;= v.fr[0] &amp;&amp; offset &lt;= v.lr[0]){
                        g.clipRect(this.getLeftCaptionWidth() - this.scrollManager.getSX(),
                                   this.getTopCaptionHeight() - this.scrollManager.getSY(), this.width, this.height);

                        markerView.paint(g, v.fc[1], this.getRowY(offset),
                                        v.lc[1] - v.fc[1] + this.getColWidth(v.lc[0]),
                                        this.rowHeights[offset], this);
                    }
                }
            };

            this.paintSelection = function(g){
                if (this.editingRow &gt;= 0) return;
                var v = this.views[this.hasFocus()?&quot;onselection&quot;:&quot;offselection&quot;];
                if (v == null) return;

                for(var j = this.visibility.fr[0];j &lt;= this.visibility.lr[0]; j ++ ){
                    if (this.isSelected(j)) {
                        var x = this.visibility.fc[1], y = this.getRowY(j), h = this.rowHeights[j];
                        //!!! this code below can be used to implement cell oriented selection
                        for(var i = this.visibility.fc[0];i &lt;= this.visibility.lc[0]; i ++ ){
                            v.paint(g, x, y, this.colWidths[i], h, this);
                            x += this.colWidths[i] + this.lineSize;
                        }
                    }
                }
            };

            this.rPsMetric = function(){
                var cols = this.getGridCols(), rows = this.getGridRows();
                if (this.colWidths == null || this.colWidths.length != cols) this.colWidths = arr(cols, 0);
                if (this.rowHeights == null || this.rowHeights.length != rows) this.rowHeights = arr(rows, 0);
                var addW = this.cellInsetsLeft + this.cellInsetsRight,
                    addH = this.cellInsetsTop + this.cellInsetsBottom;

                for(var i = 0;i &lt; cols; i++ ) this.colWidths [i] = 0;
                for(var i = 0;i &lt; rows; i++ ) this.rowHeights[i] = 0;
                for(var i = 0;i &lt; cols; i++ ){
                    for(var j = 0;j &lt; rows; j ++ ){
                        var v = this.provider.getView(j, i, this.model.get(j, i));
                        if(v != null){
                            var ps = v.getPreferredSize();
                            ps.width += addW;
                            ps.height += addH;
                            if(ps.width &gt; this.colWidths[i]) this.colWidths [i] = ps.width;
                            if(ps.height &gt; this.rowHeights[j]) this.rowHeights[j] = ps.height;
                        }
                        else {
                            if ( pkg.Grid.DEF_COLWIDTH &gt; this.colWidths [i]) this.colWidths [i] = pkg.Grid.DEF_COLWIDTH;
                            if ( pkg.Grid.DEF_ROWHEIGHT &gt; this.rowHeights[j]) this.rowHeights[j] = pkg.Grid.DEF_ROWHEIGHT;
                        }
                    }
                }
            };

            this.getPSSize = function (rowcol,b){
                if (this.isUsePsMetric) return b ? this.getRowHeight(rowcol) : this.getColWidth(rowcol);
                else {
                    var max = 0, count = b ? this.getGridCols() : this.getGridRows();
                    for(var j = 0;j &lt; count; j ++ ){
                        var r = b ? rowcol : j, c = b ? j : rowcol,
                            v = this.provider.getView(r, c, this.model.get(r, c));

                        if(v != null){
                            var ps = v.getPreferredSize();
                            if(b){
                                if(ps.height &gt; max) max = ps.height;
                            }
                            else {
                                if(ps.width &gt; max) max = ps.width;
                            }
                        }
                    }
                    return max + this.lineSize * 2 + (b ? this.cellInsetsTop + this.cellInsetsBottom : this.cellInsetsLeft + this.cellInsetsRight);
                }
            };

            this.rCustomMetric = function(){
                var start = 0;
                if(this.colWidths != null){
                    start = this.colWidths.length;
                    if(this.colWidths.length != this.getGridCols()){
                        var na = arr(this.getGridCols(), 0);
                        zebra.util.arraycopy(this.colWidths, 0, na, 0, Math.min(this.colWidths.length, na.length));
                        this.colWidths = na;
                    }
                }
                else this.colWidths = arr(this.getGridCols(), 0);

                for(; start &lt; this.colWidths.length; start ++ ) {
                    this.colWidths[start] = pkg.Grid.DEF_COLWIDTH;
                }

                start = 0;
                if(this.rowHeights != null){
                    start = this.rowHeights.length;
                    if(this.rowHeights.length != this.getGridRows()){
                        var na = arr(this.getGridRows(), 0);
                        zebra.util.arraycopy(this.rowHeights, 0, na, 0, Math.min(this.rowHeights.length, na.length));
                        this.rowHeights = na;
                    }
                }
                else this.rowHeights = arr(this.getGridRows(), 0);
                for(; start &lt; this.rowHeights.length; start ++ ) this.rowHeights[start] = pkg.Grid.DEF_ROWHEIGHT;
            };

            this.pageSize = function(d){
                this.validate();
                if (this.visibility.hasVisibleCells()){
                    var off = this.position.offset;
                    if(off &gt;= 0){
                        var hh = this.visibleArea.height - this.getTopCaptionHeight(), sum = 0, poff = off;
                        for(; off &gt;= 0 &amp;&amp; off &lt; this.getGridRows() &amp;&amp; sum &lt; hh; sum += this.rowHeights[off] + this.lineSize,off += d);
                        return Math.abs(poff - off);
                    }
                }
                return 0;
            };

            /**
             * Set the given height for the specified grid row. The method has no effect
             * if the grid component is forced to use preferred size metric. 
             * @param {Integer} row a grid row
             * @param {Integer} h   a height of the grid row
             * @method setRowHeight
             */
            this.setRowHeight = function(row,h){
                if(h &lt; 0) throw new Error(&quot;Invalid row height: &quot; + h);

                if (this.isUsePsMetric === false){
                    this.validateMetric();
                    if(this.rowHeights[row] != h){
                        this.stopEditing(false);
                        this.psHeight_ += (h - this.rowHeights[row]);
                        this.rowHeights[row] = h;
                        this.cachedHeight = this.getTop() + this.getBottom() + this.psHeight_ +
                                            ((this.topCaption != null &amp;&amp; this.topCaption.isVisible) ? this.topCaption.getPreferredSize().height : 0);
                        if(this.parent != null) this.parent.invalidate();
                        this.iRowVisibility(0);
                        this.invalidateLayout();
                        this.repaint();
                    }
                }
            };

            /**
             * Set the given width for the specified grid column. The method has no effect
             * if the grid component is forced to use preferred size metric. 
             * @param {Integer} column a grid column
             * @param {Integer} w   a width of the grid column
             * @method setColWidth
             */
            this.setColWidth = function (col,w){
                if (w &lt; 0) throw new Error(&quot;Invalid col width: &quot; + w);

                if( !this.isUsePsMetric){
                    this.validateMetric();
                    if(this.colWidths[col] != w){
                        this.stopEditing(false);
                        this.psWidth_ += (w - this.colWidths[col]);
                        this.colWidths[col] = w;
                        this.cachedWidth = this.getRight() + this.getLeft() +
                                           this.psWidth_ + ((this.leftCaption != null &amp;&amp; this.leftCaption.isVisible) ? this.leftCaption.getPreferredSize().width : 0);
                        if(this.parent != null) this.parent.invalidate();
                        this.iColVisibility(0);
                        this.invalidateLayout();
                        this.repaint();
                    }
                }
            };
        },

        function (rows, cols){ 
            this.$this(new Matrix(rows, cols)); 
        },
        
        function (){ 
            this.$this(new Matrix(5, 5)); 
        },

        function (model){
            this.psWidth_ = this.psHeight_ = this.colOffset = this.rowOffset = this.pressedCol = this.selectedIndex = 0;
            this.visibleArea = this.selected = null;
            this._ = new Listeners();
            this.views = {};

            this.editingRow = this.editingCol = this.pressedRow = -1;
            this.editors = this.leftCaption = this.topCaption = this.colWidths = this.rowHeights = null;
            this.position = this.stub = null;
            this.visibility = new CellsVisibility();

            this.$super();

            this.add(L.NONE, new pkg.Grid.CornerPan());
            this.setModel(model);
            this.setViewProvider(new pkg.DefViews());
            this.setPosition(new Position(this));
            this.scrollManager = new ui.ScrollManager(this);
        },

        /**
         * Set the given titles for top or left grid header. If grid header 
         * has not been added it will be created.
         * @param {Integer} constr a header constraints. Can be:
         
        zebra.layout.TOP to express top grid caption 
        zebra.layout.LEFT to express left grid caption 

         * @param {Array} header captions titles 
         * @method setHeader
         */
        function setHeader(constr, titles) {
            var cap = new pkg.GridCaption(this);
            this.add(constr, cap);
            if (titles != null) {
                for (var i = 0; i &lt; titles.length; i++) cap.putTitle(i, titles[i]);
            }
            return cap;
        },

        function focused(){ 
            this.$super();
            this.repaint(); 
        },

        /**
         * Set the given editor provider. Editor provider is a way to customize 
         * cell editing.  
         * @param {Object} p an editor provider
         * @method setEditorProvider
         */
        function setEditorProvider(p){
            if(p != this.editors){
                this.stopEditing(true);
                this.editors = p;
            }
        },

        function setUsePsMetric(b){
            if (this.isUsePsMetric != b){
                this.isUsePsMetric = b;
                this.vrp();
            }
        },

        function setPosition(p){
            if(this.position != p){
                if (this.position != null)this.position._.remove(this);

                /**
                 * Virtual cursor position controller
                 * @readOnly
                 * @attribute position 
                 * @type {zebra.util.Position}
                 */
                this.position = p;
                if(this.position != null){
                    this.position._.add(this);
                    this.position.setMetric(this);
                }
                this.repaint();
            }
        },

        /**
         * Set the given cell view provider. Provider is a special class that says 
         * how grid cells content has to be rendered, aligned, colored
         * @param {Object} p a view provider
         * @method setViewProvider
         */
        function setViewProvider(p){
            if(this.provider != p){
                this.provider = p;
                this.vrp();
            }
        },

        /**
         * Set the given matrix model to be visualized and controlled 
         * with the grid component 
         * @param {zebra.data.Matrix|Array} d a model passed as an 
         * instance of zebra matrix model or an array that contains 
         * model rows as embedded arrays.
         * @method setModel 
         */
        function setModel(d){
            if (d != this.model) {
                this.clearSelect();
                if (Array.isArray(d)) d = new Matrix(d);
                if (this.model != null &amp;&amp; this.model._) this.model._.remove(this);
                this.model = d;
                if (this.model != null &amp;&amp; this.model._) this.model._.add(this);
                if (this.position != null) this.position.clearPos();
                if (this.model != null &amp;&amp; this.selected != null) this.selected = arr(this.model.rows, false);
                this.vrp();
            }
        },

        /**
         * Set the given top, left, right, bottom cell paddings
         * @param {Integer} p a top, left, right and bottom cell paddings
         * @method setCellPadding
         */
        function setCellPadding(p){
            this.setCellPaddings(p,p,p,p);
        },

        /**
         * Set the given top, left, right, bottom cell paddings
         * @param {Integer} t a top cell padding
         * @param {Integer} l a left cell padding
         * @param {Integer} b a bottom cell padding
         * @param {Integer} r a rightcell padding
         * @method setCellPaddings
         */
        function setCellPaddings(t,l,b,r){
            if (t != this.cellInsetsTop    || l != this.cellInsetsLeft ||
                b != this.cellInsetsBottom || r != this.cellInsetsRight)
            {
                this.cellInsetsTop = t;
                this.cellInsetsLeft = l;
                this.cellInsetsBottom = b;
                this.cellInsetsRight = r;
                this.vrp();
            }
        },

        function matrixResized(target,prevRows,prevCols){
            this.clearSelect();
            if (this.selected != null) this.selected = arr(this.model.rows, false);
            this.vrp();
            if (this.position != null) this.position.clearPos();
        },

        function cellModified(target,row,col,prevValue) {
            if (this.isUsePsMetric) this.invalidate();
        },

        function invalidate(){
            this.$super();
            this.iColVisibility(0);
            this.iRowVisibility(0);
        },

        /**
         * Set the given color to render the grid vertical and horizontal lines
         * @param {String} c a color
         * @method setLineColor
         */
        function setLineColor(c){
            if (c != this.lineColor){
                this.lineColor = c;
                if (this.drawVerLines || this.drawHorLines) this.repaint();
            }
        },

        function kidAdded(index,id,c){
            this.$super(index, id, c);
            if (L.TOP == id){
                this.topCaption = c;
                if (zebra.instanceOf(c, pkg.GridCaption)) c.setup(this, L.HORIZONTAL);
            }
            else {
                if (L.TEMPORARY == id) this.editor = c;
                else {
                    if (L.LEFT == id){
                        this.leftCaption = c;
                        if (zebra.instanceOf(c, pkg.GridCaption)) c.setup(this, L.VERTICAL);
                    }
                    else if (L.NONE === id) this.stub = c;
                }
            }
        },

        function kidRemoved(index,c){
            this.$super(index, c);
            if(c == this.editor) this.editor = null;
            else {
                if(c == this.topCaption){
                    if(zebra.instanceOf(c, pkg.GridCaption)) c.setup(null, L.HORIZONTAL);
                    this.topCaption = null;
                }
                else {
                    if(c == this.leftCaption){
                        if(zebra.instanceOf(c, pkg.GridCaption)) c.setup(null, L.VERTICAL);
                        this.leftCaption = null;
                    }
                    else if(c == this.stub) this.stub = null;
                }
            }
        },

        /**
         * Set the given grid lines size
         * @param {Integer} s a size
         * @method setLineSize
         */
        function setLineSize(s){
            if (s != this.lineSize){
                this.lineSize = s;
                this.vrp();
            }
        },

        /**
         * Start editing the given grid cell. Editing is initiated only if an editor 
         * provider has been set and the editor provider defines not-null UI component
         * as an editor for the given cell. 
         * @param  {Integer} row a grid cell row
         * @param  {Integer} col a grid cell column
         * @method startEditing
         */
        function startEditing(row,col){
            this.stopEditing(true);
            if(this.editors != null){
                var editor = this.editors.getEditor(this, row, col, this.getDataToEdit(row, col));
                if (editor != null){
                    this.editingRow = row;
                    this.editingCol = col;
                    if (zebra.instanceOf(editor, ui.ExternalEditor)) {
                        var p = L.getAbsLocation(this.getColX(col) + this.scrollManager.getSX(), this.getRowY(row) + this.scrollManager.getSY(), this);
                        editor.setLocation(p[0], p[1]);
                        ui.makeFullyVisible(ui.findCanvas(this), editor);
                        this.editor = editor;
                        ui.findCanvas(this).getLayer(WinLayer.ID).addWin(&quot;modal&quot;, editor, this);
                    }
                    else{
                        this.add(L.TEMPORARY, editor);
                        this.repaintRows(this.editingRow, this.editingRow);
                    }
                    ui.focusManager.requestFocus(editor);
                    return true;
                }
            }
            return false;
        },

        /**
         * Get currently editing grid cell 
         * @return {Array} am editing grid cell row and column as the first 
         * and the second array elements correspondingly. null if there is no 
         * any editing grid cell
         * @method getEditingCell
         */
        function getEditingCell(){
            return (this.editingRow &gt;= 0 &amp;&amp; this.editingCol &gt;= 0) ? [this.editingRow, this.editingCol] : null;
        },

        function winOpened(winLayer,target,b){
            if (this.editor == target &amp;&amp;  b === false) this.stopEditing(this.editor.isAccepted());
        },

        function winActivated(winLayer,target,b){},
        function getDataToEdit(row,col){ return this.model.get(row, col); },
        function setEditedData(row,col,value){ this.model.put(row, col, value); }
]);
pkg.Grid.prototype.setViews = ui.$ViewsSetter;


/**
 * Special UI panel that manages to stretch grid columns to occupy the whole panel space. 
 * @constructor
 * @param {zebra.ui.Grid} grid a grid component that has to be added in the panel
 * @class GridStretchPan
 * @extends {zebra.ui.Panel}
 */
pkg.GridStretchPan = Class(ui.Panel, zebra.layout.Layout, [
    function $prototype() {
        this.calcPreferredSize = function (target){
            this.recalcPS();
            return (target.kids.length === 0 || !target.grid.isVisible) ? { width:0, height:0 }
                                                                        : { width:this.strPs.width, 
                                                                            height:this.strPs.height };
        };

        this.doLayout = function(target){
            this.recalcPS();
            if (target.kids.length &gt; 0){
                var grid = this.grid;
                if (grid.isVisible){
                    var left = target.getLeft(), top = target.getTop();
                    grid.setLocation(left, top);
                    grid.setSize(target.width  - left - target.getRight(),
                                 target.height - top  - target.getBottom());

                    for(var i = 0; i &lt; this.widths.length; i++) {
                        grid.setColWidth(i, this.widths[i]);
                    }

                    if (this.heights != null){
                        for(var i = 0;i &lt; this.heights.length; i++) {
                            grid.setRowHeight(i, this.heights[i]);
                        }
                    }
                }
            }
        };

        this.captionResized = function(src, col, pw){
            var grid = this.grid;
            if (col &lt; this.widths.length - 1){
                var w = grid.getColWidth(col), dt = w - pw;
                if (dt &lt; 0) grid.setColWidth(col + 1, grid.getColWidth(col + 1) - dt);
                else {
                    var ww = grid.getColWidth(col + 1) - dt, mw = this.getMinWidth();
                    if (ww &lt; mw) {
                        grid.setColWidth(col, w - (mw - ww));
                        grid.setColWidth(col + 1, mw);
                    }
                    else grid.setColWidth(col + 1, ww);
                }
                this.proportions = null;
            }
        };

        this.calcColProportions = function (targetAreaW,targetAreaH){
            var g = this.grid, cols = g.getGridCols(), sw = 0;
            for(var i = 0;i &lt; cols; i++){
                var w = g.getColWidth(i);
                if (w === 0) w = g.getColPSWidth(i);
                sw += w;
            }

            var props = Array(cols);
            for(var i = 0;i &lt; cols; i++){
                var w = g.getColWidth(i);
                if (w === 0) w = g.getColPSWidth(i);
                props[i] = w / sw;
            }
            return props;
        };

        this.calcRowHeights = function(targetAreaW,targetAreaH,widths) { 
            return null;
        };

        this.getMinWidth = function (){
            return zebra.instanceOf(this.grid.topCaption, pkg.GridCaption) ? this.grid.topCaption.minSize
                                                                           : 10;
        };

        this.calcColWidths = function (targetAreaW,targetAreaH){
            var grid = this.grid, w = Array(grid.getGridCols()),
                ew = targetAreaW - (this.proportions.length + 1) * grid.lineSize, sw = 0;

            for(var i = 0; i &lt; this.proportions.length; i++){
                if (this.proportions.length - 1 == i) w[i] = ew - sw;
                else {
                    var cw = (ew * this.proportions[i]);
                    w[i] = cw;
                    sw += cw;
                }
            }
            return w;
        };

        this.recalcPS = function (){
            var grid = this.grid;
            if (grid == null || grid.isVisible === false) return;

            var p = this.parent, isScr = zebra.instanceOf(p, ui.ScrollPan),
                taWidth   = (isScr ? p.width - p.getLeft() - p.getRight() - this.getRight() - this.getLeft()
                                   : this.width - this.getRight() - this.getLeft()),
                taHeight = (isScr  ? p.height - p.getTop() - p.getBottom() - this.getBottom() - this.getTop()
                                   : this.height - this.getBottom() - this.getTop());

            if (this.strPs != null &amp;&amp; this.prevTargetAreaSize.width == taWidth &amp;&amp;
                                      this.prevTargetAreaSize.height == taHeight  ) {
                return;
            }

            if (this.proportions == null || this.proportions.length != grid.getGridCols()) {
                this.proportions = this.calcColProportions(taWidth, taHeight);
            }

            this.prevTargetAreaSize.width = taWidth;
            this.prevTargetAreaSize.height = taHeight;
            this.widths  = this.calcColWidths (taWidth, taHeight);
            this.heights = this.calcRowHeights(taWidth, taHeight, this.widths);
            this.strPs = this.summarizePS(taWidth, taHeight, this.widths, this.heights);

            if (isScr === true &amp;&amp; p.height &gt; 0 &amp;&amp; p.vBar &amp;&amp; p.autoHide === false &amp;&amp; taHeight &lt; this.strPs.height){
                taWidth -= p.vBar.getPreferredSize().width;
                this.widths  = this.calcColWidths(taWidth, taHeight);
                this.heights = this.calcRowHeights(taWidth, taHeight, this.widths);
                this.strPs   = this.summarizePS(taWidth, taHeight, this.widths, this.heights);
            }
        };

        this.summarizePS = function (targetAreaW,targetAreaH,widths,heights){
            var ps = { width: targetAreaW, height:0 }, grid = this.grid;
            if (heights != null){
                for(var i = 0;i &lt; heights.length; i++) ps.height += heights[i];
                if (grid.topCaption != null &amp;&amp; grid.topCaption.isVisible) {
                    ps.height += grid.topCaption.getPreferredSize().height;
                }
                ps.height += (grid.getTop() + grid.getBottom());
            }
            else ps.height = grid.getPreferredSize().height;
            return ps;
        };
    },

    function (grid){
        this.$super(this);
        this.heights = [];
        this.widths  = [];
        this.grid = grid;
        this.proportions = this.strPs = null;
        this.prevTargetAreaSize = { width:0, height:0 };
        this.add(grid);
    },

    function kidAdded(index,constr,l){
        this.proportions = null;
        if (l.topCaption != null) l.topCaption._.add(this);
        this.scrollManager = l.scrollManager;
        this.$super(index, constr, l);
    },

    function kidRemoved(i,l){
        this.proportions = null;
        if(l.topCaption != null) l.topCaption._.remove(this);
        this.scrollManager = null;
        this.$super(i, l);
    },

    function invalidate(){
        this.strPs = null;
        this.$super();
    }
]);

pkg.GridCapView = Class(ui.View, [
    function $prototype() {
        this.paint = function(g,x,y,w,h,d) {
            if (d.orient == L.HORIZONTAL) {
                if (this.hgradient == null) {
                    this.hgradient = new ui.Gradient(this.color1, this.color2,  L.VERTICAL);       
                }
                this.hgradient.paint(g,x,y,w,h,d);
                g.setColor(this.lineColor1);
                g.drawLine(x + w, y, x + w, y + h);
                g.setColor(this.lineColor2);
                g.drawLine(x, y, x + w, y);
            }
            else {
                if (this.vgradient == null) {
                    this.vgradient = new ui.Gradient(this.color1, this.color2,  L.HORIZONTAL);       
                }
                this.vgradient.paint(g,x,y,w,h,d);
                g.setColor(this.lineColor1);
                g.drawLine(x, y + h, x + w, y + h);
                g.setColor(this.lineColor2);
                g.drawLine(x, y, x, y + h);
            }
        };
    },

    function() {
        this.$this(&quot;rgba(255, 255, 255, 0.8)&quot;, &quot;rgba(255, 255, 255, 0.0)&quot;);
    },

    function(col1, col2) {
        this.gap = 6;
        this.color1 = col1;
        this.color2 = col2;
        this.lineColor1 = &quot;black&quot;;
        this.lineColor2 = &quot;#CCCCCC&quot;;
    }
]);

})(zebra(&quot;ui.grid&quot;), zebra.Class, zebra(&quot;ui&quot;));

</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
